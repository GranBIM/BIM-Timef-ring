<!DOCTYPE html>
<html lang="nb">
<head>
    <meta charset="UTF-8">
    <title>BIMføring tidsregistrering</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        * { box-sizing: border-box; }

        :root{
            --bg: #f3f4f6;
            --text: #111827;
            --muted: #4b5563;
            --card: #ffffff;
            --border: #d1d5db;
            --border-soft: #e5e7eb;
            --hover: #f3f4f6;
            --btn-bg: #f9fafb;
            --shadow: 0 1px 3px rgba(15,23,42,0.08);

            --dot-blue: #2563eb;
            --dot-orange: #f97316;
            --dot-green: #16a34a;

            --danger: #dc2626;
            --danger-border: #b91c1c;

            --excel: #217346;
            --excel-border: #14552f;

            --modal-backdrop: rgba(15,23,42,0.3);

            --chart-hand: #111827;

            --timebar-base: #e5e7eb;

            --comment-pink: #ec4899;

            --select-bg: #ffffff;
            --select-text: #111827;

            --btn-copy-bg: #6b7280; 

            --fav-divider: #000000;
        
            --outdated-bg: rgba(156,163,175,0.20);

            --glass-surface-rgb: 255,255,255;
            --glass-border-rgb: 255,255,255;
            --glass-ui-alpha: 0.28;
            --glass-border-alpha: 0.36;
            --glass-ui-blur: 1px;
}

        body.theme-dark{
            --bg: #0b1220;
            --text: #ffffff;
            --muted: #ffffff;
            --card: #0f172a;
            --border: #334155;
            --border-soft: #1f2937;
            --hover: rgba(148,163,184,0.10);
            --btn-bg: rgba(148,163,184,0.12);
            --shadow: 0 1px 3px rgba(0,0,0,0.35);

            --modal-backdrop: rgba(0,0,0,0.32);

            --chart-hand: #ffffff;

            --timebar-base: #1f2937;

            --select-bg: #0f172a;
            --select-text: #ffffff;

            --btn-copy-bg: #4b5563;

            --fav-divider: #ffffff;
        
            --outdated-bg: rgba(156,163,175,0.16);

            --glass-surface-rgb: 15,23,42;
            --glass-border-rgb: 255,255,255;
            --glass-ui-alpha: 0.22;
            --glass-border-alpha: 0.26;
            --glass-ui-blur: 1px;
}

        body.theme-black{
            --bg: #000000;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --card: #000000;
            --border: #333333;
            --border-soft: #1f2937;
            --hover: #111111;
            --btn-bg: #111111;
            --shadow: none;

            --modal-backdrop: rgba(0,0,0,0.45);

            --chart-hand: #e5e7eb;

            --timebar-base: #1f2937;

            --select-bg: #000000;
            --select-text: #e5e7eb;

            --fav-divider: #ffffff;
        
            --outdated-bg: rgba(156,163,175,0.12);

            --glass-surface-rgb: 0,0,0;
            --glass-border-rgb: 255,255,255;
            --glass-ui-alpha: 0.20;
            --glass-border-alpha: 0.22;
            --glass-ui-blur: 1px;
}
        
        body.theme-black .card, 
        body.theme-black .modal {
            border: 1px solid #333;
        
            position: relative;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 1.5rem;
            background: var(--bg);
            color: var(--text);
        }

        body.custom-page-bg-active{
            background: transparent;
        }
        #customPageBackgroundLayer{
            position: fixed;
            inset: 0;
            z-index: -10;
            display: none;
            overflow: hidden;
            background: var(--bg);
            pointer-events: none;
        }
        body.custom-page-bg-active #customPageBackgroundLayer{
            display: block;
        }
        #customPageBackgroundLayer .custom-page-bg-fill,
        #customPageBackgroundLayer .custom-page-bg-media{
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }
        #customPageBackgroundLayer .custom-page-bg-fill{
            background: var(--bg);
        }
        #customPageBackgroundLayer .custom-page-bg-media{
            object-fit: cover;
            display: none;
            background: transparent;
        }
        body.glass-mode-active .card,
        body.glass-mode-active .modal,
        body.glass-mode-active .btn-secondary,
        body.glass-mode-active .modal-button-primary,
        body.glass-mode-active .btn-stepper,
        body.glass-mode-active input:not([type="checkbox"]):not([type="radio"]):not([type="range"]),
        body.glass-mode-active select,
        body.glass-mode-active textarea{
            background: rgba(var(--glass-surface-rgb), var(--glass-ui-alpha)) !important;
            border-color: rgba(var(--glass-border-rgb), var(--glass-border-alpha)) !important;
            backdrop-filter: blur(var(--glass-ui-blur, 12px)) saturate(130%);
            -webkit-backdrop-filter: blur(var(--glass-ui-blur, 12px)) saturate(130%);
        }
        body.glass-mode-active .card,
        body.glass-mode-active .modal{
            box-shadow: 0 10px 28px rgba(0,0,0,0.20), inset 0 1px 0 rgba(255,255,255,0.06);
        }
        body.glass-mode-active .btn-secondary:disabled{
            opacity: 0.55;
        }
        body.glass-mode-active .personal-bg-panel,
        body.glass-mode-active .personal-bg-color-controls,
        body.glass-mode-active .personal-customize-scroll-panel,
        body.glass-mode-active #taskSuggestions{
            background: rgba(var(--glass-surface-rgb), calc(var(--glass-ui-alpha) + 0.06)) !important;
            border-color: rgba(var(--glass-border-rgb), calc(var(--glass-border-alpha) + 0.06)) !important;
            backdrop-filter: blur(var(--glass-ui-blur, 12px)) saturate(130%);
            -webkit-backdrop-filter: blur(var(--glass-ui-blur, 12px)) saturate(130%);
        }
        body.glass-mode-active #taskSuggestions{
            /* Forslaglisten skal være helt uten gjennomsiktighet for bedre lesbarhet */
            background: var(--card) !important;
            border-color: var(--border) !important;
            box-shadow: 0 10px 28px rgba(0,0,0,0.20), inset 0 1px 0 rgba(255,255,255,0.06);
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.glass-solid-active .card,
        body.glass-solid-active .modal,
        body.glass-solid-active .btn-secondary,
        body.glass-solid-active .modal-button-primary,
        body.glass-solid-active .btn-stepper,
        body.glass-solid-active input:not([type="checkbox"]):not([type="radio"]):not([type="range"]),
        body.glass-solid-active select,
        body.glass-solid-active textarea,
        body.glass-solid-active .personal-bg-panel,
        body.glass-solid-active .personal-bg-color-controls,
        body.glass-solid-active .personal-customize-scroll-panel{
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.glass-solid-active.personal-strong-overlay-blur #settingsOverlay.overlay.show .modal,
        body.glass-solid-active.personal-strong-overlay-blur #personalCustomizeOverlay.overlay.show .modal{
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }
        body.glass-mode-active .task-input-wrapper{
            z-index: 2100;
        }
        body.glass-mode-active #taskSuggestions{
            z-index: 2150;
        }
        body.glass-mode-active #personalBgGlassButton.active{
            background: rgba(34,197,94,0.18) !important;
            border-color: rgba(34,197,94,0.9) !important;
            color: var(--text) !important;
            box-shadow: 0 0 0 1px rgba(34,197,94,0.22) inset;
        }
        .personal-bg-glass-controls{
            display:none;
            margin-top:0.6rem;
            border:1px solid var(--border-soft);
            border-radius:0.55rem;
            padding:0.6rem;
            background: var(--bg-soft);
        }
        .personal-bg-glass-controls.is-open{ display:block; }
        .personal-bg-panel{
            border: 1px solid var(--border-soft);
            border-radius: 0.65rem;
            margin-top: 0.8rem;
            padding: 0.65rem;
            background: color-mix(in srgb, var(--card) 96%, transparent);
        }
        .personal-bg-controls{
            margin-top: 0.6rem;
            border-top: 1px solid var(--border-soft);
            padding-top: 0.6rem;
            display: none;
        }
        .personal-bg-controls.is-open{ display:block; }
        .personal-bg-top-buttons{
            display:flex;
            flex-wrap:wrap;
            gap:0.5rem;
            align-items:center;
        }
        .personal-bg-top-buttons > button{
            flex: 0 1 auto;
        }
        .personal-rename-controls{
            display:none;
            margin-top:0.6rem;
            border:1px solid var(--border-soft);
            border-radius:0.55rem;
            padding:0.55rem;
            background: var(--bg-soft);
        }
        .personal-rename-controls.is-open{ display:block; }
        .personal-bg-action-buttons{
            display:flex;
            flex-wrap:wrap;
            gap:0.5rem;
            align-items:flex-start;
            margin-bottom:0.65rem;
        }

        .personal-bg-action-stack{
            display:flex;
            flex-direction:column;
            gap:0.5rem;
        }
        .personal-bg-action-stack > button{
            width:100%;
        }
        .ctrl-hint-orange{
            color: var(--dot-orange) !important;
        }

        /* Profil-knapp: alltid lesbar i lysmodus (og ved tekst-overstyring) */
        body:not(.theme-dark):not(.theme-black) #profileButton{
            color: #000000 !important;
        }
        body:not(.theme-dark):not(.theme-black) #profileButton.active,
        body:not(.theme-dark):not(.theme-black) #profileButton.btn-profile-active{
            color: #ffffff !important;
        }
        .personal-bg-color-controls{
            display:none;
            border:1px solid var(--border-soft);
            border-radius:0.55rem;
            padding:0.6rem;
            background: var(--bg-soft);
        }
        .personal-bg-color-controls.is-open{ display:block; }
        .personal-bg-slider-row{
            display:grid;
            grid-template-columns: 82px 1fr 56px;
            gap:0.55rem;
            align-items:center;
            margin-bottom:0.45rem;
        }
        .personal-bg-slider-row:last-child{ margin-bottom:0; }
        .personal-bg-slider-row input[type="range"]{ width:100%; }
        .personal-bg-glass-controls .personal-bg-slider-row{
            grid-template-columns: 1fr auto;
            grid-template-areas:
                'label value'
                'slider slider';
            align-items: start;
            row-gap: 0.35rem;
        }
        .personal-bg-glass-controls .personal-bg-slider-row label{
            grid-area: label;
        }
        .personal-bg-glass-controls .personal-bg-slider-row input[type="range"]{
            grid-area: slider;
            margin-top: 0.1rem;
        }
        .personal-bg-glass-controls .personal-bg-slider-row span{
            grid-area: value;
            white-space: nowrap;
            align-self: center;
        }
        #personalBgColorButton.active{
            background: rgba(59,130,246,0.12);
            border-color: rgba(59,130,246,0.35);
        }
        #personalBgTextColorButton.active{
            background: rgba(168,85,247,0.14);
            border-color: rgba(168,85,247,0.42);
            box-shadow: 0 0 0 1px rgba(168,85,247,0.12) inset;
        }
        #personalFruitigerArchiveButton.active{
            background: rgba(34,197,94,0.14);
            border-color: rgba(34,197,94,0.42);
            box-shadow: 0 0 0 1px rgba(34,197,94,0.12) inset;
        }
        .personal-bg-blur-presets{
            display:flex;
            gap:0.4rem;
            flex-wrap:wrap;
            margin-top:0.5rem;
        }
        .personal-bg-blur-presets .btn-secondary{
            min-width: 84px;
        }
        #personalBgCustomizeButton.active,
        #personalBgCustomizeButton[aria-pressed="true"],
        #personalRenameControlsToggleButton.active,
        #personalRenameControlsToggleButton[aria-pressed="true"],
        #personalBgColorButton.active,
        #personalBgTextColorButton.active,
        #personalBgGlassButton.active,
        #personalBgBlurFastButton.active,
        #personalBgBlurPrettyButton.active,
        #personalBgBlurHeavyButton.active{
            background: rgba(34,197,94,0.14) !important;
            border-color: rgba(34,197,94,0.42) !important;
            box-shadow: 0 0 0 1px rgba(34,197,94,0.12) inset !important;
            color: var(--text) !important;
        }

        .personal-bg-archive-panel{
            display:none;
            margin-top:0.55rem;
            border:1px solid var(--border-soft);
            border-radius:0.55rem;
            background: var(--bg-soft);
            padding:0.5rem;
        }
        .personal-bg-archive-panel.is-open{ display:block; }
        .personal-bg-archive-status{
            font-size:0.72rem;
            color: var(--muted);
            margin:0 0 0.4rem 0;
        }

        .personal-bg-archive-status.is-loading{
            color: var(--dot-orange);
            font-weight: 700;
        }
        .personal-bg-archive-status .status-category{
            color: var(--dot-green);
            font-weight: 800;
        }

        .personal-bg-archive-toolbar{
            border:1px solid var(--border-soft);
            border-radius:0.45rem;
            padding:0.45rem;
            margin:0 0 0.45rem 0;
            background: color-mix(in srgb, var(--card) 92%, transparent);
        }
        .personal-bg-archive-toolbar .personal-bg-slider-row{
            grid-template-columns: 58px 1fr 64px;
            margin-bottom:0.35rem;
        }
        .personal-bg-archive-toolbar .personal-bg-slider-row label{
            font-size:0.78rem;
        }
        .personal-bg-archive-toolbar-buttons{
            display:flex;
            gap:0.35rem;
            flex-wrap:wrap;
        }
        .personal-bg-archive-toolbar-buttons button{
            flex:1 1 170px;
        }
        .personal-bg-archive-list{
            display:grid;
            grid-template-columns:1fr;
            gap:0.35rem;
            max-height:220px;
            overflow:auto;
        }
        .personal-bg-archive-item{
            width:100%;
            text-align:left;
            padding:0.45rem 0.55rem;
            border-radius:0.45rem;
            border:1px solid var(--border);
            background: var(--card);
            color: var(--text);
            cursor:pointer;
            font-size:0.82rem;
            line-height:1.25;
        }
        .personal-bg-archive-item:hover{ background: var(--hover); }
        .personal-bg-archive-item[disabled]{ opacity:0.65; cursor:wait; }
        @keyframes personalResetDangerBlink {
            0%, 100% { background: var(--btn-bg); border-color: var(--border); color: var(--text); }
            50% { background: rgba(220,38,38,0.16); border-color: rgba(220,38,38,0.75); color: var(--danger); }
        }
        #personalCustomizeResetButton.danger-hold-pending{
            animation: personalResetDangerBlink 0.7s linear infinite;
        }
        
        @keyframes newProfileGreenBlink {
            0%, 49% { background: var(--input-bg, var(--bg-soft)); border-color: var(--border); }
            50%, 100% { background: rgba(16,185,129,0.22); border-color: rgba(16,185,129,0.75); }
        }
        #newProfileName.new-profile-attention{
            animation: newProfileGreenBlink 2s linear infinite;
        }
.personal-bg-media-history{
            display:none;
            margin-top:0.55rem;
            border:1px solid var(--border-soft);
            border-radius:0.55rem;
            background: var(--bg-soft);
            padding:0.45rem;
            max-height: 210px;
            overflow:auto;
        }

        .personal-bg-media-history-grid{
            display:grid;
            grid-template-columns: 1fr 1px 1fr;
            gap:0.6rem;
            align-items:start;
        }
        .personal-bg-media-history-divider{
            width:1px;
            background: var(--border-soft);
            align-self: stretch;
        }
        .personal-bg-media-history-col-title{
            font-size:0.72rem;
            font-weight: 800;
            margin:0 0 0.35rem 0.1rem;
            opacity: 0.9;
        }

        .personal-bg-media-history.is-open{ display:block; }
        .personal-bg-media-history-item{
            display:flex;
            align-items:center;
            gap:0.55rem;
            width:100%;
            padding:0.45rem 0.5rem;
            border-radius:0.45rem;
            border:1px solid transparent;
            background: transparent;
            color: var(--text);
            cursor:pointer;
            text-align:left;
        }
        .personal-bg-media-history-item:hover{
            background: var(--hover);
            border-color: var(--border);
        }
        .personal-bg-media-history-thumb{
            width:46px;
            height:32px;
            border-radius:0.35rem;
            border:1px solid var(--border);
            overflow:hidden;
            background: rgba(148,163,184,0.16);
            display:flex;
            align-items:center;
            justify-content:center;
            flex:0 0 auto;
            font-size:0.7rem;
            color: var(--muted);
        }
        .personal-bg-media-history-thumb img,
        .personal-bg-media-history-thumb video{
            width:100%;
            height:100%;
            object-fit:cover;
            display:block;
        }
        .personal-bg-media-history-meta{
            min-width:0;
            display:flex;
            flex-direction:column;
            gap:0.15rem;
        }
        .personal-bg-media-history-title{
            font-size:0.85rem;
            font-weight:600;
            color: var(--text);
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
            max-width: 100%;
        }
        .personal-bg-media-history-sub{
            font-size:0.76rem;
            color: var(--muted);
        }
        .personal-bg-media-history-empty{
            font-size:0.82rem;
            color: var(--muted);
            padding:0.35rem 0.2rem;
        }
        
        /* Historikk-visning: skjul øvrige verktøy/hjelpetekster når historikk er åpen */
        #personalCustomizeOverlay.history-only .personal-bg-top-buttons,
        #personalCustomizeOverlay.history-only #personalRenameControlsWrap,
        #personalCustomizeOverlay.history-only #personalBgColorControls,
        #personalCustomizeOverlay.history-only #personalBgTextColorControls,
        #personalCustomizeOverlay.history-only #personalBgGlassControls,
        #personalCustomizeOverlay.history-only #personalFruitigerArchivePanel,
        #personalCustomizeOverlay.history-only #personalBgMediaStatus{
            display:none !important;
        }
        #personalCustomizeOverlay.history-only #personalBgControlsWrap .personal-bg-action-buttons > :not(#personalBgMediaHistoryButton){
            display:none !important;
        }
        #personalCustomizeOverlay.history-only #personalBgControlsWrap .helptext-container,
        #personalCustomizeOverlay.history-only #personalBgControlsWrap .helper-text{
            display:none !important;
        }
        .personal-bg-media-history-item.thumb-only{
            justify-content:flex-start;
            gap:0;
            padding:0.35rem;
        }
        .personal-bg-media-history-item.thumb-only .personal-bg-media-history-thumb{
            width:64px;
            height:44px;
        }
.personal-bg-preview-chip{
            width:100%;
            min-height:42px;
            border-radius:0.5rem;
            border:1px solid var(--border);
            margin-top:0.55rem;
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:0.75rem;
            color: var(--text);
            text-shadow: 0 1px 2px rgba(0,0,0,0.25);
            background:#888;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        /* App-notat indikator (rosa prikk ved tittel) */
        #appNotesButton{
            position: relative;
            display: inline-block;
        }
        #appNotesIndicator{
            position: absolute;
            left: -14px;          /* venstre for teksten uten å flytte den */
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--comment-pink);
            display: none;        /* vises kun når notater finnes */
            pointer-events: none;
            animation: appNotesPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 0 0 rgba(236,72,153,0.45);
        }
        @keyframes appNotesPulse {
            0% { transform: translateY(-50%) scale(1); box-shadow: 0 0 0 0 rgba(236,72,153,0.45); }
            50% { transform: translateY(-50%) scale(1.28); box-shadow: 0 0 0 6px rgba(236,72,153,0); }
            100% { transform: translateY(-50%) scale(1); box-shadow: 0 0 0 0 rgba(236,72,153,0); }
        }

        #appNotesButton:hover #appTitleText,
        #appNotesButton:focus-visible #appTitleText{
            color: var(--dot-green);
        }
        body.theme-dark #appNotesButton #appTitleText{
            color: var(--dot-green);
        }
        body.theme-dark #appNotesButton:hover #appTitleText,
        body.theme-dark #appNotesButton:focus-visible #appTitleText{
            color: var(--dot-orange);
        }

        /* Tittelfarge: grønn i alle moduser, orange ved hover */
        #appNotesButton #appTitleText{
            color: var(--dot-green);
        }
        #appNotesButton:hover #appTitleText,
        #appNotesButton:focus-visible #appTitleText{
            color: var(--dot-orange);
        }

        /* Prosjektforslag: kun selve forslaglisten skal ligge foran andre kort */
        #projectInputCard{
            position: relative;
            overflow: visible;
        }
        #projectInputCard .task-input-row,
        #projectInputCard .task-input-wrapper{
            overflow: visible;
        }
        #projectInputCard .task-input-wrapper{
            z-index: auto; /* unngå at hele prosjektkortet havner over modaler/andre kort */
        }
        #projectInputCard #taskSuggestions{
            z-index: 2800; /* kun dropdown-listen løftes */
        }
        #projectInputCard.suggestions-open{
            z-index: 2799; /* løft kun mens dropdown er åpen (trengs pga stacking context i glass/personlig modus) */
        }

.header-left h1 {
            margin: 0 0 0.25rem;
            font-size: 1.5rem;
        }
        .time-now {
            font-size: 1.02rem;
            font-weight: 700;
            color: var(--text);
            letter-spacing: 0.01em;
        }
        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--muted);
            text-align: right;
            white-space: nowrap;
        }

        .frutiger-music-player-wrap{
            display:none;
            position: fixed;
            top: 0.18rem;
            left: 0;
            right: 0;
            z-index: 2100;
            margin: 0;
            pointer-events: none;
        }
        .frutiger-music-player-wrap.is-visible{
            display:flex;
            justify-content:center;
        }
        .frutiger-music-player{
            pointer-events: auto;
            width: min(300px, calc(100vw - 0.75rem));
            border:1px solid var(--border);
            border-radius: 0.7rem;
            background: color-mix(in srgb, var(--card) 94%, transparent);
            box-shadow: var(--shadow);
            padding: 0.30rem 0.38rem;
            display:flex;
            flex-direction:column;
            gap:0.16rem;
            backdrop-filter: blur(10px) saturate(120%);
            -webkit-backdrop-filter: blur(10px) saturate(120%);
        }
        .frutiger-music-row{
            display:flex;
            align-items:center;
            gap:0.22rem;
            min-width:0;
        }
        .frutiger-music-row-top{
            justify-content:space-between;
        }
        #frutigerMusicPlayerTitle{
            font-size:0.74rem;
            line-height:1.15;
            min-width:0;
            overflow:hidden;
            text-overflow:ellipsis;
            white-space:nowrap;
        }
        .frutiger-music-status{
            font-size:0.66rem;
            color:var(--muted);
            white-space:nowrap;
        }
        .frutiger-music-row-controls{
            flex-wrap:wrap;
        }
        .frutiger-music-row-controls .btn-secondary{
            padding: 0.12rem 0.28rem;
            font-size:0.68rem;
            line-height:1.15;
        }
        #toggleFrutigerMusicPlayerButton.active{
            background: rgba(59,130,246,0.14);
            border-color: rgba(59,130,246,0.42);
            box-shadow: 0 0 0 1px rgba(59,130,246,0.12) inset;
        }
        .frutiger-music-track{
            font-size:0.72rem;
            color: var(--text);
            border-top:1px solid var(--border-soft);
            padding-top:0.22rem;
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
        }
        body.glass-mode-active .frutiger-music-player{
            background: rgba(var(--glass-surface-rgb), calc(var(--glass-ui-alpha) + 0.08));
            border-color: rgba(var(--glass-border-rgb), calc(var(--glass-border-alpha) + 0.10));
        }
        @media (max-width: 700px){
            .frutiger-music-player-wrap{ top:0.1rem; }
            .frutiger-music-player{ width: calc(100vw - 0.35rem); padding: 0.30rem 0.34rem; }
            #frutigerMusicPlayerTitle{ font-size:0.71rem; }
            .frutiger-music-track{ font-size:0.68rem; }
        }

        .card {
            background: var(--card);
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
            transition: border-color 0.3s, background-color 0.3s, box-shadow 0.3s;
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            gap: 0.5rem;
        }
        .card-header-left{
            display: flex;
            align-items: center;
            gap: 0.6rem;
            min-width: 0;
            flex-wrap: wrap;
        }
        .card-header-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Historikk: klikkbar overskrift med pil (som år/mnd) */
        .archive-header-toggle{
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        .archive-header-toggle:focus{ outline: none; }
        .archive-toggle-arrow{
            width: 0.8em;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            opacity: 0.85;
            flex: none;
            font-size: 1em;
            line-height: 1;
        }

@keyframes pulse-blue-card {
            0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
            70% { box-shadow: 0 0 0 8px rgba(37, 99, 235, 0); }
            100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
        }

        @keyframes pulse-orange-card {
            0% { box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.4); }
            70% { box-shadow: 0 0 0 8px rgba(249, 115, 22, 0); }
            100% { box-shadow: 0 0 0 0 rgba(249, 115, 22, 0); }
        }

        .card-active-mode {
            position: relative;
            border: 2px solid var(--dot-blue) !important;
            border-radius: 0.75rem;
            background: var(--card);
            animation: pulse-blue-card 2s infinite;
        }

        .card-active-mode-resumed {
            position: relative;
            border: 2px solid var(--dot-orange) !important;
            border-radius: 0.75rem;
            background: var(--card);
            animation: pulse-orange-card 2s infinite;
        }

        .task-input-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .task-input-wrapper {
            position: relative;
            flex: 1;
            z-index: 600;
        }

        .task-input-row input {
            flex: 1;
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            font-size: 0.95rem;
            background: transparent;
            color: var(--text);
        }

        .task-input-row button {
            padding: 0.5rem 0.9rem;
            border-radius: 0.5rem;
            border: none;
            font-size: 0.95rem;
            cursor: pointer;
            background: var(--dot-green);
            color: #ffffff;
            font-weight: 500;
        }
        .task-input-row button:disabled {
            background: #9ca3af;
            cursor: default;
        }

        #taskSuggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 0.25rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            box-shadow: 0 4px 8px rgba(15,23,42,0.15);
            height: var(--suggestions-height, 240px);
            max-height: 60vh;
            overflow: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
            resize: vertical;
            z-index: 1850;
            font-size: 0.9rem;
            display: none;
        }
        #taskSuggestions::-webkit-scrollbar { width: 0; height: 0; }

        .suggestion-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.35rem 0.6rem;
            cursor: pointer;
        }
        .suggestion-item:hover { background: var(--hover); }
        .suggestion-item.selected { background: rgba(37,99,235,0.12); }
        .suggestion-divider{
            height: 1px;
            width: 100%;
            background: var(--fav-divider);
            margin: 2px 0;
            opacity: 0.9;
            flex-shrink: 0;
        }


        .project-outdated-wrap{
            /* In-flow placement under project number field (same vertical rhythm as other rows) */
            position: relative;
            left: auto;
            bottom: auto;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0;
            margin-bottom: 1rem;
            z-index: 2;
        }
        .outdated-label{
            display:flex;
            align-items:center;
            gap:0.45rem;
            font-size: 0.85rem;
            color: var(--muted);
            user-select:none;
        }
        .outdated-checkbox{
            width: 14px;
            height: 14px;
            border: 1px solid var(--border);
            border-radius: 3px;
            background: transparent;
            appearance: none;
            -webkit-appearance: none;
            outline: none;
            cursor: pointer;
            display: inline-block;
        }
        .outdated-checkbox:checked{
            background: #9ca3af;
        }
        .suggestion-item.task-outdated{
            background: var(--outdated-bg);
        }
        /* Favorite projects: highlight in the top project suggestion list */
        .suggestion-item.is-fav-row {
            cursor: grab;
            background: rgba(250, 204, 21, 0.22);
        }
        .suggestion-item.is-fav-row:hover { background: rgba(250, 204, 21, 0.32); }
        .suggestion-item.is-fav-row.selected { background: rgba(250, 204, 21, 0.42); }
        .suggestion-item.is-fav-row.dragging { opacity: 0.6; cursor: grabbing; }
        .suggestion-item.drop-above { border-top: 2px solid rgba(37,99,235,0.8); }
        .suggestion-item.drop-below { border-bottom: 2px solid rgba(37,99,235,0.8); }

        .suggestion-item.drop-into { outline: none !important; }
        .suggestion-item.group-item { font-weight: 600; }
        .suggestion-item.group-header { font-weight: 600; opacity: 0.9; }
        .suggestion-item.group-header .suggestion-label { font-style: italic; }
        .suggestion-label {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .suggestion-delete{
    margin-left: 0.5rem;
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    border-radius: 0.5rem;
    line-height: 1;
    font-size: 0.8rem;
    color: #9ca3af;
}
        .suggestion-delete:hover { color: #ef4444; }

        

        .suggestion-actions{
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            flex-shrink: 0;
        }
        .suggestion-edit{
    margin-left: 0.5rem;
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    border-radius: 0.5rem;
    line-height: 1;
    font-size: 0.85rem;
    color: #9ca3af;
    position: relative;
    overflow: hidden;
}
.suggestion-edit::before{
    content: '';
    position: absolute;
    inset: 0;
    background: var(--dot-green);
    opacity: 0;
    transition: opacity 0.15s ease-in-out;
    z-index: 0;
}
.suggestion-edit:hover::before{
    opacity: 1;
}
.suggestion-edit:hover{
    color: #ffffff;
}
.suggestion-edit .pencil-icon{
    position: relative;
    z-index: 2;
    display: inline-block;
    line-height: 1;
}
.suggestion-fav{
    width: 28px;
    height: 28px;
    border: none;
    background: transparent;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    border-radius: 0.5rem;
    line-height: 1;
    font-size: 0.9rem;
    color: #9ca3af;
}
        .suggestion-fav.is-fav{ color: #fbbf24; }
        .suggestion-fav:hover{ color: #f59e0b; }
.helper-text {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        /* HJELPETEKST-KONTRAKT:
           - All ny hjelpetekst skal enten ha class="helper-text" / "inline-note" / "empty-text"
             eller ligge inni en container med data-helptext-container="true".
           - Bruk helst wrapper: <div class="helptext-container" data-helptext-container="true">...</div>
           - Dette gjør at knappen "Ingen hjelpetekst" fortsetter å virke også for nye elementer.
        */
        .helptext-container[data-helptext-container="true"]{
            display: contents;
        }

        
        /* Skjul all hjelpetekst når "Ingen hjelpetekst" er aktiv */
        body.no-helpertext .helper-text,
        body.no-helpertext .inline-note,
        body.no-helpertext .empty-text,
        body.no-helpertext .helptext-container[data-helptext-container="true"]{
            display: none !important;
        }

        /* Behold hjelpetekst i popup-vinduet Profil og Innstillinger */
        body.no-helpertext #settingsOverlay .helper-text{
            display: revert !important;
        }
        body.no-helpertext #settingsOverlay .helptext-container[data-helptext-container="true"]{
            display: contents !important;
        }
.helper-text.hidden {
            display: none;
        }

        body.theme-dark .helper-text,
        body.theme-dark .empty-text,
        body.theme-dark .task-time,
        body.theme-dark .modal p,
        body.theme-dark .chart-legend,
        body.theme-dark input,
        body.theme-dark textarea,
        body.theme-dark select,
        body.theme-dark option,
        body.theme-dark ::placeholder{
            color: #ffffff !important;
        }
        body.theme-dark .helper-text { color: var(--muted); }

        .current-task {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
        }
        .current-task-label {
            font-weight: 600;
            color: var(--text);
        }
        .current-task-title { font-weight: 600; }
        
        .current-task-time { 
            font-family: monospace; 
            color: var(--text); 
            font-size: 1.1rem;
        }

        .time-digit-neutral { color: var(--text); font-weight: normal; }
        .time-digit-h-active { color: #ff6b6b; font-weight: 600; }
        .time-digit-m-active { color: #feca57; font-weight: 600; }
        .time-digit-s-active { color: #54a0ff; font-weight: 600; }

        .text-rounded-green, .text-rounded-green span {
            color: var(--dot-green) !important;
            font-weight: 600;
        }

        .current-task-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: flex-end;
            flex-wrap: wrap;
            margin-top: 0.35rem;
        }

        .rainbow-text {
            background: linear-gradient(
                90deg,
                #ef4444, #f97316, #facc15, #22c55e,
                #14b8a6, #3b82f6, #a855f7, #ef4444
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: rainbow 8s linear infinite;
        }

        @keyframes rainbow {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        @keyframes flash-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }
        
        .text-flash-anim {
            animation: flash-text 0.3s ease-in-out 2;
        }

        .btn-secondary {
            padding: 0.35rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: var(--btn-bg);
            font-size: 0.85rem;
            cursor: pointer;
            color: var(--text);
            transition: background-color 0.2s, color 0.2s, box-shadow 0.2s, border-color 0.2s;
        }
        .btn-secondary:disabled {
            cursor: default;
            opacity: 0.5;
        }
        .btn-secondary.active {
            background-color: var(--dot-blue);
            color: #ffffff;
            border-color: var(--dot-blue);
        }

        .btn-hover-blue:not(:disabled):hover {
            background-color: var(--dot-blue) !important;
            color: #ffffff !important;
            border-color: var(--dot-blue) !important;
        }

        .btn-hover-green:not(:disabled):hover {
            background-color: var(--dot-green) !important;
            color: #ffffff !important;
            border-color: var(--dot-green) !important;
        }

        #copyOneNoteButton:not(:disabled):hover {
            background-color: var(--comment-pink) !important;
            color: #ffffff !important;
            border-color: var(--comment-pink) !important;
        }

        #endButton:not(:disabled):hover {
            background-color: var(--danger) !important;
            color: #ffffff !important;
            border-color: var(--danger-border) !important;
        }

        @keyframes pulse-green-wave {
            0% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(22, 163, 74, 0); }
            100% { box-shadow: 0 0 0 0 rgba(22, 163, 74, 0); }
        }

        .btn-rounding-active {
            background-color: var(--dot-green) !important;
            color: #ffffff !important;
            border-color: var(--dot-green) !important;
            animation: pulse-green-wave 2s infinite;
        }

        @keyframes pulse-blue-wave {
            0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(37, 99, 235, 0); }
            100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
        }

        .btn-profile-active {
            background-color: var(--dot-blue) !important;
            color: #ffffff !important;
            border-color: var(--dot-blue) !important;
            animation: pulse-blue-wave 2s infinite;
        }

        .text-rounded {
            color: var(--dot-green) !important;
            font-weight: 600;
        }

        .time-add-display {
            font-size: 1.5rem;
            font-family: monospace;
            font-weight: 600;
            color: var(--text);
            text-align: center;
            padding: 0.5rem;
            flex: 1;
        }

        .btn-stepper {
            background-color: var(--dot-green);
            color: #ffffff;
            border: none;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            user-select: none;
            min-width: 100px;
        }
        .btn-stepper:active {
            transform: scale(0.96);
        }
        .btn-stepper.btn-orange-flash {
            background-color: var(--dot-orange) !important;
        }

        #clearButton:not(:disabled):hover {
            background: var(--danger);
            color: #ffffff;
            border-color: var(--danger-border);
        }
        #exportButton:not(:disabled):hover {
            background: var(--excel);
            color: #ffffff;
            border-color: var(--excel-border);
        }
        #clearArchivesButton:not(:disabled):hover {
            background: var(--danger);
            color: #ffffff;
            border-color: var(--danger-border);
        }

        #themeToggleButton:hover{
            background: rgba(37,99,235,0.12);
            border-color: rgba(37,99,235,0.35);
        }
        @keyframes themeButtonPinkPulse5s{
            0%, 86%, 100%{
                box-shadow: none;
            }
            2%{
                box-shadow: 0 0 0 0 rgba(236,72,153,0.42);
            }
            5%{
                box-shadow:
                    0 0 0 4px rgba(236,72,153,0.16),
                    0 0 16px rgba(236,72,153,0.20);
            }
            9%{
                box-shadow:
                    0 0 0 8px rgba(236,72,153,0.00),
                    0 0 0 rgba(236,72,153,0.00);
            }
        }
        #themeToggleButton.media-amoled-pulse{
            border-color: rgba(236,72,153,0.45);
            animation: themeButtonPinkPulse5s 5s ease-in-out infinite;
        }
        
        #profileButton {
            margin-top: 0.25rem;
        }
        #profileButton:hover {
            opacity: 0.9;
        }

        .task-list-wrapper {
            position: relative;
            --dynamic-gap: 60%; 
        }

        .task-list {
            list-style: none;
            margin: 0;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
        }
        .task-list.expanded {
            max-height: none;
        }

        /* SCROLLBAR STYLING */
        .task-list::-webkit-scrollbar {
            width: 12px;
        }
        .task-list::-webkit-scrollbar-track {
            background: var(--card);
        }
        .task-list::-webkit-scrollbar-thumb {
            background-color: #000000;
            border-radius: 6px;
            border: 3px solid var(--card);
        }
        body.theme-dark .task-list::-webkit-scrollbar-thumb,
        body.theme-black .task-list::-webkit-scrollbar-thumb {
            background-color: #ffffff;
        }

        .task-list.compact-mode .task-list-item {
            display: flex;
            align-items: center;
            position: relative; 
        }
        
        .task-list.compact-mode .task-left {
            width: calc(var(--dynamic-gap) - 10px);
            min-width: 0;
            flex: none;
            padding-right: 10px;
        }

        /* Logic to hide comment field when divider is dragged over */
        .task-list.compact-mode .task-comment-row {
            width: calc(var(--dynamic-gap) - 10px);
            max-width: calc(var(--dynamic-gap) - 10px);
            overflow: hidden;
        }

        .task-list.compact-mode .project-division-comment-row {
            width: calc(var(--dynamic-gap) - 10px - 2.15rem);
            max-width: calc(var(--dynamic-gap) - 10px - 2.15rem);
            overflow: hidden;
        }

        .task-list.compact-mode .project-division-row {
            position: relative;
            padding-right: 0;
        }

        .task-list.compact-mode .project-division-item {
            position: relative;
            padding-right: 0;
            min-height: 1.55rem;
        }

        .task-list.compact-mode .project-division-index,
        .task-list.compact-mode .project-division-text,
        .task-list.compact-mode .btn-comment-copy {
            position: relative;
            z-index: 1;
        }

        .task-list.compact-mode .project-division-time {
            position: absolute;
            left: calc(var(--dynamic-gap) - 1.35rem);
            top: 0;
            bottom: 0;
            right: 0;
            margin: 0;
            z-index: 10;
            background: var(--card);
            padding-left: 10px;
            display: flex;
            align-items: center;
            white-space: nowrap;
            justify-content: flex-start;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .task-list.compact-mode .task-comment-box {
            white-space: nowrap; 
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .task-list.compact-mode .task-time {
            position: absolute;
            left: var(--dynamic-gap);
            top: 0;
            bottom: 0;
            right: 0;
            margin: 0;
            z-index: 10;
            background: var(--card);
            padding-left: 10px;
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        #resizeHandle {
            position: absolute;
            top: 0;
            bottom: 0;
            left: var(--dynamic-gap); 
            width: 24px;
            transform: translateX(-50%);
            cursor: col-resize;
            z-index: 100;
            display: none;
            align-items: stretch;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        
        .task-list-wrapper.compact-active #resizeHandle {
            display: flex;
        }

        #resizeHandle::after {
            content: '';
            width: 2px;
            background-color: var(--dot-green);
            transition: none; 
        }
        
        body.theme-dark #resizeHandle::after {
            background-color: var(--dot-green);
        }

        #resizeHandle:hover::after, 
        #resizeHandle.resizing::after {
            background-color: var(--dot-blue) !important;
            width: 3px;
        }

        .handle-release-anim::after {
            animation: blinkGreenBlue 0.6s ease-in-out;
        }

        @keyframes blinkGreenBlue {
            0% { background-color: var(--dot-blue); width: 3px; }
            20% { background-color: var(--dot-green); width: 2px; }
            40% { background-color: var(--dot-blue); width: 3px; }
            60% { background-color: var(--dot-green); width: 2px; }
            80% { background-color: var(--dot-blue); width: 3px; }
            100% { background-color: var(--dot-green); width: 2px; }
        }
        
        body.theme-dark .task-list.compact-mode .task-time {
            background: var(--card);
        }

        .task-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.25rem;
            border-bottom: 1px solid var(--border-soft);
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        .task-list-item:last-child { border-bottom: none; }
        .task-list-item:hover { background: var(--hover); }

        .task-left {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            min-width: 0;
        }
        
        .task-info-col {
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0;
        }

        .task-name-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-name {
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 520px;
        }
        
        .task-project-number {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0px;
            line-height: 1.1;
        }
        
        body.theme-dark .task-project-number {
            color: #64748b;
        }

        .project-division-row {
            padding: 0.25rem 0 0.55rem 1.35rem;
            border-bottom: 1px solid var(--border-soft);
        }

        .project-division-list {
            list-style: none;
            margin: 0;
            padding: 0.15rem 0 0 0;
            display: flex;
            flex-direction: column;
            gap: 0.22rem;
        }


        .project-division-comment-row {
            margin: -0.05rem 0 0.15rem 2.15rem;
            width: calc(100% - 2.15rem);
            max-width: calc(100% - 2.15rem);
            box-sizing: border-box;
        }

        .project-division-comment-row .task-comment-box {
            font-size: 0.82rem;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
        }

        .project-division-item {
            display: flex;
            gap: 0.55rem;
            align-items: flex-start;
            justify-content: space-between;
            font-size: 0.88rem;
            line-height: 1.3;
            color: var(--text);
            cursor: pointer;
            padding: 0.16rem 0.3rem 0.16rem 0.1rem;
            border-radius: 10px;
        }

        .project-division-item:hover {
            background: rgba(244, 114, 182, 0.10);
        }

        .project-division-item.is-active .project-division-text,
        .project-division-item.is-active .project-division-time {
            color: var(--dot-green);
            font-weight: 700;
        }

        .project-division-item.is-selected {
            background: rgba(244, 114, 182, 0.18);
        }

        .project-division-item.is-selected .project-division-text,
        .project-division-item.is-selected .project-division-time {
            color: #db2777;
            font-weight: 700;
        }

        .project-division-arrow {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 0.95rem;
            min-width: 0.95rem;
            font-size: 0.9rem;
            line-height: 1;
            color: #f472b6;
            transform: translateY(1px);
            user-select: none;
            cursor: pointer;
        }

        .project-division-arrow.is-collapsed {
            opacity: 1;
            transition: opacity 0.16s linear;
            animation: projectDivisionArrowBlinkEven 2s steps(1, end) infinite;
        }

        .project-division-arrow.is-collapsed.is-blink-off {
            opacity: 0.2;
        }

        .project-division-arrow.is-expanded {
            opacity: 1;
            animation: none;
        }

        @keyframes projectDivisionArrowBlinkEven {
            0%, 49.999% { opacity: 1; }
            50%, 100% { opacity: 0.2; }
        }

        .task-name.is-project-division-parent {
            color: #f472b6;
            font-weight: 700;
            cursor: pointer;
        }

        .project-division-index {
            min-width: 1.25rem;
            color: #f472b6;
            font-weight: 700;
            text-align: right;
            flex: 0 0 auto;
        }

        .project-division-text {
            min-width: 0;
            word-break: break-word;
            opacity: 0.95;
            flex: 1 1 auto;
        }

        .project-division-time {
            flex: 0 0 auto;
            margin-left: 0.65rem;
            font-size: 0.8rem;
            opacity: 0.82;
            white-space: nowrap;
        }

        .task-list-item.project-division-open .task-name {
            color: #f472b6;
        }

        .task-list-item.task-selected .task-name.is-project-division-parent,
        body.temp-task-selection .task-list-item.task-selected .task-name.is-project-division-parent {
            color: var(--dot-green) !important;
        }

        .btn-comment-copy {
            background: transparent;
            border: none;
            cursor: pointer;
            height: 18px; 
            width: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.25rem;
            padding: 0;
            vertical-align: middle;
        }
        
        .btn-comment-copy::after {
            content: '';
            width: 8px; 
            height: 8px;
            border-radius: 50%;
            background-color: var(--comment-pink);
            display: block;
            transition: transform 0.2s;
        }
        
        .btn-comment-copy:hover::after {
            transform: scale(1.3);
        }

        .project-division-item .btn-comment-copy {
            margin-right: 0.15rem;
            margin-left: 0.05rem;
            flex: 0 0 auto;
        }
        
        .task-time {
            font-family: monospace;
            font-size: 0.9rem;
            color: #374151;
            white-space: nowrap;
            margin-left: 0.75rem;
        }
        body.theme-dark .task-time { color: #ffffff; }

        /* FAVORITT (gul markering) */
        .task-list-item.task-favorite{
            background: rgba(251,191,36,0.22);
        }
        .task-list-item.task-favorite:hover{
            background: rgba(251,191,36,0.28);
        }
        body.theme-dark .task-list-item.task-favorite{
            background: rgba(251,191,36,0.16);
        }
        body.theme-dark .task-list-item.task-favorite:hover{
            background: rgba(251,191,36,0.22);
        }

        /* I kompakt modus har .task-time egen bakgrunn – slå den av for favoritter,
           ellers blir høyre del "maskert". */
        .task-list.compact-mode .task-list-item.task-favorite .task-time{
            background: transparent;
        }

        /* Kommentar-boksen under raden */
        .task-comment-row.task-favorite .task-comment-box{
            background: rgba(251,191,36,0.14);
            border-color: rgba(251,191,36,0.55);
        }
        body.theme-dark .task-comment-row.task-favorite .task-comment-box{
            background: rgba(251,191,36,0.10);
            border-color: rgba(251,191,36,0.45);
        }

        /* ====== FAVORITT: kun i øverste forslagliste (taskSuggestions) ======
           Arbeidsliste (dagens) skal IKKE ha gul fyllfarge, selv om task-favorite class finnes.
        */
        #taskList .task-list-item.task-favorite,
        #taskList .task-list-item.task-favorite:hover{
            background: transparent !important;
        }

        /* Kommentar-boksen under raden (dagens) skal heller ikke bli gul */
        #taskList .task-comment-row.task-favorite .task-comment-box{
            background: rgba(148,163,184,0.08) !important;
            border-color: var(--border) !important;
        }

        body.theme-dark #taskList .task-list-item.task-favorite,
        body.theme-dark #taskList .task-list-item.task-favorite:hover{
            background: transparent !important;
        }
        body.theme-dark #taskList .task-comment-row.task-favorite .task-comment-box{
            background: rgba(148,163,184,0.10) !important;
            border-color: var(--border) !important;
        }

        .task-selected { background: rgba(37,99,235,0.12); }
        .task-active { font-weight: 600; }

        /* Green text logic for Arbeidsliste (dagens)
           - Default: active task is green
           - Temporary (when a different task is clicked): active becomes normal, selected becomes green for 10s
        */
        .task-list-item.task-active{
            color: var(--dot-green);
        }
        .task-list-item.task-active .task-time{
            color: var(--dot-green);
        }

        body.temp-task-selection .task-list-item.task-active{
            color: inherit;
        }
        body.temp-task-selection .task-list-item.task-active .task-time{
            color: inherit;
        }
        body.temp-task-selection .task-list-item.task-selected{
            color: var(--dot-green);
        }
        body.temp-task-selection .task-list-item.task-selected .task-time{
            color: var(--dot-green);
        }

#youtubeButton:not(:disabled):hover {
            color: var(--dot-green);
        }

        .empty-text {
            font-size: 0.9rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }
        body.theme-dark .empty-text { color: var(--muted); }

        .archive-group { margin-top: 0.5rem; }
        .archive-group summary {
            cursor: pointer;
            font-weight: 500;
            margin-bottom: 0.25rem;
        }
        .archive-group ul {
            margin-top: 0.25rem;
            margin-left: 1rem;
            max-height: none;
        }

        
        .year-group {
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }
        .year-summary {
            font-size: 1.2rem;
            font-weight: 800;
            cursor: pointer;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

.month-group {
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        .month-summary {
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 0.5rem;
            color: var(--text);
        }
        
        .week-group {
            margin-top: 0.5rem;
            margin-left: 0.5rem;
            border-left: 3px solid;
            padding-left: 0.75rem;
        }

        .week-group:nth-of-type(odd) {
            border-left-color: var(--dot-green);
        }
        .week-group:nth-of-type(odd) > .week-summary {
            color: var(--dot-green);
        }

        .week-group:nth-of-type(even) {
            border-left-color: var(--dot-blue);
        }
        .week-group:nth-of-type(even) > .week-summary {
            color: var(--dot-blue);
        }

        .week-summary {
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 0.25rem;
            display: flex;
            align-items: center;
        }
        
        .week-export-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: var(--comment-pink);
            border-radius: 50%;
            margin-right: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .week-export-dot:hover {
            transform: scale(1.3);
        }

        .archive-adhd-dot{
            display: inline-block;
            position: relative;
            top: -0.5px;
            width: 10px;
            height: 10px;
            background-color: var(--dot-orange);
            border-radius: 50%;
            margin-right: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            flex: 0 0 auto;
        }
        .archive-adhd-dot:hover{
            transform: scale(1.3);
        }

        .week-content {
            margin-left: 0.5rem;
        }

        .week-content .archive-summary .archive-label {
            color: var(--dot-green);
            font-weight: 600;
        }

        .archive-group .task-list .task-name,
        .archive-group .task-list .task-time {
            color: var(--comment-pink);
        }

        .archive-summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            list-style: none;
        }
        .archive-summary .archive-label {
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .archive-summary .archive-actions {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        .archive-action-btn {
            padding: 0.25rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: var(--btn-bg);
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--text);
        }
        .archive-action-btn:hover {
            background: rgba(37,99,235,0.12);
            border-color: rgba(37,99,235,0.35);
        }
        .archive-action-btn:disabled {
            opacity: 0.5;
            cursor: default;
        }

        .task-comment-row{
            border-bottom: 1px solid var(--border-soft);
            padding: 0.4rem 0.25rem 0.55rem;
            margin: -0.2rem 0 0.2rem;
        }
        .task-comment-box{
            border: 1px solid var(--border);
            background: rgba(148,163,184,0.08);
            border-radius: 0.5rem;
            padding: 0.5rem 0.65rem;
            font-size: 0.9rem;
            color: #374151;
            white-space: pre-wrap;
        }
        body.theme-dark .task-comment-box{
            color: #cbd5e1;
            background: rgba(148,163,184,0.10);
        }

        .compact-control {
            display: none;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
            font-size: 0.85rem;
            color: var(--muted);
        }
        .compact-control input[type=range] {
            width: 120px;
            cursor: pointer;
        }



        /* Sekvensmodus (oppgavelinje) */
        .adhd-strip-wrap{
            display:none;
            justify-content:center;
            margin: 0.35rem 0 0.6rem;
        }
        body.adhd-mode-active .adhd-strip-wrap{
            display:flex;
        }

        /* Sekvensmodus erstatter tidslinje i samme ramme */
        #adhdTimelineHost{ display:none; }
        body.adhd-mode-active #timelineWrap{ display:none; }
        body.adhd-mode-active #adhdTimelineHost{ display:block; }
        .adhd-strip{
            width:100%;
            background: transparent;
            border:0;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
            text-align:center;
            user-select:none;
        }
        .adhd-strip-line{
            height: 8px;
            width: 100%;
            border-radius: 999px;
            opacity: 0.95;
            margin: 0.05rem 0 0.45rem;
            max-width: none;
            transition: background 0.15s ease, opacity 0.15s ease, filter 0.15s ease;
            display:flex;
            gap:2px;
            align-items:stretch;
            overflow:hidden;
            background: rgba(148,163,184,0.18);
            padding: 0;
        }
        .adhd-strip-line .adhd-strip-seg{
            flex: 1 1 0;
            min-width: 0;
            height: 100%;
            border-radius: 999px;
            background: linear-gradient(90deg,#60a5fa,#a78bfa,#f472b6,#f59e0b,#34d399,#60a5fa);
            background-size: 220% 100%;
            animation: adhdLineFlow 6s linear infinite;
            transition: background 0.18s ease, opacity 0.18s ease, filter 0.18s ease;
        }
        .adhd-strip-line .adhd-strip-seg.is-done{
            background: #22c55e;
            animation: adhdDoneSegGlowPulse 2s ease-in-out infinite;
            box-shadow: 0 0 0 0 rgba(22,163,74,0.0);
            position: relative;
            z-index: 1;
        }
        .adhd-strip-line .adhd-strip-seg.is-placeholder{
            flex: 1 1 auto;
        }
        body.adhd-mode-active .adhd-strip-line{
            cursor: pointer;
        }
        body.adhd-mode-active .adhd-strip-line:hover{
            opacity: 1;
            filter: none;
        }
        body.adhd-mode-active .adhd-strip-line:hover .adhd-strip-seg:not(.is-done){
            background: var(--dot-orange) !important;
            animation: none !important;
            opacity: 1;
            filter: none;
        }
        body.adhd-mode-active .adhd-strip-line:hover .adhd-strip-seg.is-done{
            opacity: 1;
            filter: none;
        }
        .adhd-strip-hint{
            font-size: 0.78rem;
            color: var(--muted);
            margin-bottom: 0.2rem;
        }
        .adhd-current-task{
            min-height: 2.1rem;
            display:flex;
            align-items:center;
            justify-content:center;
            gap: 0.5rem;
            line-height: 1.2;
        }
        .adhd-current-task.hidden{ visibility:hidden; }
        .adhd-current-text{
            font-weight: 700;
            color: var(--text);
            font-size: 1rem;
            max-width: calc(100% - 2.2rem);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: color 0.15s ease;
        }
        body.adhd-mode-active .adhd-current-text{
            cursor: pointer;
        }
        body.adhd-mode-active .adhd-current-text:hover{
            color: var(--dot-green);
        }
        .adhd-current-check{
            width: 18px;
            height: 18px;
            accent-color: #22c55e;
            cursor: pointer;
            flex: 0 0 auto;
        }
        .adhd-empty{
            color: var(--muted);
            font-size: 0.9rem;
            font-style: italic;
        }
        .adhd-current-task.is-completing{
            transform-origin:center;
        }
        .adhd-current-text.is-completing-green{
            animation: adhdTaskTextBlinkGreen 0.5s ease-in-out 2;
        }
        .adhd-current-task.is-entering{
            animation: adhdTaskEnter 0.28s ease-out;
        }
        .adhd-summary-pill{
            display:inline-block;
            font-size: 0.82rem;
            padding: 0.2rem 0.55rem;
            border:1px solid var(--border);
            border-radius: 999px;
            background: var(--btn-bg);
            margin-top: 0.1rem;
        }
        @keyframes adhdLineFlow {
            0%{ background-position: 0% 50%; }
            100%{ background-position: 220% 50%; }
        }
        @keyframes adhdDoneSegGlowPulse {
            0% {
                box-shadow:
                    0 0 0 0 rgba(22,163,74,0.38),
                    0 0 4px rgba(22,163,74,0.35),
                    inset 0 0 2px rgba(255,255,255,0.18);
                filter: brightness(1);
            }
            70% {
                box-shadow:
                    0 0 0 6px rgba(22,163,74,0),
                    0 0 10px rgba(22,163,74,0.5),
                    inset 0 0 3px rgba(255,255,255,0.22);
                filter: brightness(1.06);
            }
            100% {
                box-shadow:
                    0 0 0 0 rgba(22,163,74,0),
                    0 0 4px rgba(22,163,74,0.32),
                    inset 0 0 2px rgba(255,255,255,0.16);
                filter: brightness(1);
            }
        }
        @keyframes adhdTaskPulseRainbow {
            0% { filter:none; transform: scale(1); }
            20% { color:#ef4444; transform: scale(1.02); }
            40% { color:#f59e0b; transform: scale(1.04); }
            60% { color:#10b981; transform: scale(1.03); }
            80% { color:#3b82f6; transform: scale(1.04); }
            100% { color:#a855f7; transform: scale(1.02); }
        }
        @keyframes adhdTaskTextBlinkGreen {
            0%, 100% { color: var(--text); }
            25%, 75% { color: #16a34a; }
            50% { color: #22c55e; }
        }
        @keyframes adhdTaskExitUp {
            from { opacity: 1; transform: translateY(0) scale(1.02); }
            to { opacity: 0; transform: translateY(-18px) scale(0.98); }
        }
        @keyframes adhdTaskEnter {
            from { opacity:0; transform: translateY(10px); }
            to { opacity:1; transform: translateY(0); }
        }
        @keyframes adhdChartHoldBlink {
            0% { outline-color: rgba(249,115,22,0.95); box-shadow: 0 0 0 2px rgba(249,115,22,0.25) inset, 0 0 0 0 rgba(249,115,22,0.0); }
            50% { outline-color: rgba(249,115,22,0.20); box-shadow: 0 0 0 1px rgba(249,115,22,0.10) inset, 0 0 0 0 rgba(249,115,22,0.0); }
            100% { outline-color: rgba(249,115,22,0.95); box-shadow: 0 0 0 2px rgba(249,115,22,0.25) inset, 0 0 0 0 rgba(249,115,22,0.0); }
        }
        .chart-wrapper.adhd-hold-arming{
            outline: 2px solid var(--dot-orange);
            outline-offset: 2px;
            border-radius: 0.85rem;
            animation: adhdChartHoldBlink 0.5s step-end infinite;
        }
        .chart-wrapper.adhd-hold-arming #taskChart{
            outline: 2px solid transparent;
            outline-offset: 0;
            border-radius: 0.7rem;
        }

        .adhd-merged-chart-host{
            display:none;
            margin-top: 0.8rem;
            padding-top: 0.8rem;
            border-top: 1px solid var(--border-soft);
        }
        body.adhd-mode-active .adhd-merged-chart-host{
            display:block;
        }
        body.adhd-mode-active .adhd-merged-chart-host .chart-wrapper{
            max-width: none;
            width: 100%;
        }
        body.adhd-mode-active .adhd-merged-chart-host .chart-legend{
            margin-top: 0.65rem;
        }

        #adhdTasksOverlay .modal{
            max-width: 760px;
        }
        .adhd-modal-grid{
            display:grid;
            grid-template-columns: 46px 1fr;
            gap: 0;
            border:1px solid var(--border);
            border-radius: 0.75rem;
            overflow: hidden;
            background: var(--card);
        }
        .adhd-line-numbers{
            background: rgba(148,163,184,0.10);
            border-right:1px solid var(--border);
            font: 13px/1.7 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            color: var(--muted);
            padding: 0.6rem 0.35rem 0.6rem 0.25rem;
            text-align: right;
            white-space: pre;
            overflow: hidden;
            user-select:none;
        }
        .adhd-textarea{
            min-height: 260px;
            width:100%;
            resize: vertical;
            border:0;
            outline:none;
            border-radius: 0;
            padding: 0.6rem 0.7rem;
            background-image: linear-gradient(to bottom, transparent calc(1.7em - 1px), rgba(148,163,184,0.20) calc(1.7em - 1px), rgba(148,163,184,0.20) 1.7em);
            background-size: 100% 1.7em;
            line-height: 1.7;
            font: 13px/1.7 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }
        .adhd-modal-footnote{
            margin-top: 0.5rem;
            color: var(--muted);
            font-size: 0.85rem;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: var(--modal-backdrop);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .overlay.show { display: flex; }
        
        /* Kraftig blur i popup-vinduene (ikke bakgrunnen) – kun når Personlig tilpasning er aktiv OG glassmodus er aktivert */
        body.personal-strong-overlay-blur #settingsOverlay.overlay.show .modal,
        body.personal-strong-overlay-blur #personalCustomizeOverlay.overlay.show .modal{
            background: rgba(var(--glass-surface-rgb), calc(var(--glass-ui-alpha) + 0.08)) !important;
            border-color: rgba(var(--glass-border-rgb), 0.70) !important;
            backdrop-filter: blur(24px) saturate(140%) !important;
            -webkit-backdrop-filter: blur(24px) saturate(140%) !important;
        }

        #projectTaskDivisionOverlay{
            z-index: 12150;
        }
        #projectOverlay{
            z-index: 12000;
        }
        #projectOverlay .modal{
            position: relative;
            z-index: 1;
        }
        /* Sørg for at slett-prosjekt popup alltid ligger over andre overlays/modaler */
        #deleteTaskOverlay{
            z-index: 13050;
        }
        #deleteTaskOverlay .modal{
            position: relative;
            z-index: 1;
        }
        .modal {
            position: relative;
            background: var(--card);
            border-radius: 0.75rem;
            padding: 1.25rem 1.5rem;
            max-width: 520px;
            width: 100%;
            box-shadow: 0 20px 40px rgba(15,23,42,0.35);
            border: 1px solid rgba(0,0,0,0.02);
        }
        body.theme-dark .modal { border-color: rgba(255,255,255,0.06); box-shadow: 0 20px 40px rgba(0,0,0,0.45); }

        .modal h2 {
            margin: 0 0 0.75rem;
            font-size: 1.1rem;
            color: var(--text);
        }
        .modal p {
            margin: 0 0 0.75rem;
            font-size: 0.9rem;
            color: #374151;
        }
        body.theme-dark .modal p { color: #ffffff; }
        
        .settings-section {
            margin-bottom: 1.25rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-soft);
        }
        .settings-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .settings-section h3 {
            margin-top: 0;
            font-size: 1rem;
            color: var(--text);
        }

        .modal-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .modal-row label { font-size: 0.9rem; }
        .transfer-project-row {
            align-items: flex-start;
        }
        .transfer-subtask-wrap {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .modal-select, .modal-input, .modal-textarea {
            padding: 0.4rem 0.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            font-size: 0.9rem;
            background: transparent;
            color: var(--text);
        }
        select.modal-select{
            background: var(--select-bg);
            color: var(--select-text);
            border-color: var(--border);
        }
        body.theme-dark select.modal-select{
            background: var(--select-bg);
            color: var(--select-text);
            border-color: #94a3b8;
        }
        select.modal-select option{
            background: var(--select-bg);
            color: var(--select-text);
        }

        .modal-input{ width: 100%; }
        .modal-textarea{
            width: 100%;
            min-height: 120px;
            resize: vertical;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            overflow: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge legacy */
        }
        .modal-textarea::-webkit-scrollbar{
            width: 0;
            height: 0;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .modal-button-primary {
            padding: 0.45rem 0.9rem;
            border-radius: 0.5rem;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            background: var(--dot-blue);
            color: #ffffff;
            font-weight: 500;
        }

        .modal-close {
            position: absolute;
            top: 0.4rem;
            right: 0.6rem;
            border: none;
            background: transparent;
            font-size: 1.25rem;
            line-height: 1;
            cursor: pointer;
            color: var(--muted);
        }
        .modal-close:hover { color: var(--text); }

        #taskChart {
            width: 100%;
            max-width: 900px;
            height: 110px;
            display: block;
            margin: 0 auto;
        }

        .chart-legend {
            margin-top: 0.75rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem 1.25rem;
            font-size: 0.8rem;
            color: #374151;
        }
        body.theme-dark .chart-legend { color: #ffffff; }

        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .chart-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .chart-wrapper {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 110px;
            margin: 0 auto;
        }

        .chart-gif-overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }
        .chart-gif-overlay img {
            max-height: 100%;
            max-width: 100%;
            object-fit: contain;
            opacity: 0.9;
        }

        .inline-note {
            font-size: 0.8rem;
            color: var(--muted);
        }

        /* TIMELINE STYLES */
        .timeline-wrap{
            width: 100%;
            max-width: 900px;
            margin: 0.25rem auto 0;
            position: relative;
        }
        .timeline-bar{
            position: relative;
            height: 14px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(37,99,235,0.20);
            overflow: hidden;
            user-select: none;
            cursor: default;
            isolation: isolate;
        }
        body.theme-dark .timeline-bar{
            background: rgba(37,99,235,0.25);
        }

        .timeline-seg{
            position: absolute;
            top: 0;
            bottom: 0;
            border-radius: 999px; /* Can be 0 if contiguous, but small radius looks ok */
            transform: translateZ(0);
            will-change: left, width;
        }
        .timeline-seg.blue{ background: var(--dot-blue); opacity: 0.75; }
        .timeline-seg.orange{ background: var(--dot-orange); opacity: 0.85; }
        .timeline-seg.green{ background: var(--dot-green); opacity: 0.90; }

        .timeline-seg.clickable{
            cursor: pointer;
        }
        .timeline-seg.clickable:hover{
            filter: brightness(1.05);
        }

        .timeline-ticks{
            position: relative;
            height: 28px;
            margin-top: 0.5rem;
            user-select: none;
        }
        .timeline-tick{
            position: absolute;
            top: 0;
            width: 1px;
            height: 10px;
            background: var(--border);
        }
        body.theme-dark .timeline-tick{
            background: #94a3b8;
            opacity: 0.7;
        }
        .timeline-label{
            position: absolute;
            top: 12px;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: var(--muted);
            white-space: nowrap;
            font-family: monospace;
        }

        .timeline-curtain{
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            transition: max-height 220ms ease, opacity 180ms ease;
            margin-top: 0.65rem;
            border-top: 1px solid var(--border-soft);
            padding-top: 0;
        }
        .timeline-curtain.open{
            max-height: 140px;
            opacity: 1;
            padding-top: 0.75rem;
        }
        .timeline-curtain-header{
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        .timeline-curtain-title{
            font-weight: 600;
            color: var(--text);
        }
        .timeline-curtain-row{
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .timeline-curtain-row label{
            font-size: 0.9rem;
            color: var(--muted);
        }
        .timeline-curtain-close{
            padding: 0.25rem 0.6rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: var(--btn-bg);
            font-size: 0.8rem;
            cursor: pointer;
            color: var(--text);
        }
        .timeline-curtain-close:hover{
            background: rgba(37,99,235,0.12);
            border-color: rgba(37,99,235,0.35);
        }

        .timeline-now-layer{
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 14px;
            pointer-events: none;
            z-index: 20;
        }

        .timeline-now-dot{
            position: absolute;
            top: 0x;
            width: 12px;
            height: 12px;
            border-radius: 999px;
            transform: translateX(-50%);
            background: conic-gradient(
                #ef4444, #f97316, #facc15, #22c55e,
                #14b8a6, #3b82f6, #a855f7, #ef4444
            );
            box-shadow:
                0 0 0 2px rgba(255,255,255,0.85),
                0 6px 14px rgba(15,23,42,0.18);
            animation: spinRainbow 2.2s linear infinite;
            will-change: left;
        }

        body.theme-dark .timeline-now-dot{
            box-shadow:
                0 0 0 2px rgba(15,23,42,0.75),
                0 6px 14px rgba(0,0,0,0.45);
        }

        @keyframes spinRainbow{
            0%   { transform: translateX(-50%) rotate(0deg); }
            100% { transform: translateX(-50%) rotate(360deg); }
        }

        /* Switch Toggle Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
            margin-right: 0.5rem;
            vertical-align: middle;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--dot-green);
        }
        input:checked + .slider:before {
            transform: translateX(18px);
        }
        body.theme-dark .slider {
            background-color: #4b5563;
        }
        body.theme-dark input:checked + .slider {
            background-color: var(--dot-green);
        }

        /* Tilleggsfunksjoner: Hindre dobbeltelling = standard (blå) */
        #cpToggle2:checked + .slider {
            background-color: var(--dot-blue) !important;
        }

/* Midlertidig deaktivering ved «Gjenoppta dagen»: vis orange fyllfarge */
#cpToggle2.temp-restore-off + .slider {
    background-color: #f59e0b !important;
}
#cpToggle2.temp-restore-off ~ label[for="cpToggle2"],
.control-panel-row.guard-temp-disabled label[for="cpToggle2"] {
    color: #f59e0b !important;
    font-weight: 600;
}

@keyframes profileTempGuardBlinkOrange {
    0%, 100% {
        box-shadow: 0 0 0 0 rgba(245,158,11,0);
        transform: translateZ(0);
    }
    50% {
        box-shadow: 0 0 0 6px rgba(245,158,11,0.22);
        transform: translateZ(0);
    }
}
#profileButton.profile-temp-guard-indicator {
    background-color: #f59e0b !important;
    border-color: rgba(245,158,11,0.55) !important;
    color: #111827 !important;
}
body.theme-dark #profileButton.profile-temp-guard-indicator {
    color: #111827 !important;
}
#profileButton.profile-temp-guard-blink {
    animation: profileTempGuardBlinkOrange 0.5s ease-in-out 6;
}

    

        /* Standardfunksjon: Lagre profil automatisk ved «Avslutt arbeid» = blå */
        #autoSaveToggle:checked + .slider {
            background-color: var(--dot-blue) !important;
        }

        /* Under utvikling: Prosjektinndeling = rosa */
        #cpProjectDivisionToggle:checked + .slider {
            background-color: var(--comment-pink) !important;
        }

        /* Under utvikling: Sekvensmodus = orange */
        #cpToggle3:checked + .slider {
            background-color: #f59e0b !important;
        }
        .adhd-mode-toggle-label.is-active {
            color: #f59e0b !important;
            font-weight: 600;
        }
@keyframes blink-blue-copy {
    0% { box-shadow: 0 0 0 0 rgba(37,99,235,0.6); }
    70% { box-shadow: 0 0 0 8px rgba(37,99,235,0); }
    100% { box-shadow: 0 0 0 0 rgba(37,99,235,0); }
}
.copy-ready-blink {
    animation: blink-blue-copy 1.2s ease-in-out 1;
}

button:not([disabled]):hover {
    transform: translateY(-1px);
}


/* Ensure comment line breaks are visible when list is expanded */
.task-list.expanded .task-comment,
.task-list.expanded .task-comment-box,
.task-list.expanded textarea,
.task-list.expanded .comment {
    white-space: pre-wrap;
}


        .btn-delete-time {
            opacity: 0.45;
            filter: saturate(0.7);
            cursor: pointer;
        }
        .btn-delete-time:hover {
            opacity: 0.85;
            background-color: var(--danger) !important;
            color: #ffffff !important;
            border-color: var(--danger-border) !important;
        }


        .modal-button-primary.danger{
            background-color: var(--danger) !important;
            color: #ffffff !important;
            border-color: var(--danger-border) !important;
        }
        .modal-button-primary.danger:hover{
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.20);
        }

        /* Subtract-time mode: make stepper button red (override default green) */
        .btn-stepper.danger-stepper{
            background-color: var(--danger) !important;
            color: #ffffff !important;
        }
        .btn-stepper.danger-stepper:hover{
            background-color: var(--danger) !important;
        }

        /* Utvid liste: ensure expansion always affects visible scroll container */
        .task-list-wrapper.expanded .task-list{
            max-height: none !important;
            overflow-y: visible;
        }

        /* Group edit modal */
        .group-edit-backdrop{
            position: fixed;
            inset: 0;
            background: var(--modal-backdrop);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 1rem;
        }
        .group-edit-modal{
            width: min(520px, 95vw);
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            overflow: hidden;
        }
        .group-edit-header{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap: 0.75rem;
            padding: 0.85rem 1rem;
            border-bottom: 1px solid var(--border-soft);
        }
        .group-edit-title{ font-weight: 700; }
        .group-edit-close{
            border: 1px solid var(--border);
            background: var(--btn-bg);
            color: var(--text);
            border-radius: 10px;
            width: 34px;
            height: 34px;
            line-height: 30px;
            font-size: 20px;
            cursor: pointer;
        }
        .group-edit-body{ padding: 1rem; display:flex; flex-direction:column; gap: 0.5rem; }
        .group-edit-label{ font-size: 0.9rem; color: var(--muted); margin-top: 0.35rem; }
        .group-edit-input{
            padding: 0.6rem 0.75rem;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--select-bg);
            color: var(--text);
            font-size: 1rem;
        }
        .group-edit-colorrow{ display:flex; align-items:center; gap: 0.75rem; }
        .group-edit-color{ width: 56px; height: 40px; padding:0; border: 1px solid var(--border); border-radius: 10px; background: transparent; cursor: pointer;}
        .group-edit-actions{ display:flex; justify-content:flex-end; gap: 0.5rem; margin-top: 0.75rem; }

    
        /* Settings modal: allow internal scroll so Kontrollpanel ends up below fold */
        #settingsOverlay .modal{
            max-height: 84vh;
            overflow-y: auto;
            max-width: 760px;
            }

        /* Kontrollpanel buttons (placeholder) */
        #controlPanelSection{
            margin-top: 1rem;
            border-top: 1px solid var(--border-soft);
            padding-top: 1rem;
        }
        .control-panel-buttons{
            display: none;
            margin-top: 0.75rem;
            border-top: 1px solid var(--border-soft);
            padding-top: 0.75rem;
        }
        .control-panel-buttons.open{
            display: block;
        }
        .control-panel-row{
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            flex-wrap: nowrap;
            margin-top: 0.6rem;
        }
        .control-panel-row:first-child{
            margin-top: 0;
        }
        .control-panel-left{
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 0;
            flex: 1 1 54%;
            max-width: 54%;
        }
        .control-panel-help{
            margin-left: auto;
            text-align: left;
            margin-top: 0;
            margin-bottom: 0;
            white-space: normal;
            flex: 0 1 46%;
            max-width: 46%;
            line-height: 1.25;
        }

        #personalCustomizationRow .control-panel-left{
            max-width: none;
            flex: 1 1 auto;
        }

        #personalCustomizationRow .pc-label-stack{
            display:flex;
            flex-direction:column;
            gap:0.12rem;
            min-width:0;
        }
        #personalCustomizationRow .pc-label-stack .helper-text{
            margin:0;
            line-height:1.2;
        }
        #personalCustomizationRow{
            align-items:flex-start;
            flex-wrap:wrap;
        }
        #personalCustomizationRow > .helptext-container{
            order:2;
            flex:1 1 100%;
            width:100%;
            margin-left:2.1rem !important;
        }
        #personalCustomizationRow > #personalCustomizeActionWrap{
            order:3;
            flex:1 1 100%;
            width:100%;
            margin-left:2.1rem !important;
            margin-top:0.25rem;
        }
        #personalCustomizationRow > #personalCustomizeActionWrap > div{
            justify-content:flex-start !important;
        }

        #underDevelopmentItems{
            display:none;
            margin-top: 0;
        }
        #underDevelopmentItems.open{
            display:block;
            margin-top: 0.45rem;
            padding-top: 0.15rem;
        }

</style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react/": "https://esm.sh/react@^19.2.3/",
    "recharts": "https://esm.sh/recharts@^3.6.0"
  }
}
</script>

<script>
// Clipboard helper: supports Firefox (fallback to writeText / execCommand)
async function copyToClipboard(htmlContent, plainText) {
    try {
        if (window.isSecureContext && navigator.clipboard) {
            // Rich clipboard (Chrome/Edge/Safari etc.)
            if (navigator.clipboard.write && window.ClipboardItem) {
                const clipboardItem = new ClipboardItem({
                    'text/plain': new Blob([plainText], { type: 'text/plain' }),
                    'text/html': new Blob([htmlContent], { type: 'text/html' })
                });
                await navigator.clipboard.write([clipboardItem]);
                return true;
            }
            // Plain text fallback (Firefox)
            if (navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(plainText);
                return true;
            }
        }
    } catch (err) {
        // fall through
    }

    // Last resort fallback
    try {
        const ta = document.createElement('textarea');
        ta.value = plainText;
        ta.setAttribute('readonly', '');
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        ta.style.top = '0';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return !!ok;
    } catch (err) {
        return false;
    }
}

// Enable copy button when selecting a historical day
if (archiveListEl && copyOneNoteButtonEl) {
    archiveListEl.addEventListener("click", (e) => {
        archiveListEl.querySelectorAll(".archive-summary").forEach(el => el.classList.remove("selected"));
        const dayItem = e.target.closest(".archive-summary");
        if (!dayItem) return;

        selectedArchiveForCopy = dayItem.getAttribute("data-archive-id");
        const archive = data.archives.find(a => a.id === selectedArchiveForCopy);
        copyOverrideTasks = archive ? archive.tasks : null;

        copyOneNoteButtonEl.disabled = false;
        copyOneNoteButtonEl.classList.remove("copy-ready-blink");
        void copyOneNoteButtonEl.offsetWidth;
        copyOneNoteButtonEl.classList.add("copy-ready-blink");
        setTimeout(() => {
            copyOneNoteButtonEl.classList.remove("copy-ready-blink");
        }, 1300);
    });
}

// Dedicated OneNote copy for history (day-level)
if (El && archiveListEl) {
    El.addEventListener("click", async () => {
        const selectedDay = archiveListEl.querySelector(".archive-summary.selected");
        if (!selectedDay) return;

        const archiveId = selectedDay.getAttribute("data-archive-id");
        const archive = data.archives.find(a => a.id === archiveId);
        if (!archive || !Array.isArray(archive.tasks)) return;

        const escapeHtml = (text) => {
            if (!text) return "";
            return text.replace(/&/g, "&amp;")
                       .replace(/</g, "&lt;")
                       .replace(/>/g, "&gt;")
                       .replace(/"/g, "&quot;")
                       .replace(/'/g, "&#039;");
        };


        const roundingOn = isRoundingEnabled || (toggleRoundingButtonEl && toggleRoundingButtonEl.classList.contains("btn-rounding-active"));

        const plainText = archive.tasks.map(t => {
            let ms = t.totalMs || 0;
            if (roundingOn) ms = getRoundedMs(ms);
            const timeStr = formatDuration(ms, false);
            const comment = t.comment || "";
            return `${t.name}
${timeStr}
${comment}
-`;
        }).join("\n\n");

        const htmlContent = archive.tasks.map(t => {
            let ms = t.totalMs || 0;
            if (roundingOn) ms = getRoundedMs(ms);
            const timeStr = formatDuration(ms, false);
            const safeName = escapeHtml(t.name);
            const safeComment = escapeHtml(t.comment || "").replace(/\n/g, "<br>");
            return `<div style="margin-bottom: 1em;"><b>${safeName}</b><br><span style="color: #16a34a; font-weight: 600;">${timeStr}</span><br>${safeComment}<br>-</div>`;
        }).join("");

        await copyToClipboard(htmlContent, plainText);
    });
}
</script>
</head>
<body>
<div id="customPageBackgroundLayer" aria-hidden="true">
    <div id="customPageBgFill" class="custom-page-bg-fill"></div>
    <img id="customPageBgImage" class="custom-page-bg-media" alt="" />
    <video id="customPageBgVideo" class="custom-page-bg-media" muted loop playsinline preload="metadata"></video>
</div>

<header class="header-bar">
    <div class="header-left">
        <h1 id="appNotesButton" style="cursor:pointer;" title="trykk for å åpne notater"><span id="appNotesIndicator" aria-hidden="true"></span><span id="appTitleText">BIMføring tidsregistrering</span></h1>
        <div class="time-now" id="timeNow"></div>
    </div>
    <div class="header-right">
        <button id="themeToggleButton" class="btn-secondary" type="button" title="Bytt mellom lys, mørk og svart modus">Mørkmodus</button>
        <button id="profileButton" class="btn-secondary" type="button" style="margin-top: 0.25rem;" title="Administrer profiler og data">Profil og innstillinger</button>
        <div style="margin-top:0.25rem;">Utviklet av:<br>Mathias Weiseth Gran, BIM Tekniker<br>siste endring: 02.03.2026</div>
    </div>
</header>

<div id="frutigerMusicPlayerWrap" class="frutiger-music-player-wrap" aria-hidden="true">
    <div class="frutiger-music-player">
        <div class="frutiger-music-row frutiger-music-row-top">
            <strong id="frutigerMusicPlayerTitle">Frutiger Aero Archive – Music</strong>
            <span id="frutigerMusicStatus" class="frutiger-music-status">Av</span>
        </div>
        <div class="frutiger-music-row frutiger-music-row-controls">
            <button id="frutigerMusicStartStopButton" class="btn-secondary" type="button">Start</button>
            <button id="frutigerMusicPauseButton" class="btn-secondary" type="button">Pause</button>
            <button id="frutigerMusicPrevButton" class="btn-secondary" type="button">Forrige</button>
            <button id="frutigerMusicNextButton" class="btn-secondary" type="button">Neste</button>
        </div>
        <div id="frutigerMusicTrackName" class="frutiger-music-track">Ingen sang valgt</div>
        <audio id="frutigerMusicAudio" preload="none"></audio>
    </div>
</div>

<div id="adhdStripWrap" class="adhd-strip-wrap" title="Klikk for å legge inn eller endre oppgavelisten">
    <div id="adhdStrip" class="adhd-strip">
        <div class="adhd-strip-line" aria-hidden="true"></div>
        <div class="helptext-container" data-helptext-container="true"><div class="adhd-strip-hint helper-text">Klikk linjen for å legge inn eller endre oppgaver</div></div>
        <div id="adhdCurrentTask" class="adhd-current-task">
            <div id="adhdCurrentTaskEmpty" class="adhd-empty">Ingen oppgaver lagt inn</div>
            <span id="adhdCurrentTaskText" class="adhd-current-text" style="display:none;"></span>
            <input id="adhdCurrentTaskCheck" class="adhd-current-check" type="checkbox" style="display:none;" aria-label="Marker oppgave som fullført">
        </div>
        <div id="adhdSummaryPill" class="adhd-summary-pill" style="display:none;"></div>
    </div>
</div>

<section class="card" id="timelineCard">
    <div class="card-header">
        <div class="card-header-left">
            <span><strong id="timelineCardTitle">Tidslinje</strong></span>
        </div>
    </div>

    <div id="adhdTimelineHost"></div>
    <div class="timeline-wrap" id="timelineWrap">
        <!-- Main Bar - Content generated by JS -->
        <div id="dayTimelineBar" class="timeline-bar" title="Viser arbeidsfordeling."></div>

        <!-- Rainbow dot layer -->
        <div class="timeline-now-layer">
            <div id="timelineNowDot" class="timeline-now-dot" aria-hidden="true"></div>
        </div>

        <div id="dayTimelineTicks" class="timeline-ticks"></div>

        <div id="dayTimelineCurtain" class="timeline-curtain">
            <div class="timeline-curtain-header">
                <div id="dayTimelineCurtainTitle" class="timeline-curtain-title">Juster tid</div>
                <div style="display:flex; flex-direction:column; align-items:flex-end; gap:0.5rem;">
                    <button id="dayTimelineResetButton" type="button" class="timeline-curtain-close">
                        Tilbakestill tidslinjen
                    </button>
                    <button id="dayTimelineCurtainClose" type="button" class="timeline-curtain-close">
                        Lukk
                    </button>
                </div>
            </div>

            <div class="timeline-curtain-row">
                <label id="dayTimelineFromLabel" for="dayTimelineFrom">Fra:</label>
                <select id="dayTimelineFrom" class="modal-select"></select>

                <label id="dayTimelineToLabel" for="dayTimelineTo">Til:</label>
                <select id="dayTimelineTo" class="modal-select"></select>

                <span class="helper-text" id="dayTimelineCurtainHint"></span>
            </div>
        </div>
    </div>
</section>

<section class="card">
    <div class="card-header">
        <span><strong id="chartCardTitle">Fordeling av prosjekter (tid)</strong></span>
    </div>

    <div class="chart-wrapper">
        <div id="taskChartGifOverlay" class="chart-gif-overlay">
            <img src="din-animasjon.gif" alt="Start et prosjekt for å se fordelingen" />
        </div>
        <canvas id="taskChart" width="900" height="110"></canvas>
    </div>

    <div id="chartLegend" class="chart-legend"></div>
</section>

<section class="card" id="projectInputCard">
    <div><strong id="projectCardTitle">Prosjekt</strong></div>
    <div class="task-input-row">
        <div class="task-input-wrapper">
            <input type="text" id="taskInput" placeholder="Skriv inn prosjektnavn …" />
            <div id="taskSuggestions"></div>
        </div>
        <button id="startButton" title="Start tidsur for valgt prosjekt">Start arbeid</button>
    </div>
    <div class="helper-text" id="selectionInfo">
        Skriv inn et prosjekt og trykk Enter eller «Start arbeid».
    </div>
</section>

<section class="card" id="currentTaskCard">
    <div class="current-task">
        <div>
            <div>
                <span id="currentTaskLabel" class="current-task-label">Nåværende prosjekt</span>
            </div>
            <div id="currentTaskName" class="current-task-title">Ingen aktivt prosjekt</div>
            <div class="current-task-actions">
                <button id="transferTimeButton" class="btn-secondary" disabled title="Flytt tid mellom prosjekter">Overfør tid mellom</button>
                <button id="adjustStartButton" class="btn-secondary" disabled title="Legg til tid på aktivt prosjekt">Tilfør tid</button>
            </div>
            <div class="inline-note" id="currentTaskHint"></div>
        </div>
        <div style="text-align:right;">
            <div id="currentTaskTime" class="current-task-time">00:00:00</div>
            <button id="endButton" class="btn-secondary" disabled title="Stopp tid og avslutt dagen">Avslutt arbeid</button>
        </div>
    </div>
</section>

<section class="card">
    <div class="card-header">
        <div class="card-header-left">
            <span><strong id="taskListCardTitle">Arbeidsliste (dagens)</strong></span>
            <button id="copyOneNoteButton" class="btn-secondary" type="button" disabled title="Kopier sammendrag til utklippstavle">Kopier for Onenote</button>
            <button id="toggleAllCommentsButton" class="btn-secondary" type="button" disabled title="Vis/skjul alle kommentarer">Vis kommentarer</button>
            <button id="toggleListHeightButton" class="btn-secondary" type="button" disabled title="Endre høyde på oppgaveliste">Utvid liste</button>
            <button id="toggleRoundingButton" class="btn-secondary" type="button" title="Runder tid til nærmeste 30min/1t">Avrund tid</button>
        </div>
        <button id="clearButton" class="btn-secondary" disabled title="Tøm listen og arkiver til historikk">Tøm og arkiver</button>
    </div>
    <p class="helper-text" id="taskListHelper">
        Klikk på et prosjekt i listen for å velge det. Knappen over feltet blir da «Gjenoppta arbeid».
        Dobbeltklikk på den rosa sirkelen for å legge til eller vise kommentar.
    </p>
    <div class="task-list-wrapper">
        <div id="resizeHandle" title="Dra for å justere kolonnebredde"></div>
        <ul id="taskList" class="task-list"></ul>
    </div>
    <div id="emptyListText" class="empty-text helper-text">Ingen prosjekter registrert ennå.</div>
</section>

<section class="card">
    <div class="card-header">
        <div class="card-header-left archive-header-toggle" id="archiveHeaderToggle" role="button" tabindex="0" aria-expanded="true">
            <span class="archive-toggle-arrow" id="archiveToggleArrow" aria-hidden="true">▾</span>
            <span><strong id="archiveCardTitle">Historikk</strong></span>
        </div>
        <div class="card-header-buttons">

            <button id="exportButton" class="btn-secondary" title="Last ned all historikk som CSV">Eksporter til Excel</button>
            <button id="clearArchivesButton" class="btn-secondary" title="Slett all historikk permanent">Slett historikk</button>
        </div>
    </div>

    <div id="archiveContentWrap">
        <p class="helper-text" id="archiveHelper">
            Når du tømmer listen, blir prosjektene flyttet hit, gruppert på dag, måned og år.
            Du kan gjenoppta et arkivert prosjekt kun dersom det er samme dato.
        </p>
        <div id="archiveList"></div>
    </div>
</section>

<!-- Settings Modal -->
<div id="adhdTasksOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="adhdTasksCloseButton">&times;</button>
        <h2>Sekvensmodus – oppgaveliste</h2>
        <p class="helper-text">Legg inn én oppgave per linje. Rekkefølgen brukes i visningen øverst på nettsiden.</p>
        <div class="adhd-modal-grid">
            <div id="adhdLineNumbers" class="adhd-line-numbers">1</div>
            <textarea id="adhdTasksTextarea" class="modal-textarea adhd-textarea" spellcheck="false" placeholder="SHIFT + ENTER for linjeskift"></textarea>
        </div>
        <div class="adhd-modal-footnote helper-text">Tomme linjer ignoreres. Dobbeltklikk den fargede linjen øverst for å åpne denne dialogen igjen.</div>
        <div class="modal-actions" style="margin-top:0.9rem;">
            <button id="adhdTasksCancelButton" type="button" class="btn-secondary">Avbryt</button>
            <button id="adhdTasksOkButton" type="button" class="btn-secondary">OK</button>
        </div>
    </div>
</div>

<div id="projectTaskDivisionOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="projectTaskDivisionCloseButton">&times;</button>
        <h2>Prosjektoppgaver</h2>
        <p class="helper-text">Legg inn én oppgave per linje. Listen er knyttet til valgt prosjekt.</p>
        <div class="adhd-modal-grid">
            <div id="projectTaskDivisionLineNumbers" class="adhd-line-numbers">1</div>
            <textarea id="projectTaskDivisionTextarea" class="modal-textarea adhd-textarea" spellcheck="false" placeholder="SHIFT + ENTER for linjeskift"></textarea>
        </div>
        <div class="modal-actions" style="margin-top:0.9rem;">
            <button id="projectTaskDivisionCancelButton" type="button" class="btn-secondary">Avbryt</button>
            <button id="projectTaskDivisionOkButton" type="button" class="btn-secondary">OK</button>
        </div>
    </div>
</div>

<div id="adhdDiscardOverlay" class="overlay">
    <div class="modal">
        <h2>Deaktiver Sekvensmodus</h2>
        <p id="adhdDiscardMessage">Dette vil deaktivere Sekvensmodus. Fortsette?</p>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="adhdDiscardCancelButton" class="btn-secondary" type="button">Avbryt</button>
            <button id="adhdDiscardConfirmButton" class="modal-button-primary" type="button" style="background: var(--danger);">Deaktiver</button>
        </div>
        <div class="helper-text" style="text-align:center; margin-top: 0.75rem;">ESC eller klikk utenfor = angre</div>
    </div>
</div>

<div id="personalCustomizeOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="personalCustomizeCloseButton">&times;</button>
        <h2>Personlig tilpasning</h2>
        <div class="helptext-container" data-helptext-container="true" style="margin-bottom:0.6rem;">
            <div class="helper-text">Her kan du tilpasse det visuelle slik du selv ønsker, NB! Tekst og menyer kan bli vanskelig å lese. <span class="ctrl-hint-orange">Hold nede CTRL tasten hvis du ikke klarer se ellr lese tekst</span></div>
        </div>
        <div class="personal-customize-scroll-panel" style="border:1px solid var(--border); border-radius:0.65rem; padding:0.55rem; max-height:52vh; overflow:auto; background: color-mix(in srgb, var(--card) 94%, transparent);">
            <div class="personal-bg-panel">
                <div style="font-weight:700; margin:0 0 0.35rem 0.05rem;">Tilpass bimføring</div>
                <div class="helptext-container" data-helptext-container="true" style="margin:0 0 0.45rem 0.05rem;">
                    <div class="helper-text">Her kan du tilpasse det visuelle slik du selv ønsker</div>
                </div>
                <div class="personal-bg-top-buttons">
                    <button id="personalBgCustomizeButton" type="button" class="btn-secondary" aria-pressed="false">Tilpass bakgrunnen</button>
                    <button id="personalRenameControlsToggleButton" type="button" class="btn-secondary" aria-pressed="false">Tilpass overskrifter</button>
                </div>

                <div id="personalBgAutoSwapWrap" class="personal-bg-archive-toolbar" aria-hidden="true" style="margin-top:0.55rem; display:none;">
                    <div class="personal-bg-slider-row">
                        <label for="personalFruitigerArchiveIntervalRange">Intervall</label>
                        <input id="personalFruitigerArchiveIntervalRange" type="range" min="0" max="600" step="5" value="45" />
                        <span id="personalFruitigerArchiveIntervalValue">45s</span>
                    </div>
                    <div class="personal-bg-archive-toolbar-buttons">
                        <button id="personalFruitigerArchiveModeToggle" type="button" class="btn-secondary" aria-pressed="false">Samme kategori</button>
                    </div>
                </div>
<div id="personalRenameControlsWrap" class="personal-rename-controls" aria-hidden="true">
                    <div style="font-weight:700; margin:0 0 0.5rem 0.15rem;">Tilpass overskrifter</div>
                    <div id="personalCustomizeRows"></div>
                </div>
                <div id="personalBgControlsWrap" class="personal-bg-controls" aria-hidden="true">
                    <div class="personal-bg-action-buttons">
                        <div class="personal-bg-action-stack">
                            <button id="personalBgColorButton" type="button" class="btn-secondary">Tilpass bakgrunnsfarge</button>
                            <button id="personalBgTextColorButton" type="button" class="btn-secondary" aria-pressed="false">Overstyr tekstfarge</button>
                        </div>
                        <button id="personalBgMediaButton" type="button" class="btn-secondary">Last opp et bilde eller video</button>
                        <button id="personalBgMediaHistoryButton" type="button" class="btn-secondary">Historikk bilder / video</button>
                        <button id="personalBgGlassButton" type="button" class="btn-secondary" aria-pressed="false">Glassmodus</button>
                        <button id="personalFruitigerArchiveButton" type="button" class="btn-secondary" aria-pressed="false">The Frutiger Aero Archive</button>
                        <input id="personalBgMediaInput" type="file" accept="image/*,video/*" style="position:fixed; left:-99999px; top:0; opacity:0; width:1px; height:1px; pointer-events:none;" />
                    </div>
                    <div id="personalBgGlassControls" class="personal-bg-glass-controls" aria-hidden="true">
                        <div class="personal-bg-slider-row" style="margin-bottom:0;">
                            <label for="personalBgGlassOpacityRange">Gjennomsiktighet</label>
                            <input id="personalBgGlassOpacityRange" type="range" min="0" max="100" step="1" value="28" />
                            <span id="personalBgGlassOpacityValue">28%</span>
                        </div>
                        <div class="personal-bg-blur-presets" role="group" aria-label="Blurvalg">
                            <button id="personalBgBlurOffButton" type="button" class="btn-secondary" aria-pressed="false">AV</button>
                            <button id="personalBgBlurFastButton" type="button" class="btn-secondary" aria-pressed="false">Klar</button>
                            <button id="personalBgBlurPrettyButton" type="button" class="btn-secondary" aria-pressed="false">Uskarp</button>
                            <button id="personalBgBlurHeavyButton" type="button" class="btn-secondary" aria-pressed="false">Tåkete</button>
                        </div>
                        <div class="helper-text" style="margin-top:0.45rem;">Blur: Klar = 1px, Uskarp = 12px, Tåkete = 24px</div>
                        <div class="helper-text" style="margin-top:0.2rem;">Mer blur = tyngere for maskinen</div>
                        <div class="helper-text" style="margin-top:0.2rem;">0% = solid bakgrunn, 100% = mest gjennomsiktig (glass)</div>
                    </div>
                    <div id="personalBgColorControls" class="personal-bg-color-controls">
                        <div class="personal-bg-slider-row">
                            <label for="personalBgHueRange">Fargetone</label>
                            <input id="personalBgHueRange" type="range" min="0" max="360" step="1" value="210" />
                            <span id="personalBgHueValue">210</span>
                        </div>
                        <div class="personal-bg-slider-row">
                            <label for="personalBgSatRange">Metning</label>
                            <input id="personalBgSatRange" type="range" min="0" max="100" step="1" value="35" />
                            <span id="personalBgSatValue">35%</span>
                        </div>
                        <div class="personal-bg-slider-row">
                            <label for="personalBgLightRange">Lyshet</label>
                            <input id="personalBgLightRange" type="range" min="0" max="100" step="1" value="96" />
                            <span id="personalBgLightValue">96%</span>
                        </div>
                        <div id="personalBgPreviewChip" class="personal-bg-preview-chip">Forhåndsvisning</div>
                    </div>
                    <div id="personalBgTextColorControls" class="personal-bg-color-controls" aria-hidden="true">
                        <div class="personal-bg-slider-row">
                            <label for="personalTextHueRange">Fargetone</label>
                            <input id="personalTextHueRange" type="range" min="0" max="360" step="1" value="220" />
                            <span id="personalTextHueValue">220</span>
                        </div>
                        <div class="personal-bg-slider-row">
                            <label for="personalTextSatRange">Metning</label>
                            <input id="personalTextSatRange" type="range" min="0" max="100" step="1" value="12" />
                            <span id="personalTextSatValue">12%</span>
                        </div>
                        <div class="personal-bg-slider-row">
                            <label for="personalTextLightRange">Lyshet</label>
                            <input id="personalTextLightRange" type="range" min="0" max="100" step="1" value="18" />
                            <span id="personalTextLightValue">18%</span>
                        </div>
                        <div id="personalTextPreviewChip" class="personal-bg-preview-chip">Tekstfarge forhåndsvisning</div>
                    </div>
                    <div id="personalFruitigerArchivePanel" class="personal-bg-archive-panel" aria-hidden="true">
                        <div class="personal-bg-archive-status" id="personalFruitigerArchiveStatus">Trykk på knappen for å hente kategorier fra Frutiger Aero Archive.</div>
                        <div id="personalFruitigerArchiveList" class="personal-bg-archive-list"></div>
                    </div>
                    <div id="personalBgMediaStatus" class="helper-text" style="margin-top:0.55rem;">Ingen bilde/video valgt</div>
                    <div id="personalBgMediaHistoryDropdown" class="personal-bg-media-history" aria-hidden="true"></div>
                </div>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between; gap:0.75rem; margin-top: 0.9rem;">
            <button id="personalCustomizeResetButton" type="button" class="btn-secondary">Tilbakestill</button>
            <div style="display:flex; gap:0.5rem;">
                <button id="personalCustomizeCancelButton" type="button" class="btn-secondary">Avbryt</button>
                <button id="personalCustomizeOkButton" type="button" class="btn-secondary">OK</button>
            </div>
        </div>
        <div class="helptext-container" data-helptext-container="true" style="margin-top:0.6rem; text-align:center;">
            <div class="helper-text">Endringene brukes når «personlig tilpasning» er aktiv.</div>
        </div>
    </div>
</div>

<div id="settingsOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="settingsCloseButton">&times;</button>
        <h2 id="settingsModalTitle">Profil og Innstillinger</h2>
        
        <div class="settings-section">
            <h3 id="settingsProfilesTitle">Profiler</h3>
            <p class="helper-text">Brukerprofiler kan lages for å holde data separert</p>
            
            <div class="modal-row" style="margin-top:0.5rem; border-top: 1px solid var(--border-soft); padding-top: 1rem;">
                <label for="newProfileName" style="min-width: 80px;">Ny profil:</label>
                <input type="text" id="newProfileName" class="modal-input" placeholder="Skriv inn et ønsket profilnavn her" style="flex:1;">
                <button id="createProfileButton" class="btn-secondary">Opprett</button>
            </div>
            
            
            
            
            <div class="modal-row">
                <label for="profileSelect" style="min-width: 80px;">Aktiv profil:</label>
                <select id="profileSelect" class="modal-select" style="flex:1; margin-right: 0.5rem;"></select>
                <button id="deleteProfileButton" type="button" class="btn-secondary" style="color: var(--danger);">Slett valgt</button>
            </div>
            <p class="helper-text" id="profileHelperText"></p>
        </div>

        <div style="margin-top: 1rem; border-top: 1px solid var(--border-soft); padding-top: 1rem; text-align: center;">
            <button id="youtubeButton" class="btn-secondary" style="width: 100%;">Se Dokumentasjon</button>
        </div>
    
        <div class="helper-text" style="text-align:center; margin-top: 0.75rem;">ESC = lukk og lagre</div>

        <!-- Tilleggsfunksjoner (placeholder buttons; no actions attached yet) -->
        <div class="settings-section" id="controlPanelSection">
            <h3 id="settingsExtrasTitle">Tilleggsfunksjoner</h3>

            <div class="modal-row" style="margin-top: 0.25rem;">
                <label class="switch">
                    <input type="checkbox" id="controlPanelToggle">
                    <span class="slider"></span>
                </label>
                <label id="controlPanelToggleLabel" for="controlPanelToggle" style="cursor:pointer; font-size: 0.9rem;">Åpne tilleggsfunksjoner</label>
            </div>

            <div id="controlPanelButtons" class="control-panel-buttons" aria-hidden="true">
                <!-- HJELPETEKST: Legg all ny hjelpetekst i egen wrapper:
                     <div class="helptext-container" data-helptext-container="true"><span class="helper-text">...</span></div>
                     Da vil "Ingen hjelpetekst" fortsatt virke automatisk. -->
                

                <div class="control-panel-row">
                    <div class="control-panel-left">
                        <label class="switch">
                            <input type="checkbox" id="cpToggle2" checked>
                            <span class="slider"></span>
                        </label>
                        <label for="cpToggle2" style="cursor:pointer; font-size: 0.9rem;">Hindre dobbeltelling</label>
                    </div>
                    <div class="helptext-container" data-helptext-container="true">
                        <span class="helper-text control-panel-help">Når aktivert vil nettsiden automatisk stoppe løpende telling ved midnatt. Deretter deaktiveres knappen «Gjenoppta arbeid». Hvis en telling har stått for lenge, vil du neste dag bli møtt med et vindu som spør når du avsluttet arbeidet. Dette korrigerer timeføringen, og du blir vist oversikten som normalt for overføring til Maconomy.</span>
                    </div>
                </div>
                <div class="control-panel-storage-chapter" style="border-top: 1px solid var(--border-soft); border-bottom: 1px solid var(--border-soft); margin: 0.15rem 0 0.35rem; padding: 0.4rem 0;">
                    <div style="font-size: 0.8rem; font-weight: 700; opacity: 0.85; margin: 0 0 0.35rem 0.15rem;">Lagring og gjenoppretting av profil</div>
                    <div class="control-panel-row" style="margin-top: 0;">
                        <div class="control-panel-left">
                            <label class="switch">
                                <input type="checkbox" id="autoSaveToggle" checked>
                                <span class="slider"></span>
                            </label>
                            <label for="autoSaveToggle" style="cursor:pointer; font-size: 0.9rem;">Lagre profil automatisk ved «Avslutt arbeid»</label>
                        </div>
                        <div class="helptext-container" data-helptext-container="true">
                            <span class="helper-text control-panel-help">Ingen liker å miste data, ha denne aktiv for å alltid ha oppdatert profil på egen maskin</span>
                        </div>
                    </div>
                    <div class="control-panel-row" style="margin-top: 0.25rem;">
                        <div class="control-panel-left" style="visibility:hidden; pointer-events:none;">
                            <label class="switch" aria-hidden="true">
                                <input type="checkbox" tabindex="-1">
                                <span class="slider"></span>
                            </label>
                            <span style="font-size: 0.9rem;">Plassholder</span>
                        </div>
                        <div style="margin-left: auto;">
                            <button id="downloadBackupButton" class="btn-secondary" style="margin-right: 0.35rem;">Lagre profil manuelt</button>
                            <button id="uploadBackupButton" class="btn-secondary">Gjenopprett profil</button>
                            <input type="file" id="backupFileInput" style="position: fixed; left: -99999px; top: 0; opacity: 0; width: 1px; height: 1px; pointer-events: none;" />
                        </div>
                    </div>
                </div>
<div class="control-panel-row" id="testDataControlRow">
                    <div class="control-panel-left">
                        <label class="switch">
                            <input type="checkbox" id="cpGenerateTestData">
                            <span class="slider"></span>
                        </label>
                        <label for="cpGenerateTestData" style="cursor:pointer; font-size: 0.9rem;">Aktiver testprofil med 3 års historikk</label>
                    </div>
                    <div class="helptext-container" data-helptext-container="true">
                        <span class="helper-text control-panel-help">For å deaktivere denne modusen må du slette profilen</span>
                    </div>
                </div>
                

                </div>
<div class="control-panel-under-dev" style="border-top: 1px solid var(--border-soft); margin: 0.35rem 0 0; padding: 0.45rem 0 0;">
                    <h3 id="underDevelopmentSectionTitle">Utviklerverktøy og betafunksjoner</h3>
                    <div class="helptext-container" data-helptext-container="true" style="margin: 0 0 0.45rem 0.15rem;">
                        <span class="helper-text">Funksjonene du finner her er under utvikling og kan plutselig bli endret eller slettet</span>
                    </div>
                    <div class="control-panel-row" id="underDevelopmentVisibilityRow" style="margin-top:0.25rem;">
                        <div class="control-panel-left" style="max-width:none; flex: 1 1 auto;">
                            <button id="underDevelopmentVisibilityButton" class="btn-secondary" type="button">Vis alt</button>
                        </div>
                    </div>
                    <div id="underDevelopmentItems" aria-hidden="true">
                    <div class="control-panel-row under-development">
                        <div class="control-panel-left">
                            <label class="switch">
                                <input type="checkbox" id="cpProjectDivisionToggle">
                                <span class="slider"></span>
                            </label>
                            <label for="cpProjectDivisionToggle" style="cursor:pointer; font-size: 0.9rem;">Prosjektinndeling</label>
                        </div>
                        <div class="helptext-container" data-helptext-container="true">
                            <span class="helper-text control-panel-help">Når denne er aktivert blir det mulig å dele inn et prosjekt i prosjektoppgaver, tid føres separat per oppgave, men alle oppgavene ligger under det samme prosjektet</span>
                        </div>
                    </div>
                    <div class="control-panel-row under-development">
                        <div class="control-panel-left">
                            <label class="switch">
                                <input type="checkbox" id="cpOneNoteReminderToggle">
                                <span class="slider"></span>
                            </label>
                            <label for="cpOneNoteReminderToggle" style="cursor:pointer; font-size: 0.9rem;">Onenote påminnelse</label>
                        </div>
                        <div class="helptext-container" data-helptext-container="true">
                            <span class="helper-text control-panel-help">Krever «Kopier for Onenote» før «Tøm og arkiver» kan brukes</span>
                        </div>
                    </div>
                    <div class="control-panel-row under-development" id="personalCustomizationRow">
                        <div class="control-panel-left">
                            <label class="switch">
                                <input type="checkbox" id="cpPersonalCustomizationToggle">
                                <span class="slider"></span>
                            </label>
                            <label for="cpPersonalCustomizationToggle" style="cursor:pointer; font-size: 0.9rem;">Personlig tilpasning</label>
                        </div>
                        <div class="helptext-container" data-helptext-container="true" style="margin-left:auto;">
                            <span class="helper-text control-panel-help">Her kan du tilpasse det visuelle slik du selv ønsker, NB! Tekst og menyer kan bli vanskelig å lese. <span class="ctrl-hint-orange">Hold nede CTRL tasten hvis du ikke klarer se ellr lese tekst</span></span>
                        </div>
                        <div id="personalCustomizeActionWrap" style="display:none; margin-left:0.5rem;">
                            <div style="display:flex; gap:0.4rem; flex-wrap:wrap; justify-content:flex-end;">
                                <button id="openPersonalCustomizeButton" class="btn-secondary" type="button">Tilpass</button>
                                <button id="toggleFrutigerMusicPlayerButton" class="btn-secondary" type="button" aria-pressed="false">The Frutiger Aero Archive, Music player</button>
                            </div>
                        </div>
                    </div>
                    <div class="control-panel-row under-development">
                        <div class="control-panel-left">
                            <label class="switch">
                                <input type="checkbox" id="cpToggle3">
                                <span class="slider"></span>
                            </label>
                            <label id="cpToggle3Label" class="adhd-mode-toggle-label" for="cpToggle3" style="cursor:pointer; font-size: 0.9rem;">Sekvensmodus</label>
                        </div>
                        <div class="helptext-container" data-helptext-container="true">
                            <span class="helper-text control-panel-help">Aktiverer Sekvensmodus som funksjon. Når denne er aktiv, kan du trykke og holde på kakediagrammet for å starte eller avslutte Sekvensmodus og oppgavelisten. For å kunne aktivere denne modusen må du først starte timeføring på et prosjekt.</span>
                        </div>
                    </div>
                    </div>
                </div>

</div>
        </div>

</div>
</div>

<div id="deleteProfileOverlay" class="overlay">
    <div class="modal">
        <h2>Slett profil</h2>
        <p>Er du sikker på at du vil slette profilen <strong id="deleteProfileNameDisplay"></strong>?</p>
        <p style="color: var(--danger);">Dette vil slette alle data tilhørende denne profilen permanent.</p>
        
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="deleteProfileCancelBtn" class="btn-secondary">Avbryt</button>
            <div style="display:flex; gap:0.5rem;">
                <button id="deleteProfileSaveDeleteBtn" class="btn-secondary">Lagre profil & Slett</button>
                <button id="deleteProfileConfirmBtn" class="modal-button-primary" style="background: var(--danger);">Slett profil</button>
            </div>
        </div>
    </div>
</div>


<div id="deleteTaskOverlay" class="overlay">
    <div class="modal">
        <h2>Slett prosjekt</h2>
        <p>Er du sikker på at du vil slette <strong id="deleteTaskNameDisplay"></strong> fra historikk?</p>
        <p class="helper-text" style="margin-top:0.25rem;">Ved å slette så fjernes prosjektet og tilhørende prosjektnummer fra historikken. Dersom prosjektet kan bli benyttet igjen ved en senere anledning, anbefales det i stedet å markere det som «utgått». Dette gjøres ved å trykke på blyantknappen til høyre for prosjektet. Utgåtte prosjekter bevares nederst i listen.</p>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="deleteTaskCancelBtn" class="btn-secondary" type="button">Angre</button>
            <button id="deleteTaskConfirmBtn" class="modal-button-primary" type="button" style="background: var(--danger);">Bekreft</button>
        </div>
        <div class="helper-text" style="text-align:center; margin-top: 0.75rem;">ESC eller klikk utenfor = angre</div>
    </div>
</div>

<div id="projectOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="projectCloseButton">&times;</button>
        <h2>Prosjektnummer</h2>
        <p class="helper-text">Legg inn prosjektnummer for prosjektet:</p>
        <p class="helper-text" style="margin-top:0.25rem;">Prosjektnummeret kan stå tomt, men da får du en påminnelse neste gang det brukes. Du kan legge det inn senere, eller redigere det med blyantknappen.</p>
        <p><strong id="projectTaskName"></strong></p>

        <div class="modal-row" id="projectNameEditRow" style="width:100%; display:none;">
            <input id="projectNameEditInput" class="modal-input" type="text" placeholder="Prosjektnavn …" />
        </div>

        <div class="modal-row" style="width:100%;">
            <input id="projectNumberInput" class="modal-input" type="text" placeholder="Prosjektnummer …" />
        </div>

        <div class="modal-row" id="projectTaskDivisionButtonRow" style="width:100%; justify-content:flex-start; display:none;">
            <button id="projectTaskDivisionButton" class="btn-secondary" type="button" aria-pressed="false">Prosjektoppgaver</button>
        </div>

        <div id="projectOutdatedWrap" class="project-outdated-wrap" style="display:none;">
            <label class="outdated-label" title="Marker prosjektet som utgått">
                <input id="projectOutdatedCheckbox" class="outdated-checkbox" type="checkbox" />
                <span>Utgått</span>
            </label>
        </div>
        <div class="modal-footer">
            <button id="projectCancelButton" class="btn-secondary" type="button">Avbryt</button>
            <button id="projectConfirmButton" class="modal-button-primary" type="button">Start arbeid</button>
        </div>
        <div class="helper-text">Enter = start. Prosjektnummer lagres per prosjektnavn til du sletter det fra historikk (X i forslaglisten).</div>
    </div>
</div>

<div id="overdueOverlay" class="overlay">
    <div class="modal">
        <h2 id="overdueTitle">Aktivt prosjekt har stått for lenge</h2>
        <p id="overdueMessagePrimary">
            Prosjektet <strong id="overdueTaskName"></strong> har vært aktivt i mer enn 10 timer.
        </p>
        <p id="overdueMessageSecondary">Når ble dette prosjektet fullført?</p>
        <div class="modal-row">
            <label for="overdueHour">Tidspunkt:</label>
            <select id="overdueHour" class="modal-select"></select>
            <span>:</span>
            <select id="overdueMinute" class="modal-select"></select>
        </div>
        <p class="helper-text">Valgt tidspunkt brukes til å beregne total tid for prosjektet.</p>
        <div class="modal-footer">
            <button id="overdueConfirmButton" class="modal-button-primary">
                Fullfør prosjekt til angitt tid og tøm og arkiver listen
            </button>
        </div>
    </div>
</div>

<div id="clearArchivesOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="clearArchivesCloseButton">&times;</button>
        <h2>Slette historikk</h2>
        <p>Du er i ferd med å slette all «Historikk».</p>
        <p>Velg om du vil kun slette, eller først eksportere til Excel og deretter slette.</p>
        <div class="modal-footer">
            <button id="clearArchivesCancelButton" class="btn-secondary">Avbryt</button>
            <button id="clearArchivesDeleteButton" class="btn-secondary">Slett all historikk</button>
            <button id="clearArchivesExportDeleteButton" class="modal-button-primary">Eksporter til Excel og slett</button>
        </div>
    </div>
</div>

<div id="clearTodayOverlay" class="overlay">
    <div class="modal">
        <h2>Tøm dagens arbeidsliste</h2>
        <p>Dette vil tømme dagens arbeidsliste, og det vil ikke lenger være mulig å gjenoppta prosjekter.</p>
        <p>Er du sikker på at du vil fortsette?</p>
        <div class="modal-footer">
            <button id="clearTodayCancelButton" class="btn-secondary">Avbryt</button>
            <button id="clearTodayConfirmButton" class="modal-button-primary">Tøm og arkiver</button>
        </div>
    </div>
</div>

<div id="oneNoteReminderOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="oneNoteReminderCloseButton">&times;</button>
        <h2>Onenote påminnelse</h2>
        <p>Husk å oppdatere loggen for timeføring!</p>
        <p class="helper-text">Trykk «Kopier for Onenote» før du bruker «Tøm og arkiver».</p>
        <div class="modal-footer">
            <button id="oneNoteReminderOkButton" class="modal-button-primary" type="button">OK</button>
        </div>
    </div>
</div>

<div id="commentOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="commentCloseButton">&times;</button>
        <h2>Kommentar</h2>
        <p><strong id="commentTaskName"></strong></p>
        <textarea id="commentTextarea" class="modal-textarea" placeholder="Skriv kommentar … (Enter = lagre)"></textarea>
        <div class="modal-footer">
            <button id="commentCancelButton" class="btn-secondary">Avbryt</button>
            <button id="commentSaveButton" class="modal-button-primary">Lagre</button>
        </div>
        <div class="helper-text">Tips: Enter lagrer. Shift+Enter gir linjeskift.</div>
    </div>
</div>

<div id="transferOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="transferCloseButton">&times;</button>
        <h2>Overfør tid mellom</h2>
        <p id="transferHelpDesc">
            Velg «Fra prosjekt» og «Til prosjekt». Det er ikke mulig å overføre mer tid enn det som er registrert på «Fra».
        </p>

        <div class="modal-row transfer-project-row">
            <label for="transferSource">Fra prosjekt:</label>
            <select id="transferSource" class="modal-select"></select>
            <div id="transferSourceSubtaskWrap" class="transfer-subtask-wrap" style="display:none;">
                <label for="transferSourceSubtask">Fra prosjektoppgave:</label>
                <select id="transferSourceSubtask" class="modal-select"></select>
            </div>
        </div>

        <div class="modal-row transfer-project-row">
            <label for="transferTarget">Til prosjekt:</label>
            <select id="transferTarget" class="modal-select"></select>
            <div id="transferTargetSubtaskWrap" class="transfer-subtask-wrap" style="display:none;">
                <label for="transferTargetSubtask">Til prosjektoppgave:</label>
                <select id="transferTargetSubtask" class="modal-select"></select>
            </div>
        </div>

        <div class="modal-row">
            <label>Varighet:</label>
            <select id="transferHours" class="modal-select"></select>
            <span>t</span>
            <select id="transferMinutes" class="modal-select"></select>
            <span>min</span>
        </div>

        <div class="helper-text" id="transferMaxHint"></div>

        <div class="modal-footer">
            <button id="transferCancelButton" class="btn-secondary">Avbryt</button>
            <button id="transferConfirmButton" class="modal-button-primary">Overfør</button>
        </div>
    </div>
</div>

<div id="adjustStartOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="adjustStartCloseButton">&times;</button>
        <h2 id="adjustStartTitle">Tilfør tid</h2>
        <p id="adjustStartDesc">
            Juster tid på det aktive prosjektet.
        </p>

        <div id="adjustStartTargetRow" class="modal-row transfer-project-row" style="display:none; margin-bottom:0.75rem;">
            <label for="adjustStartTarget">Prosjekt:</label>
            <select id="adjustStartTarget" class="modal-select"></select>
            <div id="adjustStartTargetSubtaskWrap" class="transfer-subtask-wrap" style="display:none;">
                <label for="adjustStartTargetSubtask">Prosjektoppgave:</label>
                <select id="adjustStartTargetSubtask" class="modal-select"></select>
            </div>
        </div>

        <div id="adjustStartModeTime" style="display:none;">
            <p>Sett starttidspunkt:</p>
            <div class="modal-row">
                <select id="adjustStartHour" class="modal-select"></select>
                <span>:</span>
                <select id="adjustStartMinute" class="modal-select"></select>
            </div>
        </div>

        <div id="adjustStartModeAdd">
            <div class="modal-row" style="justify-content: space-around; gap: 1rem;">
                <div id="adjustAddTimeDisplay" class="time-add-display">0t 0min</div>
                <button id="adjustTimeStepperBtn" type="button" class="btn-stepper" title="Enkeltrykk: +15 min | Dobbeltrykk: -15 min">
                    +15 min
                </button>
            </div>
            <div id="adjustStepperHelp" class="helper-text" style="text-align:center; margin-top:0.5rem;">
                Enkeltrykk = +15 min<br>Dobbeltrykk = -15 min
            </div>
        </div>

        <div class="modal-footer">
            <button id="adjustStartCancelButton" class="btn-secondary">Avbryt</button>
            <button id="adjustStartConfirmButton" class="modal-button-primary">Lagre resultat</button>
        </div>
    </div>
</div>

<div id="restoreDayOverlay" class="overlay">
    <div class="modal">
        <h2>Gjenoppta arkivert dag</h2>
        <p id="restoreDayText"></p>
        <p>Dette vil flytte hele dagens liste tilbake til «Arbeidsliste (dagens)».</p>
        <div class="modal-footer">
            <button id="restoreDayCancelButton" class="btn-secondary">Avbryt</button>
            <button id="restoreDayConfirmButton" class="modal-button-primary">Gjenoppta dagen</button>
        </div>
    </div>
</div>


<div id="adhdCommentOverlay" class="overlay">
    <div class="modal" style="max-width:700px;">
        <button class="modal-close" id="adhdCommentCloseButton">&times;</button>
        <h2>Sekvensmodus – kommentar</h2>
        <p id="adhdCommentTaskLabel" style="font-weight:600; margin-bottom:0.5rem;"></p>
        <textarea id="adhdCommentTextarea" class="modal-textarea" placeholder="Erfaringer, kommentarer, observasjoner ..."></textarea>
        <div class="modal-footer" style="margin-top:0.75rem;">
            <button id="adhdCommentCancelButton" type="button" class="btn-secondary">Avbryt</button>
            <button id="adhdCommentSaveButton" type="button" class="btn-secondary">Lagre</button>
        </div>
    </div>
</div>

<div id="adhdBreakdownOverlay" class="overlay">
    <div class="modal" style="max-width:820px;">
        <button class="modal-close" id="adhdBreakdownCloseButton">&times;</button>
        <h2>Sekvensmodus – Breakdown</h2>
        <div id="adhdBreakdownSummary" class="inline-note" style="margin-bottom:0.65rem;"></div>
        <div id="adhdBreakdownContent" style="max-height:55vh; overflow:auto; border:1px solid var(--border); border-radius:0.6rem; padding:0.5rem 0.65rem;"></div>
        <div class="modal-footer" style="margin-top:0.75rem;">
            <button id="adhdBreakdownOkButton" type="button" class="btn-secondary">OK</button>
        </div>
    </div>
</div>

<script>
    const STORAGE_KEY_PREFIX = "taskTimeTracker_data_";
    const THEME_KEY = "taskTimeTracker_theme_v1";
    const ADHD_THEME_RESTORE_KEY = "taskTimeTracker_adhd_prevTheme_v1";
    const TIMELINE_KEY_PREFIX = "taskTimeTracker_timeline_";
    const PROFILES_KEY = "taskTimeTracker_profiles_list";
    const AUTO_SAVE_KEY = "taskTimeTracker_autoSave_v1";
    const NO_HELP_TEXT_KEY = "taskTimeTracker_noHelpText_v1";
    const MIDNIGHT_DOUBLE_COUNT_GUARD_KEY = "taskTimeTracker_midnightDoubleCountGuard_v1";
    const ONENOTE_REMINDER_KEY = "taskTimeTracker_onenoteReminder_v1";
    const CONTROL_PANEL_OPEN_KEY = "taskTimeTracker_controlPanelOpen_v1";
    const UNDER_DEVELOPMENT_EXPANDED_KEY = "taskTimeTracker_underDevelopmentExpanded_v1";
    const SUGGESTIONS_HEIGHT_KEY_PREFIX = "taskTimeTracker_suggestions_height_";

    const DEMO_PROFILE_NAME = "Testprofil (3 år)";

    const Docsgoogle = "https://docs.google.com/document/d/1F1nFT4N_02xjNeQDJxTPKbGvzK9YwYhb8l9dYR565vw/edit?usp=sharing";

    let profiles = ["Standard"];
    let currentProfile = "Standard";
    let autoSaveOnEndDay = false;
    let oneNoteReminderEnabled = false;
    let oneNoteReminderCurrentTasksCopySignature = "";

    let data = {
        tasks: [],
        archives: [],
        taskNames: [],
        projectNumbers: {},
        projectDivisions: {},
        favorites: {},
        favoritesOrder: [],
        outdated: {},
        appNotes: ""
    };

    let selectedTaskId = null;
    let tempTaskSelectionTimer = null;
    let overduePopupShown = false;
    let endDayPressedAtMs = null;
    let midnightDoubleCountGuardEnabled = false;
    let overduePopupMode = "overdue10h";

let midnightGuardTempResumeSuspended = false;
let midnightGuardTempResumePrevEnabled = null;
let profileTempGuardBlinkTimer = null;
let profileTempGuardIndicatorActive = false;



    let adjustPopupMode = "normal";
    let adjustPopupTargetId = null;
    let suggestionIndex = -1;
    let filteredSuggestions = [];

    // Drag & drop ordering for favorites in suggestion list
    let dragFavKey = null;
    let dragOverFavKey = null;
    let dragInsertAfter = false;

    let isReorderingFavorites = false;

    
    let isPointerDownOnTaskSuggestion = false;
    let currentGroupId = null;
    let dragTaskKey = null;
    let suppressNextSuggestionClick = false;
    let escListenerAdded = false;

    let commentEditingTaskId = null;
    let suppressProjectDivisionOutsideCloseUntil = 0;
    let pendingRestoreArchiveId = null;

    let showAllComments = false;
    let expandedCommentTaskId = null;

    let pendingNewTaskName = null;
    let expandedProjectDivisionTaskId = null;
    let selectedProjectDivisionTarget = null;
    let timelineMode = localStorage.getItem('taskTimeTracker_timeline_mode') || 'setup';

    function getTotalWorkedMsToday(){
        return data.tasks.reduce((s,t)=>s+(t.totalMs||0),0);
    }


    const timeNowEl = document.getElementById("timeNow");
    const taskInputEl = document.getElementById("taskInput");
    const taskSuggestionsEl = document.getElementById("taskSuggestions");
    
    // Keep suggestions open while pointer is held down on a suggestion item.
    // This prevents the blur->clearSuggestions timeout from hiding the list before drag begins.
    if (taskSuggestionsEl) {
        const markPointerDown = (e) => {
            const li = e.target.closest('.task-list-item');
            if (!li) return;
            isPointerDownOnTaskSuggestion = true;
        };
        // Support both Pointer Events and classic Mouse Events (some browsers/configs only fire mouse events).
        taskSuggestionsEl.addEventListener('pointerdown', markPointerDown);
        taskSuggestionsEl.addEventListener('mousedown', markPointerDown);
    }

    const releaseTaskSuggestionPointer = () => {
        if (!isPointerDownOnTaskSuggestion) return;
        isPointerDownOnTaskSuggestion = false;
        if (!isReorderingFavorites && document.activeElement !== taskInputEl) {
            clearSuggestions();
        }
    };
    document.addEventListener('pointerup', releaseTaskSuggestionPointer);
    document.addEventListener('pointercancel', releaseTaskSuggestionPointer);
    document.addEventListener('mouseup', releaseTaskSuggestionPointer);
const startButtonEl = document.getElementById("startButton");
    const endButtonEl = document.getElementById("endButton");
    const clearButtonEl = document.getElementById("clearButton");
    const exportButtonEl = document.getElementById("exportButton");
    const clearArchivesButtonEl = document.getElementById("clearArchivesButton");
    const currentTaskLabelEl = document.getElementById("currentTaskLabel");
    const currentTaskNameEl = document.getElementById("currentTaskName");
    const currentTaskTimeEl = document.getElementById("currentTaskTime");
    const currentTaskHintEl = document.getElementById("currentTaskHint");

    const transferTimeButtonEl = document.getElementById("transferTimeButton");
    const adjustStartButtonEl = document.getElementById("adjustStartButton");

    const taskListEl = document.getElementById("taskList");
    const selectionInfoEl = document.getElementById("selectionInfo");
    const taskListHelperEl = document.getElementById("taskListHelper");
    const archiveHelperEl = document.getElementById("archiveHelper");
    const emptyListTextEl = document.getElementById("emptyListText");
    const archiveListEl = document.getElementById("archiveList");


    // --- Historikk: kollaps/utvid hele historikkseksjonen (per profil) ---
    const archiveHeaderToggleEl = document.getElementById("archiveHeaderToggle");
    const archiveContentWrapEl = document.getElementById("archiveContentWrap");
    const archiveToggleArrowEl = document.getElementById("archiveToggleArrow");

    let archiveCollapsed = false;

    function getArchiveCollapsedKey(){
        return "taskTimeTracker_archiveCollapsed_" + (currentProfile || "Standard");
    }
    function loadArchiveCollapsed(){
        const v = localStorage.getItem(getArchiveCollapsedKey());
        return v === "1";
    }
    function saveArchiveCollapsed(val){
        localStorage.setItem(getArchiveCollapsedKey(), val ? "1" : "0");
    }
    function applyArchiveCollapsedUI(){
        const collapsed = !!archiveCollapsed;
        if (archiveContentWrapEl) archiveContentWrapEl.style.display = collapsed ? "none" : "";
        if (archiveToggleArrowEl) archiveToggleArrowEl.textContent = collapsed ? "▸" : "▾";
        if (archiveHeaderToggleEl) archiveHeaderToggleEl.setAttribute("aria-expanded", collapsed ? "false" : "true");
    }
    function toggleArchiveCollapsed(){
        archiveCollapsed = !archiveCollapsed;
        saveArchiveCollapsed(archiveCollapsed);
        applyArchiveCollapsedUI();
    }

    if (archiveHeaderToggleEl) {
        archiveHeaderToggleEl.addEventListener("click", (e) => {
            e.preventDefault();
            toggleArchiveCollapsed();
        });
        archiveHeaderToggleEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                toggleArchiveCollapsed();
            }
        });
    }

    const toggleAllCommentsButtonEl = document.getElementById("toggleAllCommentsButton");
    const toggleListHeightButtonEl = document.getElementById("toggleListHeightButton");
    const toggleRoundingButtonEl = document.getElementById("toggleRoundingButton");
    
    const copyOneNoteButtonEl = document.getElementById("copyOneNoteButton");

    const resizeHandleEl = document.getElementById("resizeHandle");
    const taskListWrapperEl = document.querySelector(".task-list-wrapper");

    const projectOverlayEl = document.getElementById("projectOverlay");
    const projectCloseButtonEl = document.getElementById("projectCloseButton");
    const projectCancelButtonEl = document.getElementById("projectCancelButton");
    const projectConfirmButtonEl = document.getElementById("projectConfirmButton");
    const projectTaskNameEl = document.getElementById("projectTaskName");
    const projectNumberInputEl = document.getElementById("projectNumberInput");
    const projectTaskDivisionButtonRowEl = document.getElementById("projectTaskDivisionButtonRow");
    const projectTaskDivisionButtonEl = document.getElementById("projectTaskDivisionButton");
    const projectTaskDivisionOverlayEl = document.getElementById("projectTaskDivisionOverlay");
    const projectTaskDivisionCloseButtonEl = document.getElementById("projectTaskDivisionCloseButton");
    const projectTaskDivisionCancelButtonEl = document.getElementById("projectTaskDivisionCancelButton");
    const projectTaskDivisionOkButtonEl = document.getElementById("projectTaskDivisionOkButton");
    const projectTaskDivisionTextareaEl = document.getElementById("projectTaskDivisionTextarea");
    const projectTaskDivisionLineNumbersEl = document.getElementById("projectTaskDivisionLineNumbers");
    const projectNameEditInputEl = document.getElementById("projectNameEditInput");
    const projectNameEditRowEl = document.getElementById("projectNameEditRow");

    const projectOutdatedWrapEl = document.getElementById("projectOutdatedWrap");
    const projectOutdatedCheckboxEl = document.getElementById("projectOutdatedCheckbox");

    const projectConfirmDefaultText = projectConfirmButtonEl ? projectConfirmButtonEl.textContent : "Start";
    let projectPopupMode = "start"; // "start" | "edit"


    let projectEditOriginalName = null;
    const overdueOverlayEl = document.getElementById("overdueOverlay");
    const overdueTaskNameEl = document.getElementById("overdueTaskName");
    const overdueHourEl = document.getElementById("overdueHour");
    const overdueMinuteEl = document.getElementById("overdueMinute");
    const overdueConfirmButtonEl = document.getElementById("overdueConfirmButton");
    const overdueTitleEl = document.getElementById("overdueTitle");
    const overdueMessagePrimaryEl = document.getElementById("overdueMessagePrimary");
    const overdueMessageSecondaryEl = document.getElementById("overdueMessageSecondary");

    const clearArchivesOverlayEl = document.getElementById("clearArchivesOverlay");
    const clearArchivesDeleteButtonEl = document.getElementById("clearArchivesDeleteButton");
    const clearArchivesExportDeleteButtonEl = document.getElementById("clearArchivesExportDeleteButton");
    const clearArchivesCloseButtonEl = document.getElementById("clearArchivesCloseButton");
    const clearArchivesCancelButtonEl = document.getElementById("clearArchivesCancelButton");

    const clearTodayOverlayEl = document.getElementById("clearTodayOverlay");
    const clearTodayCancelButtonEl = document.getElementById("clearTodayCancelButton");
    const clearTodayConfirmButtonEl = document.getElementById("clearTodayConfirmButton");
    const oneNoteReminderOverlayEl = document.getElementById("oneNoteReminderOverlay");
    const oneNoteReminderCloseButtonEl = document.getElementById("oneNoteReminderCloseButton");
    const oneNoteReminderOkButtonEl = document.getElementById("oneNoteReminderOkButton");

    const commentOverlayEl = document.getElementById("commentOverlay");
    const commentCloseButtonEl = document.getElementById("commentCloseButton");
    const commentCancelButtonEl = document.getElementById("commentCancelButton");
    const commentSaveButtonEl = document.getElementById("commentSaveButton");
    const commentTextareaEl = document.getElementById("commentTextarea");
    const commentTaskNameEl = document.getElementById("commentTaskName");

    const transferOverlayEl = document.getElementById("transferOverlay");
    const transferCloseButtonEl = document.getElementById("transferCloseButton");
    const transferCancelButtonEl = document.getElementById("transferCancelButton");
    const transferConfirmButtonEl = document.getElementById("transferConfirmButton");
    const transferSourceEl = document.getElementById("transferSource");
    const transferTargetEl = document.getElementById("transferTarget");
    const transferSourceSubtaskWrapEl = document.getElementById("transferSourceSubtaskWrap");
    const transferSourceSubtaskEl = document.getElementById("transferSourceSubtask");
    const transferTargetSubtaskWrapEl = document.getElementById("transferTargetSubtaskWrap");
    const transferTargetSubtaskEl = document.getElementById("transferTargetSubtask");
    const transferHoursEl = document.getElementById("transferHours");
    const transferMinutesEl = document.getElementById("transferMinutes");
    const transferMaxHintEl = document.getElementById("transferMaxHint");

    const adjustStartOverlayEl = document.getElementById("adjustStartOverlay");
    const adjustStartCloseButtonEl = document.getElementById("adjustStartCloseButton");
    const adjustStartCancelButtonEl = document.getElementById("adjustStartCancelButton");
    const adjustStartConfirmButtonEl = document.getElementById("adjustStartConfirmButton");
    const adjustStartTitleEl = document.getElementById("adjustStartTitle");
    const adjustStartDescEl = document.getElementById("adjustStartDesc");
    const adjustStartModeTimeEl = document.getElementById("adjustStartModeTime");
    const adjustStartModeAddEl = document.getElementById("adjustStartModeAdd");
    const adjustStartHourEl = document.getElementById("adjustStartHour");
    const adjustStartMinuteEl = document.getElementById("adjustStartMinute");
    const adjustStartTargetRowEl = document.getElementById("adjustStartTargetRow");
    const adjustStartTargetEl = document.getElementById("adjustStartTarget");
    const adjustStartTargetSubtaskWrapEl = document.getElementById("adjustStartTargetSubtaskWrap");
    const adjustStartTargetSubtaskEl = document.getElementById("adjustStartTargetSubtask");
    const adjustAddTimeDisplayEl = document.getElementById("adjustAddTimeDisplay");
    const adjustTimeStepperBtnEl = document.getElementById("adjustTimeStepperBtn");

    const adjustStepperHelpEl = document.getElementById("adjustStepperHelp");
    const restoreDayOverlayEl = document.getElementById("restoreDayOverlay");
    const restoreDayTextEl = document.getElementById("restoreDayText");
    const restoreDayCancelButtonEl = document.getElementById("restoreDayCancelButton");
    const restoreDayConfirmButtonEl = document.getElementById("restoreDayConfirmButton");

    const themeToggleButtonEl = document.getElementById("themeToggleButton");

    const profileButtonEl = document.getElementById("profileButton");
    function getAdhdActiveProjectKey(){
        const active = (typeof getActiveTask === 'function') ? getActiveTask() : null;
        if (!active || active.id == null) return null;
        return String(active.id);
    }
    function getAdhdModeKey(){
        const pid = currentProfile || 'default';
        const projectKey = getAdhdActiveProjectKey();
        return `taskTimeTracker_cp_adhd_mode_${pid}_${projectKey || 'none'}`;
    }
    function getAdhdModeArmKey(){
        const pid = currentProfile || 'default';
        const projectKey = getAdhdActiveProjectKey();
        return `taskTimeTracker_cp_adhd_mode_arm_${pid}_${projectKey || 'none'}`;
    }
    function getAdhdTasksKey(){
        const pid = currentProfile || 'default';
        const projectKey = getAdhdActiveProjectKey();
        return `taskTimeTracker_adhd_tasks_${pid}_${projectKey || 'none'}`;
    }

    const adhdStripWrapEl = document.getElementById("adhdStripWrap");
    const adhdStripEl = document.getElementById("adhdStrip");
    const adhdStripLineEl = document.querySelector('#adhdStrip .adhd-strip-line');
    const adhdCurrentTaskEl = document.getElementById("adhdCurrentTask");
    const adhdCurrentTaskTextEl = document.getElementById("adhdCurrentTaskText");
    const adhdCurrentTaskEmptyEl = document.getElementById("adhdCurrentTaskEmpty");
    const adhdCurrentTaskCheckEl = document.getElementById("adhdCurrentTaskCheck");
    const adhdSummaryPillEl = document.getElementById("adhdSummaryPill");
    const adhdTasksOverlayEl = document.getElementById("adhdTasksOverlay");
    const adhdTasksCloseButtonEl = document.getElementById("adhdTasksCloseButton");
    const adhdTasksCancelButtonEl = document.getElementById("adhdTasksCancelButton");
    const adhdTasksOkButtonEl = document.getElementById("adhdTasksOkButton");
    const adhdTasksTextareaEl = document.getElementById("adhdTasksTextarea");
    const adhdLineNumbersEl = document.getElementById("adhdLineNumbers");
    const cpAdhdModeEl = document.getElementById("cpToggle3");
    const cpAdhdModeLabelEl = document.getElementById("cpToggle3Label");
    const adhdCommentOverlayEl = document.getElementById("adhdCommentOverlay");
    const adhdCommentCloseButtonEl = document.getElementById("adhdCommentCloseButton");
    const adhdCommentCancelButtonEl = document.getElementById("adhdCommentCancelButton");
    const adhdCommentSaveButtonEl = document.getElementById("adhdCommentSaveButton");
    const adhdCommentTextareaEl = document.getElementById("adhdCommentTextarea");
    const adhdCommentTaskLabelEl = document.getElementById("adhdCommentTaskLabel");
    const adhdBreakdownOverlayEl = document.getElementById("adhdBreakdownOverlay");
    const adhdBreakdownCloseButtonEl = document.getElementById("adhdBreakdownCloseButton");
    const adhdBreakdownOkButtonEl = document.getElementById("adhdBreakdownOkButton");
    const adhdBreakdownSummaryEl = document.getElementById("adhdBreakdownSummary");
    const adhdBreakdownContentEl = document.getElementById("adhdBreakdownContent");
    const adhdDiscardOverlayEl = document.getElementById("adhdDiscardOverlay");
    const adhdDiscardMessageEl = document.getElementById("adhdDiscardMessage");
    const adhdDiscardCancelButtonEl = document.getElementById("adhdDiscardCancelButton");
    const adhdDiscardConfirmButtonEl = document.getElementById("adhdDiscardConfirmButton");
    const underDevelopmentVisibilityButtonEl = document.getElementById("underDevelopmentVisibilityButton");
    const underDevelopmentItemsEl = document.getElementById("underDevelopmentItems");
    let underDevelopmentExpanded = false;
    const cpPersonalCustomizationToggleEl = document.getElementById("cpPersonalCustomizationToggle");
    const personalCustomizeActionWrapEl = document.getElementById("personalCustomizeActionWrap");
    const openPersonalCustomizeButtonEl = document.getElementById("openPersonalCustomizeButton");
    const toggleFrutigerMusicPlayerButtonEl = document.getElementById("toggleFrutigerMusicPlayerButton");
    const frutigerMusicPlayerWrapEl = document.getElementById("frutigerMusicPlayerWrap");
    const frutigerMusicStatusEl = document.getElementById("frutigerMusicStatus");
    const frutigerMusicTrackNameEl = document.getElementById("frutigerMusicTrackName");
    const frutigerMusicAudioEl = document.getElementById("frutigerMusicAudio");
    const frutigerMusicStartStopButtonEl = document.getElementById("frutigerMusicStartStopButton");
    const frutigerMusicPauseButtonEl = document.getElementById("frutigerMusicPauseButton");
    const frutigerMusicPrevButtonEl = document.getElementById("frutigerMusicPrevButton");
    const frutigerMusicNextButtonEl = document.getElementById("frutigerMusicNextButton");
    const personalCustomizeOverlayEl = document.getElementById("personalCustomizeOverlay");
    const personalCustomizeCloseButtonEl = document.getElementById("personalCustomizeCloseButton");
    const personalCustomizeRowsEl = document.getElementById("personalCustomizeRows");
    const personalCustomizeCancelButtonEl = document.getElementById("personalCustomizeCancelButton");
    const personalCustomizeResetButtonEl = document.getElementById("personalCustomizeResetButton");
    const personalCustomizeOkButtonEl = document.getElementById("personalCustomizeOkButton");
    const personalBgCustomizeButtonEl = document.getElementById("personalBgCustomizeButton");
    const personalRenameControlsToggleButtonEl = document.getElementById("personalRenameControlsToggleButton");
    const personalRenameControlsWrapEl = document.getElementById("personalRenameControlsWrap");
    const personalBgControlsWrapEl = document.getElementById("personalBgControlsWrap");
    const personalBgColorButtonEl = document.getElementById("personalBgColorButton");
    const personalBgMediaButtonEl = document.getElementById("personalBgMediaButton");
    const personalBgMediaHistoryButtonEl = document.getElementById("personalBgMediaHistoryButton");
    const personalBgGlassButtonEl = document.getElementById("personalBgGlassButton");
    const personalBgTextColorButtonEl = document.getElementById("personalBgTextColorButton");
    const personalFruitigerArchiveButtonEl = document.getElementById("personalFruitigerArchiveButton");
    const personalBgMediaInputEl = document.getElementById("personalBgMediaInput");
    const personalBgColorControlsEl = document.getElementById("personalBgColorControls");
    const personalBgTextColorControlsEl = document.getElementById("personalBgTextColorControls");
    const personalBgGlassControlsEl = document.getElementById("personalBgGlassControls");
    const personalBgHueRangeEl = document.getElementById("personalBgHueRange");
    const personalBgSatRangeEl = document.getElementById("personalBgSatRange");
    const personalBgLightRangeEl = document.getElementById("personalBgLightRange");
    const personalBgHueValueEl = document.getElementById("personalBgHueValue");
    const personalBgSatValueEl = document.getElementById("personalBgSatValue");
    const personalBgLightValueEl = document.getElementById("personalBgLightValue");
    const personalBgGlassOpacityRangeEl = document.getElementById("personalBgGlassOpacityRange");
    const personalBgGlassOpacityValueEl = document.getElementById("personalBgGlassOpacityValue");
    const personalBgBlurOffButtonEl = document.getElementById("personalBgBlurOffButton");
    const personalBgBlurFastButtonEl = document.getElementById("personalBgBlurFastButton");
    const personalBgBlurPrettyButtonEl = document.getElementById("personalBgBlurPrettyButton");
    const personalBgBlurHeavyButtonEl = document.getElementById("personalBgBlurHeavyButton");
    const personalBgPreviewChipEl = document.getElementById("personalBgPreviewChip");
    const personalTextHueRangeEl = document.getElementById("personalTextHueRange");
    const personalTextSatRangeEl = document.getElementById("personalTextSatRange");
    const personalTextLightRangeEl = document.getElementById("personalTextLightRange");
    const personalTextHueValueEl = document.getElementById("personalTextHueValue");
    const personalTextSatValueEl = document.getElementById("personalTextSatValue");
    const personalTextLightValueEl = document.getElementById("personalTextLightValue");
    const personalTextPreviewChipEl = document.getElementById("personalTextPreviewChip");
    const personalBgMediaStatusEl = document.getElementById("personalBgMediaStatus");
    const personalBgAutoSwapWrapEl = document.getElementById("personalBgAutoSwapWrap");
    const personalFruitigerArchivePanelEl = document.getElementById("personalFruitigerArchivePanel");
    const personalFruitigerArchiveStatusEl = document.getElementById("personalFruitigerArchiveStatus");
    const personalFruitigerArchiveListEl = document.getElementById("personalFruitigerArchiveList");
    const personalFruitigerArchiveIntervalRangeEl = document.getElementById("personalFruitigerArchiveIntervalRange");
    const personalFruitigerArchiveIntervalValueEl = document.getElementById("personalFruitigerArchiveIntervalValue");
    const personalFruitigerArchiveModeToggleEl = document.getElementById("personalFruitigerArchiveModeToggle");
    const personalBgMediaHistoryDropdownEl = document.getElementById("personalBgMediaHistoryDropdown");
    const customPageBackgroundLayerEl = document.getElementById("customPageBackgroundLayer");
    const customPageBgFillEl = document.getElementById("customPageBgFill");
    const customPageBgImageEl = document.getElementById("customPageBgImage");
    const customPageBgVideoEl = document.getElementById("customPageBgVideo");
    let reopenSettingsAfterPersonalCustomizeClose = false;

    let adhdModeEnabled = false;
    let adhdModeArmed = false;
    let adhdTasksState = { items: [], comments: [], completed: [], activeIndex: 0, startedAt: null, completedAt: [], breakdownShown: false };
    let adhdAnimatingCompletion = false;
    let adhdActiveCommentIndex = -1;
    let adhdBoundProjectKey = null;
    let adhdChartHoldTimer = null;
    let adhdChartHoldTriggered = false;
    let adhdThemeRestoreMode = null;
    let adhdMergedChartHostEl = null;

    const settingsOverlayEl = document.getElementById("settingsOverlay");
    const settingsCloseButtonEl = document.getElementById("settingsCloseButton");
    const settingsDoneButtonEl = document.getElementById("settingsDoneButton");
    const controlPanelToggleEl = document.getElementById("controlPanelToggle");
    const controlPanelButtonsEl = document.getElementById("controlPanelButtons");

    function moveUnderDevelopmentOutOfControlPanelButtons(){
        const cpButtons = controlPanelButtonsEl;
        if (!cpButtons || !cpButtons.parentNode) return;
        const underDev = cpButtons.querySelector('.control-panel-under-dev');
        if (!underDev) return;
        // Flytt seksjonen ut slik at den ikke skjules når "Tilleggsfunksjoner" er lukket
        cpButtons.parentNode.insertBefore(underDev, cpButtons.nextSibling);
    }

    const controlPanelToggleLabelEl = document.getElementById("controlPanelToggleLabel") || document.querySelector('label[for="controlPanelToggle"]');

    const profileSelectEl = document.getElementById("profileSelect");
    const createProfileButtonEl = document.getElementById("createProfileButton");
    const deleteProfileButtonEl = document.getElementById("deleteProfileButton");
    const profileHelperTextEl = document.getElementById("profileHelperText");
    const downloadBackupButtonEl = document.getElementById("downloadBackupButton");
    const uploadBackupButtonEl = document.getElementById("uploadBackupButton");
    const backupFileInputEl = document.getElementById("backupFileInput");
    const autoSaveToggleEl = document.getElementById("autoSaveToggle");
    const newProfileNameEl = document.getElementById("newProfileName");
    const cpGenerateTestDataEl = document.getElementById("cpGenerateTestData");
    const cpNoHelpTextEl = document.getElementById("cpToggle1");
    const cpProjectDivisionToggleEl = document.getElementById("cpProjectDivisionToggle");
    const cpOneNoteReminderToggleEl = document.getElementById("cpOneNoteReminderToggle");
    const PROJECT_DIVISION_TOGGLE_KEY = "taskTimeTracker_projectDivisionToggle";
    const PERSONAL_CUSTOMIZATION_TOGGLE_KEY = "taskTimeTracker_personalCustomizationToggle";
    const PERSONAL_CUSTOMIZATION_VALUES_KEY = "taskTimeTracker_personalCustomizationValues_v1";
    const cpMidnightGuardEl = document.getElementById("cpToggle2");
    let projectDivisionEnabled = false;

    const deleteProfileOverlayEl = document.getElementById("deleteProfileOverlay");

    const deleteTaskOverlayEl = document.getElementById("deleteTaskOverlay");
    const deleteTaskNameDisplayEl = document.getElementById("deleteTaskNameDisplay");
    const deleteTaskConfirmBtnEl = document.getElementById("deleteTaskConfirmBtn");
    const deleteTaskCancelBtnEl = document.getElementById("deleteTaskCancelBtn");
    let pendingDeleteTaskName = null;

    function showDeleteTaskPopup(taskName){
        pendingDeleteTaskName = (taskName || "").trim();
        if (!pendingDeleteTaskName || !deleteTaskOverlayEl) return;
        if (deleteTaskNameDisplayEl) deleteTaskNameDisplayEl.textContent = pendingDeleteTaskName;
        deleteTaskOverlayEl.classList.add("show");
        setTimeout(() => { deleteTaskConfirmBtnEl && deleteTaskConfirmBtnEl.focus(); }, 0);
    }

    function hideDeleteTaskPopup(){
        pendingDeleteTaskName = null;
        if (deleteTaskOverlayEl) deleteTaskOverlayEl.classList.remove("show");
    }
    const deleteProfileNameDisplayEl = document.getElementById("deleteProfileNameDisplay");
    const deleteProfileCancelBtnEl = document.getElementById("deleteProfileCancelBtn");
    const deleteProfileSaveDeleteBtnEl = document.getElementById("deleteProfileSaveDeleteBtn");
    const deleteProfileConfirmBtnEl = document.getElementById("deleteProfileConfirmBtn");

    const chartCanvas = document.getElementById("taskChart");
    const chartCtx = chartCanvas ? chartCanvas.getContext("2d") : null;
    const chartLegendEl = document.getElementById("chartLegend");
    const chartGifOverlayEl = document.getElementById("taskChartGifOverlay");
    const chartWrapperEl = chartCanvas ? chartCanvas.closest('.chart-wrapper') : null;
    const chartCardEl = chartWrapperEl ? chartWrapperEl.closest('section.card') : null;
    const chartOriginalParentEl = chartWrapperEl ? chartWrapperEl.parentElement : null;

    const timelineCardTitleEl = document.getElementById("timelineCardTitle");


    const PERSONAL_CUSTOMIZATION_FIELD_DEFS = [
        { key: 'appTitle', selector: '#appTitleText', label: 'BIMføring tidsregistrering' },
        { key: 'timelineTitle', selector: '#timelineCardTitle', label: 'Tidslinje' },
        { key: 'chartTitle', selector: '#chartCardTitle', label: 'Fordeling av prosjekter (tid)' },
        { key: 'projectTitle', selector: '#projectCardTitle', label: 'Prosjekt' },
        { key: 'currentProjectLabel', selector: '#currentTaskLabel', label: 'Nåværende prosjekt' },
        { key: 'workListTitle', selector: '#taskListCardTitle', label: 'Arbeidsliste (dagens)' },
        { key: 'historyTitle', selector: '#archiveCardTitle', label: 'Historikk' },
        { key: 'settingsTitle', selector: '#settingsModalTitle', label: 'Profil og Innstillinger' },
        { key: 'settingsProfilesTitle', selector: '#settingsProfilesTitle', label: 'Profiler' },
        { key: 'settingsExtrasTitle', selector: '#settingsExtrasTitle', label: 'Tilleggsfunksjoner' },
        { key: 'settingsUnderDevTitle', selector: '#underDevelopmentSectionTitle', label: 'Utviklerverktøy og betafunksjoner' },
        { key: 'notesModalTitle', selector: '#appNotesModalTitle', label: 'Notater' }
    ];
    let personalCustomizationValues = {};
    let personalCustomizationDefaultLabels = {};
    let personalCustomizeBackgroundDraft = null;
    let personalCustomizeBackgroundSavedSnapshot = null;
    let personalBgControlsOpen = false;
    let personalRenameControlsOpen = false;
    let personalBgColorControlsOpen = false;
    let personalBgGlassControlsOpen = false;
    let personalBgGlassControlsOpenInitialized = false;
    let personalBgTextColorControlsOpen = false;
    let personalBgMediaHistoryOpen = false;
    let personalBgMediaHoldTimer = null;
    let personalBgMediaHoldTriggered = false;
    let personalFruitigerArchiveOpen = false;
    let personalFruitigerArchiveLoading = false;
    let personalFruitigerArchiveCategories = [];
    let personalFruitigerArchiveDocsCache = new Map();
    let personalFruitigerArchiveAutoTimer = null;
    let personalFruitigerArchiveAutoRunning = false;
    let personalFruitigerArchiveAutoBusy = false;
    let personalFruitigerArchiveAutoRunToken = 0;
    let personalFruitigerArchiveAutoIntervalSec = 45;
    let personalFruitigerArchiveRandomCategoryMode = false;
    let personalFruitigerArchiveHistoryMode = false;
    let personalBgHistoryAutoIndex = 0;
    let personalBgHistoryAutoLastDataUrl = '';
    let personalFruitigerArchiveSelectedCategoryHref = "";
    let personalFruitigerArchiveLastImageUrl = "";
    const PERSONAL_BG_MEDIA_DB_NAME = 'bimforingPersonalBgMedia';
    const PERSONAL_BG_MEDIA_DB_VERSION = 1;
    const PERSONAL_BG_MEDIA_STORE = 'media';
    let personalBgMediaDbPromise = null;
    let personalBgMediaHydrationToken = 0;
    let personalBgVisualApplyToken = 0;

    let frutigerMusicPlayerVisible = false;
    let frutigerMusicLoading = false;
    let frutigerMusicPlaylist = [];
    let frutigerMusicCurrentIndex = -1;
    let frutigerMusicPageCache = new Map();
    let frutigerMusicLastError = '';
    let frutigerMusicArchiveOrgMetaCache = new Map();
    let frutigerMusicCurrentPlaybackCandidates = [];
    let frutigerMusicCurrentPlaybackCandidateIndex = 0;
    let personalCtrlLightHoldActive = false;
    let personalCtrlLightRestoreThemeMode = null;
    const timelineWrapEl = document.getElementById("timelineWrap");
    const adhdTimelineHostEl = document.getElementById("adhdTimelineHost");
    const dayTimelineBarEl = document.getElementById("dayTimelineBar");
    const dayTimelineTicksEl = document.getElementById("dayTimelineTicks");

    const timelineNowDotEl = document.getElementById("timelineNowDot");

    const dayTimelineCurtainEl = document.getElementById("dayTimelineCurtain");
    const dayTimelineCurtainTitleEl = document.getElementById("dayTimelineCurtainTitle");
    const dayTimelineCurtainCloseEl = document.getElementById("dayTimelineCurtainClose");
    const dayTimelineResetButtonEl = document.getElementById("dayTimelineResetButton");

    if (dayTimelineResetButtonEl) {
        dayTimelineResetButtonEl.addEventListener("click", async () => {
            dayTimelineSettings = {
                dayStartMin: 7 * 60,
                dayEndMin: 17 * 60,
                coreStartMin: 9 * 60,
                coreEndMin: 15 * 60,
                lunchStartMin: 11 * 60 + 30,
                lunchEndMin: 12 * 60
            };
            localStorage.removeItem(getTimelineKey());
            renderDayTimeline();
        });
    }

    const dayTimelineFromLabelEl = document.getElementById("dayTimelineFromLabel");
    const dayTimelineToLabelEl = document.getElementById("dayTimelineToLabel");
    const dayTimelineFromEl = document.getElementById("dayTimelineFrom");
    const dayTimelineToEl = document.getElementById("dayTimelineTo");
    const dayTimelineCurtainHintEl = document.getElementById("dayTimelineCurtainHint");

    let dayTimelineSettings = {
        dayStartMin: 7 * 60,
        dayEndMin: 17 * 60,
        coreStartMin: 9 * 60,
        coreEndMin: 15 * 60,
        lunchStartMin: 11 * 60 + 30,
        lunchEndMin: 12 * 60
    };

    let dayTimelineEditing = null; 
    let dayTimelineBlockChange = false;
    let dayTimelineLunchAwaitingFromSelection = false;
    let isTaskListExpanded = false;
    let isRoundingEnabled = false;
    let selectedArchiveForCopy = null;
    let copyOverrideTasks = null;
    let copySourceTasks = null;

    function getCurrentThemeMode(){
        if (document.body.classList.contains("theme-black")) return "black";
        if (document.body.classList.contains("theme-dark")) return "dark";
        return "light";
    }

    function applyThemeMode(mode, opts = {}) {
        const persist = opts.persist !== false;
        document.body.classList.remove("theme-dark", "theme-black");
        if (mode === "black") {
            document.body.classList.add("theme-dark");
            document.body.classList.add("theme-black");
        } else if (mode === "dark") {
            document.body.classList.add("theme-dark");
        }
        if (persist) saveTheme(mode || "light");
    }

    function loadTheme() {
        const t = localStorage.getItem(THEME_KEY);
        applyThemeMode(t || "light", { persist: false });
    }

    function saveTheme(mode) {
        localStorage.setItem(THEME_KEY, mode);
    }

    function syncThemeButtonMediaPulse(hasMediaBg){
        if (!themeToggleButtonEl) return;
        themeToggleButtonEl.classList.toggle('media-amoled-pulse', !!hasMediaBg);
    }

    function enforceAmoledThemeForMediaBackground(hasMediaBg){
        // Mediebakgrunn skal ikke lenger tvinge mørk modus.
        // Behold kun visuell indikator på knapp dersom det brukes bilde/video.
        syncThemeButtonMediaPulse(!!hasMediaBg);
    }

    function rememberThemeBeforeAdhd(){
        if (adhdThemeRestoreMode) return;
        try {
            const stored = localStorage.getItem(ADHD_THEME_RESTORE_KEY);
            if (stored === "light" || stored === "dark" || stored === "black") {
                adhdThemeRestoreMode = stored;
                return;
            }
        } catch(e){}
        adhdThemeRestoreMode = getCurrentThemeMode();
        try { localStorage.setItem(ADHD_THEME_RESTORE_KEY, adhdThemeRestoreMode); } catch(e){}
    }

    function clearRememberedAdhdTheme(){
        adhdThemeRestoreMode = null;
        try { localStorage.removeItem(ADHD_THEME_RESTORE_KEY); } catch(e){}
    }

    function restoreThemeAfterAdhd(){
        let mode = adhdThemeRestoreMode;
        if (!mode) {
            try { mode = localStorage.getItem(ADHD_THEME_RESTORE_KEY); } catch(e) { mode = null; }
        }
        if (mode !== "light" && mode !== "dark" && mode !== "black") {
            clearRememberedAdhdTheme();
            return;
        }
        applyThemeMode(mode);
        clearRememberedAdhdTheme();
        drawTaskChart();
        renderDayTimeline();
        updateTimelineNowDot();
    }

    function saveTimelineMode(mode) {
        timelineMode = mode;
        localStorage.setItem('taskTimeTracker_timeline_mode', mode);
    }

    function normalizeTaskName(name) {
        return (name || "").trim().replace(/\s+/g, " ").toLowerCase();
    }

    function loadProfiles() {
        const raw = localStorage.getItem(PROFILES_KEY);
        if (raw) {
            try {
                const p = JSON.parse(raw);
                if (Array.isArray(p) && p.length > 0) profiles = p;
            } catch (e) {}
        }
        if (!profiles.includes("Standard")) profiles.unshift("Standard");
        
        const lastActive = localStorage.getItem("taskTimeTracker_active_profile");
        if (lastActive && profiles.includes(lastActive)) {
            currentProfile = lastActive;
        } else {
            currentProfile = profiles[0];
        }
    }

    function saveProfiles() {
        localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles));
        localStorage.setItem("taskTimeTracker_active_profile", currentProfile);
    }

    function getStorageKey() { return STORAGE_KEY_PREFIX + currentProfile; }
    function getTimelineKey() { return TIMELINE_KEY_PREFIX + currentProfile; }

function getSuggestionsHeightKey() { return SUGGESTIONS_HEIGHT_KEY_PREFIX + currentProfile; }
function getProfileScopedSettingKey(baseKey) { return `${baseKey}__${currentProfile || 'Standard'}`; }
function getProfileScopedSetting(baseKey, { fallbackToGlobal = true } = {}) {
    let val = null;
    try { val = localStorage.getItem(getProfileScopedSettingKey(baseKey)); } catch(e) { val = null; }
    if (val === null && fallbackToGlobal) {
        try { val = localStorage.getItem(baseKey); } catch(e) { val = null; }
    }
    return val;
}
function setProfileScopedSetting(baseKey, value) {
    try { localStorage.setItem(getProfileScopedSettingKey(baseKey), String(value)); } catch(e){}
}

function getProfileScopedSettingKeyForProfile(baseKey, profileName) {
    return `${baseKey}__${profileName || 'Standard'}`;
}

function getProfileScopedSettingForProfile(baseKey, profileName, { fallbackToGlobal = true } = {}) {
    let val = null;
    try { val = localStorage.getItem(getProfileScopedSettingKeyForProfile(baseKey, profileName)); } catch(e) { val = null; }
    if (val === null && fallbackToGlobal) {
        try { val = localStorage.getItem(baseKey); } catch(e) { val = null; }
    }
    return val;
}

function enforceStandardProfileDefaultPanelSettings(){
    // Ønskede standardvalg når Standard-profilen er aktiv (eller etter sletting av profil):
    // - Hindre dobbeltelling: PÅ
    // - Lagre profil automatisk: PÅ
    // - Sekvensmodus: AV
    // - Personlig tilpasning: AV
    if ((currentProfile || 'Standard') !== 'Standard') return;

    try { localStorage.setItem(getProfileScopedSettingKeyForProfile(AUTO_SAVE_KEY, 'Standard'), 'true'); } catch(e){}
    try { localStorage.setItem(getProfileScopedSettingKeyForProfile(MIDNIGHT_DOUBLE_COUNT_GUARD_KEY, 'Standard'), 'true'); } catch(e){}
    try { localStorage.setItem(getProfileScopedSettingKeyForProfile(PROJECT_DIVISION_TOGGLE_KEY, 'Standard'), 'false'); } catch(e){}
    try { localStorage.setItem(getProfileScopedSettingKeyForProfile(ONENOTE_REMINDER_KEY, 'Standard'), 'false'); } catch(e){}
    try { localStorage.setItem(getProfileScopedSettingKeyForProfile(PERSONAL_CUSTOMIZATION_TOGGLE_KEY, 'Standard'), 'false'); } catch(e){}

    // Nullstill ADHD arm/aktiv per prosjekt for Standard-profilen (beholder evt. oppgavelister, men slår av modusen).
    try {
        const modePrefix = 'taskTimeTracker_cp_adhd_mode_Standard_';
        const armPrefix = 'taskTimeTracker_cp_adhd_mode_arm_Standard_';
        for (let i = localStorage.length - 1; i >= 0; i--) {
            const k = localStorage.key(i);
            if (!k) continue;
            if (k.startsWith(modePrefix) || k.startsWith(armPrefix)) localStorage.removeItem(k);
        }
    } catch(e){}
}


function collectProfileSettingsForExport(profileName = currentProfile) {
    const pid = profileName || 'Standard';
    const settings = {
        autoSave: getProfileScopedSettingForProfile(AUTO_SAVE_KEY, pid),
        noHelpText: getProfileScopedSettingForProfile(NO_HELP_TEXT_KEY, pid),
        midnightDoubleCountGuard: getProfileScopedSettingForProfile(MIDNIGHT_DOUBLE_COUNT_GUARD_KEY, pid),
        projectDivisionToggle: getProfileScopedSettingForProfile(PROJECT_DIVISION_TOGGLE_KEY, pid),
        oneNoteReminder: getProfileScopedSettingForProfile(ONENOTE_REMINDER_KEY, pid),
        controlPanelOpen: getProfileScopedSettingForProfile(CONTROL_PANEL_OPEN_KEY, pid, { fallbackToGlobal: false }),
        underDevelopmentExpanded: getProfileScopedSettingForProfile(UNDER_DEVELOPMENT_EXPANDED_KEY, pid, { fallbackToGlobal: false }),
        personalCustomizationToggle: getProfileScopedSettingForProfile(PERSONAL_CUSTOMIZATION_TOGGLE_KEY, pid),
        personalCustomizationValues: null
    };

    try {
        settings.personalCustomizationValues = localStorage.getItem(getProfileScopedSettingKeyForProfile(PERSONAL_CUSTOMIZATION_VALUES_KEY, pid));
    } catch(e) {
        settings.personalCustomizationValues = null;
    }

    return settings;
}

function applyImportedProfileSettings(profileName, settings) {
    if (!settings || typeof settings !== 'object') return;
    const pid = profileName || currentProfile || 'Standard';
    const pairs = [
        ['autoSave', AUTO_SAVE_KEY],
        ['noHelpText', NO_HELP_TEXT_KEY],
        ['midnightDoubleCountGuard', MIDNIGHT_DOUBLE_COUNT_GUARD_KEY],
        ['projectDivisionToggle', PROJECT_DIVISION_TOGGLE_KEY],
        ['oneNoteReminder', ONENOTE_REMINDER_KEY],
        ['controlPanelOpen', CONTROL_PANEL_OPEN_KEY],
        ['underDevelopmentExpanded', UNDER_DEVELOPMENT_EXPANDED_KEY],
        ['personalCustomizationToggle', PERSONAL_CUSTOMIZATION_TOGGLE_KEY]
    ];

    pairs.forEach(([prop, key]) => {
        if (typeof settings[prop] === 'string') {
            try { localStorage.setItem(getProfileScopedSettingKeyForProfile(key, pid), settings[prop]); } catch(e){}
        }
    });

    if (typeof settings.personalCustomizationValues === 'string') {
        try { localStorage.setItem(getProfileScopedSettingKeyForProfile(PERSONAL_CUSTOMIZATION_VALUES_KEY, pid), settings.personalCustomizationValues); } catch(e){}
    } else if (settings.personalCustomizationValues && typeof settings.personalCustomizationValues === 'object') {
        try { localStorage.setItem(getProfileScopedSettingKeyForProfile(PERSONAL_CUSTOMIZATION_VALUES_KEY, pid), JSON.stringify(settings.personalCustomizationValues)); } catch(e){}
    }
}

function collectAdhdProfileLocalStateForExport(profileName = currentProfile) {
    const pid = profileName || 'Standard';
    const prefixes = [
        `taskTimeTracker_cp_adhd_mode_${pid}_`,
        `taskTimeTracker_cp_adhd_mode_arm_${pid}_`,
        `taskTimeTracker_adhd_tasks_${pid}_`
    ];
    const out = {};
    try {
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!key) continue;
            if (!prefixes.some(prefix => key.startsWith(prefix))) continue;
            out[key] = localStorage.getItem(key);
        }
    } catch(e){}
    return out;
}

function applyImportedAdhdProfileLocalState(raw) {
    if (!raw || typeof raw !== 'object') return;
    try {
        Object.entries(raw).forEach(([k, v]) => {
            if (typeof k !== 'string' || typeof v !== 'string') return;
            localStorage.setItem(k, v);
        });
    } catch(e){}
}

function applyStoredSuggestionsHeight() {
    if (!taskSuggestionsEl) return;
    const raw = localStorage.getItem(getSuggestionsHeightKey());
    const px = raw ? parseInt(raw, 10) : NaN;
    if (!isNaN(px) && px >= 80 && px <= 1200) {
        taskSuggestionsEl.style.setProperty('--suggestions-height', px + "px");
    } else {
        taskSuggestionsEl.style.removeProperty('--suggestions-height');
    }
}

function initSuggestionsResizePersistence() {
    if (!taskSuggestionsEl || typeof ResizeObserver === "undefined") return;

    let saveTimer = null;
    const ro = new ResizeObserver((entries) => {
        const entry = entries && entries[0];
        if (!entry) return;

        // Ignore when hidden (display:none -> height 0)
        if (taskSuggestionsEl.style.display === "none") return;

        const h = Math.round(entry.contentRect.height);
        if (h < 80) return;

        if (saveTimer) clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
            localStorage.setItem(getSuggestionsHeightKey(), String(h));
        }, 150);
    });
    ro.observe(taskSuggestionsEl);
}

    function updateProfileButton() {
        if (!profileButtonEl) return;
        profileButtonEl.style.backgroundColor = "";
        profileButtonEl.style.color = "";
        profileButtonEl.style.borderColor = "";

        if (currentProfile === "Standard") {
            profileButtonEl.textContent = "Profil og innstillinger";
            profileButtonEl.classList.remove("btn-profile-active");
        } else {
            profileButtonEl.textContent = currentProfile;
            profileButtonEl.classList.add("btn-profile-active");
        }

        applyMidnightGuardTemporaryVisualState();
    }

    function loadFromStorage() {
        const key = getStorageKey();
        const raw = localStorage.getItem(key);
        
        data = { tasks: [], archives: [], taskNames: [], projectNumbers: {}, projectDivisions: {}, favorites: {}, favoritesOrder: [], outdated: {}, appNotes: "" };

        if (raw) {
            try {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === "object") {
                    data.tasks = Array.isArray(parsed.tasks) ? parsed.tasks : [];
                    data.archives = Array.isArray(parsed.archives) ? parsed.archives : [];
                    data.taskNames = Array.isArray(parsed.taskNames) ? parsed.taskNames : [];
                    data.projectNumbers = (parsed.projectNumbers && typeof parsed.projectNumbers === "object") ? parsed.projectNumbers : {};
                    data.projectDivisions = (parsed.projectDivisions && typeof parsed.projectDivisions === "object") ? parsed.projectDivisions : {};
                    data.favorites = (parsed.favorites && typeof parsed.favorites === "object") ? parsed.favorites : {};
                    data.favoritesOrder = Array.isArray(parsed.favoritesOrder) ? parsed.favoritesOrder.filter(x => typeof x === "string") : [];

                    data.outdated = (parsed.outdated && typeof parsed.outdated === "object") ? parsed.outdated : {};

                    data.appNotes = (typeof parsed.appNotes === "string") ? parsed.appNotes : "";


                    data.tasks.forEach(t => {
                        if (!t) return;
                        if (typeof t.comment !== "string") t.comment = "";
                        if (typeof t.startAdjusted !== "boolean") t.startAdjusted = false;
                        if (typeof t.projectNumber !== "string") t.projectNumber = "";
                    });
                    data.archives.forEach(a => {
                        if (!a || !Array.isArray(a.tasks)) return;
                        a.tasks.forEach(t => {
                            if (!t) return;
                            if (typeof t.comment !== "string") t.comment = "";
                            if (typeof t.projectNumber !== "string") t.projectNumber = "";
                        });
                    });


                    // Normalize outdated mapping (backward compatibility)
                    if (!data.outdated || typeof data.outdated !== "object") data.outdated = {};
                    Object.keys(data.outdated).forEach(k => {
                        const v = data.outdated[k];
                        if (v === true) data.outdated[k] = { manual: true };
                        else if (v === false) data.outdated[k] = { manual: false };
                        else if (!v || typeof v !== "object") delete data.outdated[k];
                        else if (typeof v.manual !== "boolean") v.manual = false;
                    });

                    if (!parsed.projectNumbers || typeof parsed.projectNumbers !== "object") {
                        data.projectNumbers = {};
                        const ingest = (name, pn) => {
                            const key = normalizeTaskName(name);
                            const val = (pn || "").trim();
                            if (key && val) data.projectNumbers[key] = val;
                        };
                        data.tasks.forEach(t => ingest(t.name, t.projectNumber));
                        data.archives.forEach(a => (a.tasks || []).forEach(t => ingest(t.name, t.projectNumber)));
                    }
                    if (!parsed.projectDivisions || typeof parsed.projectDivisions !== "object") {
                        data.projectDivisions = {};
                    }

                    if (!parsed.taskNames) {
                        const nameSet = new Set();
                        data.tasks.forEach(t => { if (t && t.name) nameSet.add(t.name); });
                        data.archives.forEach(a => {
                            if (a && Array.isArray(a.tasks)) a.tasks.forEach(t => { if (t && t.name) nameSet.add(t.name); });
                        });
                        data.taskNames = Array.from(nameSet);
                    }
                }
            } catch (e) {}
        }
    
        archiveCollapsed = loadArchiveCollapsed();
        applyArchiveCollapsedUI();
        if (typeof loadAdhdTasksState === "function") loadAdhdTasksState();
}

    function saveToStorage() {
        const key = getStorageKey();
        try {
            localStorage.setItem(key, JSON.stringify(data));
            return true;
        } catch (e) {
            console.warn('Kunne ikke lagre arbeidsdata i localStorage.', e);
            return false;
        }
    }

    function loadAutoSaveSetting() {
        const val = getProfileScopedSetting(AUTO_SAVE_KEY);
        autoSaveOnEndDay = (val === null) ? true : (val === "true");
        if (autoSaveToggleEl) autoSaveToggleEl.checked = autoSaveOnEndDay;
    }


    function loadMidnightDoubleCountGuardSetting() {
        const val = getProfileScopedSetting(MIDNIGHT_DOUBLE_COUNT_GUARD_KEY);
        midnightDoubleCountGuardEnabled = (val === null) ? true : (val === "true");
        if (cpMidnightGuardEl) cpMidnightGuardEl.checked = midnightDoubleCountGuardEnabled;
    }

    function loadProjectDivisionToggleSetting() {
        const val = getProfileScopedSetting(PROJECT_DIVISION_TOGGLE_KEY);
        projectDivisionEnabled = (val === null) ? false : (val === "true");
        if (cpProjectDivisionToggleEl) cpProjectDivisionToggleEl.checked = projectDivisionEnabled;
    }

    function loadOneNoteReminderSetting() {
        const val = getProfileScopedSetting(ONENOTE_REMINDER_KEY);
        oneNoteReminderEnabled = (val === null) ? false : (val === "true");
        if (cpOneNoteReminderToggleEl) cpOneNoteReminderToggleEl.checked = oneNoteReminderEnabled;
    }


function applyMidnightGuardTemporaryVisualState() {
    if (cpMidnightGuardEl) {
        cpMidnightGuardEl.classList.toggle("temp-restore-off", !!midnightGuardTempResumeSuspended);
        cpMidnightGuardEl.disabled = !!midnightGuardTempResumeSuspended;
        cpMidnightGuardEl.setAttribute("aria-disabled", String(!!midnightGuardTempResumeSuspended));
    }
    const guardRowEl = cpMidnightGuardEl ? cpMidnightGuardEl.closest(".control-panel-row") : null;
    if (guardRowEl) guardRowEl.classList.toggle("guard-temp-disabled", !!midnightGuardTempResumeSuspended);

    const guardHelpEl = guardRowEl ? guardRowEl.querySelector(".control-panel-help") : null;
    if (guardHelpEl) {
        if (!guardHelpEl.dataset.defaultText) guardHelpEl.dataset.defaultText = guardHelpEl.textContent || "";
        guardHelpEl.textContent = midnightGuardTempResumeSuspended
            ? "Midlertidig deaktivert"
            : (guardHelpEl.dataset.defaultText || guardHelpEl.textContent || "");
    }

    if (profileButtonEl) {
        profileButtonEl.classList.toggle("profile-temp-guard-indicator", !!profileTempGuardIndicatorActive);
        if (!profileTempGuardIndicatorActive) profileButtonEl.classList.remove("profile-temp-guard-blink");
    }
}

function triggerMidnightGuardRestoreVisualCue() {
    profileTempGuardIndicatorActive = true;
    applyMidnightGuardTemporaryVisualState();
    if (!profileButtonEl) return;
    profileButtonEl.classList.remove("profile-temp-guard-blink");
    void profileButtonEl.offsetWidth;
    profileButtonEl.classList.add("profile-temp-guard-blink");
    if (profileTempGuardBlinkTimer) clearTimeout(profileTempGuardBlinkTimer);
    profileTempGuardBlinkTimer = setTimeout(() => {
        if (!profileButtonEl) return;
        profileButtonEl.classList.remove("profile-temp-guard-blink");
        profileTempGuardIndicatorActive = false;
        applyMidnightGuardTemporaryVisualState();
    }, 3000);
}

function activateTemporaryMidnightGuardSuspendForRestore() {
    if (midnightGuardTempResumeSuspended) {
        midnightDoubleCountGuardEnabled = false;
        if (cpMidnightGuardEl) cpMidnightGuardEl.checked = false;
        applyMidnightGuardTemporaryVisualState();
        return;
    }
    midnightGuardTempResumePrevEnabled = !!midnightDoubleCountGuardEnabled;
    midnightGuardTempResumeSuspended = true;
    midnightDoubleCountGuardEnabled = false;
    if (cpMidnightGuardEl) cpMidnightGuardEl.checked = false;
    applyMidnightGuardTemporaryVisualState();
    triggerMidnightGuardRestoreVisualCue();
}

function finalizeTemporaryMidnightGuardSuspend() {
    if (!midnightGuardTempResumeSuspended) return;
    const restoreEnabled = (midnightGuardTempResumePrevEnabled === null)
        ? true
        : !!midnightGuardTempResumePrevEnabled;
    midnightGuardTempResumeSuspended = false;
    midnightGuardTempResumePrevEnabled = null;
    profileTempGuardIndicatorActive = false;
    midnightDoubleCountGuardEnabled = restoreEnabled;
    if (cpMidnightGuardEl) cpMidnightGuardEl.checked = restoreEnabled;
    applyMidnightGuardTemporaryVisualState();
}

    function getStartOfTodayMs() {
        const d = new Date();
        d.setHours(0,0,0,0);
        return d.getTime();
    }

    function hasUnarchivedPreviousDayTasks() {
        if (!midnightDoubleCountGuardEnabled) return false;
        if (!data || !Array.isArray(data.tasks) || data.tasks.length === 0) return false;
        const startOfToday = getStartOfTodayMs();
        return data.tasks.some(t => {
            const ts = t && (t.createdAt || t.firstStartAt || t.lastEndAt || t.lastStartMs || 0);
            return !!ts && ts < startOfToday;
        });
    }

    function hasGuardArchiveLockAfterStop() {
        if (!midnightDoubleCountGuardEnabled) return false;
        if (!data || !Array.isArray(data.tasks) || data.tasks.length === 0) return false;
        if (getActiveTask()) return false;
        return data.tasks.some(t => t && !t.isActive);
    }

    function showArchiveRequiredNoticeForPreviousDay() {
        // Bevisst uten native alert/confirm/prompt:
        // nettleserens systemdialog (file:// + "don't allow this site to prompt you again")
        // kan ikke styles/skjules. Funksjonen skal kun blokkere ny føring stille.
        return;
    }

    function canStartOrResumeWorkNow(showAlert=true) {
        const blockedPrevDay = hasUnarchivedPreviousDayTasks();
        const blockedGuardArchive = hasGuardArchiveLockAfterStop();
        const blocked = blockedPrevDay || blockedGuardArchive;
        if (blocked && showAlert) showArchiveRequiredNoticeForPreviousDay();
        return !blocked;
    }

    function finalizeActiveTaskAtSameStartDate(hour, minute) {
        const idx = getActiveTaskIndex();
        if (idx === -1) return;
        const task = data.tasks[idx];
        const baseMs = Math.max(0, task.totalMs || 0);
        const startMs = task.lastStartMs;
        if (!startMs) { finalizeActiveTask(); return; }

        const startDate = new Date(startMs);
        const endDate = new Date(startDate);
        endDate.setHours(hour, minute, 0, 0);

        const delta = Math.max(0, endDate.getTime() - startMs);
        task.totalMs = baseMs + delta;
        task.isActive = false;
        task.lastEndAt = endDate.getTime();
        task.lastStartMs = null;
    }

    function handleMidnightGuardAutoStopIfNeeded() {
        if (!midnightDoubleCountGuardEnabled) return;
        const activeTask = getActiveTask();
        if (!activeTask || !activeTask.lastStartMs) return;

        const startOfToday = getStartOfTodayMs();
        if (activeTask.lastStartMs >= startOfToday) return; // still same day

        if (!overduePopupShown) {
            // Store state before auto-stop so the user-entered time can replace the provisional 23:59 stop time.
            activeTask.midnightGuardPending = true;
            activeTask.midnightGuardBaseMs = Math.max(0, activeTask.totalMs || 0);
            activeTask.midnightGuardStartMs = activeTask.lastStartMs;

            finalizeActiveTaskAt(23, 59);
            // Vis normal oversikt etter autostopp, men lås videre føring til brukeren arkiverer.
            selectedTaskId = null;
            endDayPressedAtMs = Date.now();
            saveTimelineMode('work');
            saveToStorage();
            updateUI();
    refreshProjectDivisionArrowBlink();
            autoResizeSplitter();
            enableCompactMode();
            showOverduePopup(activeTask, "midnightGuard");
        }
    }

    

    // --- Ingen hjelpetekst (skjul hjelpetekster + tooltips) ---
    let noHelpObserver = null;

    
    function disablePlaceholderOnElement(el){
        if (!el || el.nodeType !== 1) return;
        if (el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA') return;
        if (!el.hasAttribute || !el.hasAttribute('placeholder')) return;
        if (el.dataset && typeof el.dataset.placeholderBackup === 'undefined') {
            el.dataset.placeholderBackup = el.getAttribute('placeholder') || '';
        }
        el.setAttribute('placeholder', '');
    }

    function restorePlaceholderOnElement(el){
        if (!el || el.nodeType !== 1) return;
        if (el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA') return;
        if (!el.dataset || typeof el.dataset.placeholderBackup === 'undefined') return;
        const val = el.dataset.placeholderBackup || '';
        el.setAttribute('placeholder', val);
        delete el.dataset.placeholderBackup;
    }

    function applyNoHelpPlaceholders(enable){
        // Only the placeholders requested by the user
        const ids = ['taskInput', 'projectNumberInput', 'appNotesTextarea', 'commentTextarea', 'adhdTasksTextarea', 'projectTaskDivisionTextarea'];
        ids.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            if (enable) disablePlaceholderOnElement(el);
            else restorePlaceholderOnElement(el);
        });
    }


    function applyNoHelpExtraTexts(enable){
        const idsToToggle = ['transferHelpDesc', 'adjustStartDesc'];
        idsToToggle.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            if (enable) {
                if (el.dataset && typeof el.dataset.displayBackup === 'undefined') {
                    el.dataset.displayBackup = el.style.display || '';
                }
                el.style.display = 'none';
            } else {
                const val = (el.dataset && typeof el.dataset.displayBackup !== 'undefined') ? el.dataset.displayBackup : '';
                el.style.display = val;
                if (el.dataset) delete el.dataset.displayBackup;
            }
        });
    }


function ensureHelpTextContainers(root = document.body){
        // HJELPETEKST-KONTRAKT (runtime sikkerhet):
        // Wrapper alle eksisterende/nye .helper-text / .inline-note / .empty-text i en semantisk container
        // slik at "Ingen hjelpetekst" forblir robust ved fremtidige utvidelser.
        if (!root) return;
        const roots = [];
        if (root.nodeType === 1 || root === document || root === document.body) roots.push(root);
        const candidates = [];
        roots.forEach(r => {
            if (r.nodeType === 1 && (r.matches?.('.helper-text, .inline-note, .empty-text'))) candidates.push(r);
            if (r.querySelectorAll) candidates.push(...r.querySelectorAll('.helper-text, .inline-note, .empty-text'));
        });

        candidates.forEach(el => {
            if (!el || !el.parentElement) return;
            if (el.closest('.helptext-container[data-helptext-container="true"]')) return;

            const wrapper = document.createElement('div');
            wrapper.className = 'helptext-container';
            wrapper.setAttribute('data-helptext-container', 'true');
            // Merk wrappers inne i innstillingsvindu for lesbarhet ved feilsøking.
            if (el.closest('#settingsOverlay')) wrapper.setAttribute('data-helptext-scope', 'settings');

            el.parentNode.insertBefore(wrapper, el);
            wrapper.appendChild(el);
        });
    }

    function disableTitleOnElement(el){
        if (!el || el.nodeType !== 1) return;
        if (el.hasAttribute && el.hasAttribute('title')) {
            if (el.dataset && typeof el.dataset.titleBackup === 'undefined') {
                el.dataset.titleBackup = el.getAttribute('title') || '';
            }
            el.removeAttribute('title');
        }
    }

    function stripTitlesInSubtree(root){
        if (!root || root.nodeType !== 1) return;
        disableTitleOnElement(root);
        if (root.querySelectorAll) root.querySelectorAll('[title]').forEach(disableTitleOnElement);
    }

    function startNoHelpObserver(){
        if (noHelpObserver) return;
        noHelpObserver = new MutationObserver((mutations) => {
            if (!document.body.classList.contains('no-helpertext')) return;
            for (const m of mutations) {
                if (m.type === 'attributes' && m.attributeName === 'title') {
                    disableTitleOnElement(m.target);
                } else if (m.type === 'childList' && m.addedNodes && m.addedNodes.length) {
                    m.addedNodes.forEach(n => {
                        stripTitlesInSubtree(n);
                        ensureHelpTextContainers(n);
                    });
                }
            }
        });
        noHelpObserver.observe(document.body, { subtree: true, childList: true, attributes: true, attributeFilter: ['title'] });
    }

    function stopNoHelpObserver(){
        if (!noHelpObserver) return;
        noHelpObserver.disconnect();
        noHelpObserver = null;
    }

    function restoreAllTitles(){
        document.querySelectorAll('[data-title-backup]').forEach(el => {
            const val = (el.dataset && typeof el.dataset.titleBackup !== 'undefined') ? el.dataset.titleBackup : '';
            if (val) el.setAttribute('title', val);
            if (el.dataset) delete el.dataset.titleBackup;
        });
    }

    function applyNoHelpTextMode(isOn){
        const enable = !!isOn;
        ensureHelpTextContainers(document.body);
        document.body.classList.toggle('no-helpertext', enable);
        if (enable) {
            applyNoHelpPlaceholders(true);
            applyNoHelpExtraTexts(true);
            stripTitlesInSubtree(document.body);
            startNoHelpObserver();
        } else {
            applyNoHelpPlaceholders(false);
            applyNoHelpExtraTexts(false);
            stopNoHelpObserver();
            restoreAllTitles();
        }
    }

    function loadNoHelpTextSetting(){
        // "Ingen hjelpetekst" er fjernet: sørg for at hjelpetekst alltid er aktiv.
        ensureHelpTextContainers(document.body);
        try { setProfileScopedSetting(NO_HELP_TEXT_KEY, false); } catch(e){}
        if (cpNoHelpTextEl) {
            try { cpNoHelpTextEl.checked = false; } catch(e){}
        }
        applyNoHelpTextMode(false);
    }
function syncUnderDevelopmentVisibilityUi(){
        const open = !!underDevelopmentExpanded;
        if (underDevelopmentItemsEl) {
            underDevelopmentItemsEl.classList.toggle('open', open);
            underDevelopmentItemsEl.setAttribute('aria-hidden', String(!open));
        }
        if (underDevelopmentVisibilityButtonEl) {
            underDevelopmentVisibilityButtonEl.textContent = open ? 'Skjul alt' : 'Vis alt';
            underDevelopmentVisibilityButtonEl.setAttribute('aria-pressed', String(open));
        }
    }

    function setUnderDevelopmentExpanded(isOpen){
        underDevelopmentExpanded = !!isOpen;
        syncUnderDevelopmentVisibilityUi();
    }
    function loadUnderDevelopmentExpandedSetting(){
        const val = getProfileScopedSetting(UNDER_DEVELOPMENT_EXPANDED_KEY, { fallbackToGlobal: false });
        setUnderDevelopmentExpanded(val === 'true');
    }
    function saveUnderDevelopmentExpandedSetting(isOpen){
        setProfileScopedSetting(UNDER_DEVELOPMENT_EXPANDED_KEY, !!isOpen);
    }

function setPersonalCustomizationUiState(isOn){
        const on = !!isOn;
        if (cpPersonalCustomizationToggleEl) cpPersonalCustomizationToggleEl.checked = on;
        if (personalCustomizeActionWrapEl) personalCustomizeActionWrapEl.style.display = on ? '' : 'none';
        if (!on && frutigerMusicPlayerVisible) setFrutigerMusicPlayerVisible(false);
        if (toggleFrutigerMusicPlayerButtonEl) {
            toggleFrutigerMusicPlayerButtonEl.classList.toggle('active', !!frutigerMusicPlayerVisible);
            toggleFrutigerMusicPlayerButtonEl.setAttribute('aria-pressed', String(!!frutigerMusicPlayerVisible));
        }
        syncPersonalOverlayBackdropStrongBlur();
    }

    function loadPersonalCustomizationToggle(){
        let on = false;
        try { on = getProfileScopedSetting(PERSONAL_CUSTOMIZATION_TOGGLE_KEY) === 'true'; } catch(e){}
        setPersonalCustomizationUiState(on);
    }

    function savePersonalCustomizationToggle(isOn){
        try { setProfileScopedSetting(PERSONAL_CUSTOMIZATION_TOGGLE_KEY, !!isOn); } catch(e){}
    }

    function openPersonalBgMediaDb(){
        if (personalBgMediaDbPromise) return personalBgMediaDbPromise;
        personalBgMediaDbPromise = new Promise((resolve, reject) => {
            try {
                const request = indexedDB.open(PERSONAL_BG_MEDIA_DB_NAME, PERSONAL_BG_MEDIA_DB_VERSION);
                request.onupgradeneeded = () => {
                    const db = request.result;
                    if (!db.objectStoreNames.contains(PERSONAL_BG_MEDIA_STORE)) {
                        db.createObjectStore(PERSONAL_BG_MEDIA_STORE, { keyPath: 'key' });
                    }
                };
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error || new Error('IndexedDB åpnet ikke.'));
            } catch (err) {
                reject(err);
            }
        }).catch(err => {
            console.warn('Kunne ikke åpne IndexedDB for bakgrunnsmedia.', err);
            personalBgMediaDbPromise = null;
            return null;
        });
        return personalBgMediaDbPromise;
    }

    function getPersonalBgMediaStorageKey(profileName){
        const profile = String(profileName || currentProfile || 'Standard').trim() || 'Standard';
        return `pageBgMedia::${profile}`;
    }

    async function putPersonalBgMediaInDb(key, payload){
        const db = await openPersonalBgMediaDb();
        if (!db || !key) return false;
        return new Promise(resolve => {
            try {
                const tx = db.transaction(PERSONAL_BG_MEDIA_STORE, 'readwrite');
                const store = tx.objectStore(PERSONAL_BG_MEDIA_STORE);
                store.put({ key, payload });
                tx.oncomplete = () => resolve(true);
                tx.onerror = () => resolve(false);
                tx.onabort = () => resolve(false);
            } catch (err) {
                console.warn('Kunne ikke lagre bakgrunnsmedia i IndexedDB.', err);
                resolve(false);
            }
        });
    }

    async function getPersonalBgMediaFromDb(key){
        const db = await openPersonalBgMediaDb();
        if (!db || !key) return null;
        return new Promise(resolve => {
            try {
                const tx = db.transaction(PERSONAL_BG_MEDIA_STORE, 'readonly');
                const store = tx.objectStore(PERSONAL_BG_MEDIA_STORE);
                const req = store.get(key);
                req.onsuccess = () => {
                    const result = req.result;
                    resolve(result && result.payload ? result.payload : null);
                };
                req.onerror = () => resolve(null);
            } catch (err) {
                console.warn('Kunne ikke lese bakgrunnsmedia fra IndexedDB.', err);
                resolve(null);
            }
        });
    }

    async function deletePersonalBgMediaFromDb(key){
        const db = await openPersonalBgMediaDb();
        if (!db || !key) return false;
        return new Promise(resolve => {
            try {
                const tx = db.transaction(PERSONAL_BG_MEDIA_STORE, 'readwrite');
                const store = tx.objectStore(PERSONAL_BG_MEDIA_STORE);
                store.delete(key);
                tx.oncomplete = () => resolve(true);
                tx.onerror = () => resolve(false);
                tx.onabort = () => resolve(false);
            } catch (err) {
                console.warn('Kunne ikke slette bakgrunnsmedia fra IndexedDB.', err);
                resolve(false);
            }
        });
    }

    function valuesUseExternalPersonalBgMedia(valuesObj){
        return !!(valuesObj && (valuesObj.pageBgMediaExternal === true || valuesObj.pageBgMediaExternal === 'true'));
    }

    function buildPersonalCustomizationValuesForStorage(valuesObj){
        const base = (valuesObj && typeof valuesObj === 'object' && !Array.isArray(valuesObj))
            ? JSON.parse(JSON.stringify(valuesObj))
            : {};
        const state = readPersonalBackgroundStateFromValues(base);
        const isMedia = (state.type === 'image' || state.type === 'video') && !!state.mediaDataUrl;
        if (isMedia) {
            base.pageBgMediaExternal = 'true';
            base.pageBgMediaStorageKey = getPersonalBgMediaStorageKey();
            base.pageBgMediaDataUrl = '';
        } else {
            delete base.pageBgMediaExternal;
            delete base.pageBgMediaStorageKey;
        }
        return base;
    }

    async function persistCurrentPersonalBgMedia(valuesObj, profileName){
        const values = (valuesObj && typeof valuesObj === 'object' && !Array.isArray(valuesObj)) ? valuesObj : {};
        const state = readPersonalBackgroundStateFromValues(values);
        const storageKey = getPersonalBgMediaStorageKey(profileName);
        if ((state.type === 'image' || state.type === 'video') && state.mediaDataUrl) {
            await putPersonalBgMediaInDb(storageKey, {
                dataUrl: state.mediaDataUrl,
                kind: state.mediaKind || state.type,
                savedAt: Date.now()
            });
            return true;
        }
        await deletePersonalBgMediaFromDb(storageKey);
        return true;
    }

    function hydratePersonalBgMediaForCurrentProfile(opts = {}){
        const token = ++personalBgMediaHydrationToken;
        const profileAtStart = String(currentProfile || 'Standard');
        const targetValues = personalCustomizationValues;
        if (!valuesUseExternalPersonalBgMedia(targetValues)) return Promise.resolve(false);
        const storageKey = String(targetValues.pageBgMediaStorageKey || getPersonalBgMediaStorageKey(profileAtStart));
        return getPersonalBgMediaFromDb(storageKey).then(payload => {
            if (!payload || !payload.dataUrl) return false;
            if (token !== personalBgMediaHydrationToken) return false;
            if (String(currentProfile || 'Standard') !== profileAtStart) return false;
            if (personalCustomizationValues !== targetValues) return false;
            personalCustomizationValues.pageBgMediaDataUrl = String(payload.dataUrl || '');
            if (!personalCustomizationValues.pageBgMediaKind) {
                personalCustomizationValues.pageBgMediaKind = String(payload.kind || personalCustomizationValues.pageBgType || '');
            }
            if (opts.apply !== false) {
                if (isPersonalCustomizeModalOpen()) return true;
                applyPersonalCustomizationHeadings();
            }
            return true;
        }).catch(err => {
            console.warn('Kunne ikke hydrere bakgrunnsmedia fra IndexedDB.', err);
            return false;
        });
    }


    function getPersonalCustomizationFieldElement(def){
        if (!def || !def.selector) return null;
        try { return document.querySelector(def.selector); } catch(e) { return null; }
    }

    function getPersonalCustomizationFieldText(def){
        const el = getPersonalCustomizationFieldElement(def);
        if (!el) return (def && def.label) ? def.label : '';
        return (el.textContent || '').trim();
    }

    function setPersonalCustomizationFieldText(def, text){
        const el = getPersonalCustomizationFieldElement(def);
        if (!el) return;
        el.textContent = String(text == null ? '' : text);
    }

    function capturePersonalCustomizationDefaults(){
        PERSONAL_CUSTOMIZATION_FIELD_DEFS.forEach(def => {
            if (!def) return;
            const current = getPersonalCustomizationFieldText(def);
            if (!personalCustomizationDefaultLabels[def.key]) {
                personalCustomizationDefaultLabels[def.key] = current || def.label || '';
            }
        });
    }

    function loadPersonalCustomizationValues(){
        let parsed = {};
        try {
            const raw = getProfileScopedSetting(PERSONAL_CUSTOMIZATION_VALUES_KEY);
            if (raw) parsed = JSON.parse(raw) || {};
        } catch(e){ parsed = {}; }
        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) parsed = {};
        personalCustomizationValues = parsed;
        hydratePersonalBgMediaForCurrentProfile({ apply: true });
    }

    function isPersonalCustomizeModalOpen(){
        return !!(personalCustomizeOverlayEl && personalCustomizeOverlayEl.classList.contains('show'));
    }

    const PERSONAL_BG_HISTORY_MAX_IMAGE_ITEMS = 6;
    const PERSONAL_BG_HISTORY_MAX_VIDEO_ITEMS = 2;
    const PERSONAL_BG_HISTORY_MAX_TOTAL_STORAGE_BYTES = 4 * 1024 * 1024;
    const PERSONAL_BG_MAX_UPLOAD_IMAGE_BYTES = 5 * 1024 * 1024;
    const PERSONAL_BG_MAX_UPLOAD_VIDEO_BYTES = 10 * 1024 * 1024;

    function estimateStorageBytesFromString(str){
        return (typeof str === 'string' ? str.length : 0) * 2;
    }

    function estimatePersonalBgMediaEntryStorageBytes(entry){
        if (!entry || typeof entry !== 'object') return 0;
        return estimateStorageBytesFromString(entry.dataUrl || '') + estimateStorageBytesFromString(entry.name || '') + 256;
    }

    function trimPersonalCustomizationValuesForStorage(valuesObj, opts = {}){
        const base = (valuesObj && typeof valuesObj === 'object' && !Array.isArray(valuesObj))
            ? JSON.parse(JSON.stringify(valuesObj))
            : {};
        const state = readPersonalBackgroundStateFromValues(base);
        if (opts.clearHistory) state.mediaHistory = [];
        if (opts.clearCurrentMedia) {
            state.type = 'none';
            state.mediaKind = '';
            state.mediaDataUrl = '';
        }
        writePersonalBackgroundStateToValues(base, state);
        return base;
    }

    function savePersonalCustomizationValues(){
        const storageKey = getProfileScopedSettingKey(PERSONAL_CUSTOMIZATION_VALUES_KEY);
        const liveValues = (personalCustomizationValues && typeof personalCustomizationValues === 'object') ? personalCustomizationValues : {};
        persistCurrentPersonalBgMedia(liveValues, currentProfile);
        const tryWrite = (valuesObj) => {
            const payload = JSON.stringify(valuesObj || {});
            localStorage.setItem(storageKey, payload);
            return true;
        };
        try {
            return tryWrite(buildPersonalCustomizationValuesForStorage(liveValues));
        } catch(e){}

        try {
            const trimmedHistoryValues = trimPersonalCustomizationValuesForStorage(buildPersonalCustomizationValuesForStorage(liveValues), { clearHistory: true });
            const ok = tryWrite(trimmedHistoryValues);
            if (ok && personalBgMediaStatusEl) {
                personalBgMediaStatusEl.textContent = 'Historikk for bilde/video ble trimmet for å frigjøre lagringsplass.';
            }
            return ok;
        } catch(e){}

        try {
            const trimmedMediaValues = trimPersonalCustomizationValuesForStorage(buildPersonalCustomizationValuesForStorage(liveValues), { clearHistory: true, clearCurrentMedia: true });
            const ok = tryWrite(trimmedMediaValues);
            if (ok && personalBgMediaStatusEl) {
                personalBgMediaStatusEl.textContent = 'Bakgrunnsmedia ble lagret separat for å unngå at visningen forsvinner.';
            }
            return ok;
        } catch(e) {
            console.warn('Kunne ikke lagre personlig tilpasning i localStorage.', e);
        }
        return false;
    }

    function isPersonalCustomizationEnabled(){
        return !!(cpPersonalCustomizationToggleEl && cpPersonalCustomizationToggleEl.checked);
    }


    function syncPersonalOverlayBackdropStrongBlur(){
        // Aktivér kraftig blur bak innstillings-/tilpasningsvinduer kun når:
        // - Personlig tilpasning er aktiv (toggle på), og
        // - glassmodus er aktivert (glass-mode-active på body)
        const enable = isPersonalCustomizationEnabled() && document.body.classList.contains('glass-mode-active');
        document.body.classList.toggle('personal-strong-overlay-blur', !!enable);
    }

    function refreshThemeDependentVisuals(){
        try { drawTaskChart(); } catch(e){}
        try { renderDayTimeline(); } catch(e){}
        try { updateTimelineNowDot(); } catch(e){}
    }

    function activatePersonalCtrlLightHold(){
        if (personalCtrlLightHoldActive) return;
        if (!isPersonalCustomizationEnabled()) return;
        personalCtrlLightRestoreThemeMode = getCurrentThemeMode();
        personalCtrlLightHoldActive = true;
        applyThemeMode('light', { persist: false });
        refreshThemeDependentVisuals();
    }

    function releasePersonalCtrlLightHold(){
        if (!personalCtrlLightHoldActive) return;
        const restoreMode = personalCtrlLightRestoreThemeMode || 'light';
        personalCtrlLightHoldActive = false;
        personalCtrlLightRestoreThemeMode = null;
        applyThemeMode(restoreMode, { persist: false });
        refreshThemeDependentVisuals();
    }

    function getPersonalCustomizationDisplayText(def){
        const base = personalCustomizationDefaultLabels[def.key] || def.label || '';
        if (!isPersonalCustomizationEnabled()) return base;
        const custom = (personalCustomizationValues && typeof personalCustomizationValues[def.key] === 'string')
            ? personalCustomizationValues[def.key].trim()
            : '';
        return custom || base;
    }

    function applyPersonalCustomizationHeadings(){
        capturePersonalCustomizationDefaults();
        PERSONAL_CUSTOMIZATION_FIELD_DEFS.forEach(def => {
            const nextText = getPersonalCustomizationDisplayText(def);
            setPersonalCustomizationFieldText(def, nextText);
        });
        applyPersonalCustomizationBackground();
    }

    function buildPersonalCustomizeRow(def){
        const row = document.createElement('div');
        row.style.display = 'grid';
        row.style.gridTemplateColumns = '1fr 1fr';
        row.style.gap = '0.55rem';
        row.style.alignItems = 'center';
        row.style.marginBottom = '0.45rem';

        const left = document.createElement('div');
        left.style.border = '1px solid var(--border-soft)';
        left.style.borderRadius = '0.5rem';
        left.style.padding = '0.5rem 0.65rem';
        left.style.background = 'var(--bg-soft)';
        left.style.fontSize = '0.9rem';
        left.style.lineHeight = '1.25';
        left.textContent = personalCustomizationDefaultLabels[def.key] || def.label || '';

        const right = document.createElement('input');
        right.type = 'text';
        right.className = 'modal-input';
        right.dataset.pcKey = def.key;
        right.placeholder = 'Valgfritt nytt navn';
        right.value = (personalCustomizationValues && typeof personalCustomizationValues[def.key] === 'string')
            ? personalCustomizationValues[def.key]
            : '';
        right.style.width = '100%';
        right.style.minWidth = '0';

        row.appendChild(left);
        row.appendChild(right);
        return row;
    }

    function renderPersonalCustomizeModalRows(){
        if (!personalCustomizeRowsEl) return;
        capturePersonalCustomizationDefaults();
        personalCustomizeRowsEl.innerHTML = '';

        const head = document.createElement('div');
        head.style.display = 'grid';
        head.style.gridTemplateColumns = '1fr 1fr';
        head.style.gap = '0.55rem';
        head.style.margin = '0 0 0.45rem 0';
        head.innerHTML = '<div style="font-size:0.75rem; opacity:0.8; padding-left:0.15rem; font-weight:600;">Fra</div><div style="font-size:0.75rem; opacity:0.8; padding-left:0.15rem; font-weight:600;">Til</div>';
        personalCustomizeRowsEl.appendChild(head);

        PERSONAL_CUSTOMIZATION_FIELD_DEFS.forEach(def => {
            personalCustomizeRowsEl.appendChild(buildPersonalCustomizeRow(def));
        });
    }

    function collectPersonalCustomizeModalValues(){
        const next = {};
        if (!personalCustomizeRowsEl) return next;
        personalCustomizeRowsEl.querySelectorAll('input[data-pc-key]').forEach(inp => {
            const key = inp.dataset.pcKey;
            if (!key) return;
            next[key] = String(inp.value || '');
        });
        return next;
    }

    function savePersonalCustomizeModalValues(){
        personalCustomizationValues = collectPersonalCustomizeModalValues();
        savePersonalCustomizationValues();
        applyPersonalCustomizationHeadings();
    }

    function resetPersonalCustomizationValues(){
        deletePersonalBgMediaFromDb(getPersonalBgMediaStorageKey());
        personalCustomizationValues = {};
        writePersonalBgMediaHistoryToValues(personalCustomizationValues, []);
        savePersonalCustomizationValues();
        personalCustomizeBackgroundDraft = getDefaultPersonalBackgroundState();
        personalCustomizeBackgroundDraft.mediaHistory = [];
        personalCustomizeBackgroundSavedSnapshot = clonePersonalBackgroundState(personalCustomizeBackgroundDraft);
        renderPersonalCustomizeModalRows();
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(personalCustomizeBackgroundDraft, { preview: true, forceOn: true });
        applyThemeMode('light');
        syncThemeButtonMediaPulse(false);
        applyPersonalCustomizationHeadings();
    }

    function normalizePersonalGlassBlurPx(v){
        const n = Number(v);
        if (!Number.isFinite(n)) return 1;
        if (n <= 1) return 1;
        if (n >= 24) return 24;
        if (n <= 6) return 1;
        if (n <= 18) return 12;
        return 24;
    }

    function getDefaultPersonalBackgroundState(){
        return {
            type: 'none',
            hue: 210,
            sat: 35,
            light: 96,
            mediaDataUrl: '',
            mediaKind: '',
            glassEnabled: false,
            glassOpacity: 30,
            glassBlurPx: 1,
            textOverrideEnabled: false,
            textHue: 220,
            textSat: 12,
            textLight: 18,
            mediaHistory: []
        };
    }

    function clonePersonalBackgroundState(state){
        const src = state && typeof state === 'object' ? state : getDefaultPersonalBackgroundState();
        return {
            type: (src.type === 'color' || src.type === 'image' || src.type === 'video') ? src.type : 'none',
            hue: Math.max(0, Math.min(360, Number.isFinite(Number(src.hue)) ? Number(src.hue) : 210)),
            sat: Math.max(0, Math.min(100, Number.isFinite(Number(src.sat)) ? Number(src.sat) : 35)),
            light: Math.max(0, Math.min(100, Number.isFinite(Number(src.light)) ? Number(src.light) : 96)),
            mediaDataUrl: typeof src.mediaDataUrl === 'string' ? src.mediaDataUrl : '',
            mediaKind: (src.mediaKind === 'image' || src.mediaKind === 'video') ? src.mediaKind : '',
            glassEnabled: !!src.glassEnabled,
            glassOpacity: Math.max(0, Math.min(100, Number.isFinite(Number(src.glassOpacity)) ? Number(src.glassOpacity) : 30)),
            glassBlurPx: normalizePersonalGlassBlurPx(src.glassBlurPx),
            textOverrideEnabled: !!src.textOverrideEnabled,
            textHue: Math.max(0, Math.min(360, Number.isFinite(Number(src.textHue)) ? Number(src.textHue) : 220)),
            textSat: Math.max(0, Math.min(100, Number.isFinite(Number(src.textSat)) ? Number(src.textSat) : 12)),
            textLight: Math.max(0, Math.min(100, Number.isFinite(Number(src.textLight)) ? Number(src.textLight) : 18)),
            mediaHistory: limitPersonalBgMediaHistoryList(src.mediaHistory)
        };
    }

    function normalizePersonalBgMediaHistoryEntry(entry){
        if (!entry || typeof entry !== 'object') return null;
        const kind = entry.kind === 'video' ? 'video' : (entry.kind === 'image' ? 'image' : '');
        const dataUrl = typeof entry.dataUrl === 'string' ? entry.dataUrl : '';
        if (!kind || !dataUrl) return null;
        const name = (typeof entry.name === 'string' && entry.name.trim()) ? entry.name.trim() : (kind === 'video' ? 'Video' : 'Bilde');
        const addedAt = Number.isFinite(Number(entry.addedAt)) ? Number(entry.addedAt) : Date.now();
        return { kind, dataUrl, name, addedAt };
    }

    function limitPersonalBgMediaHistoryList(list){
        const arr = (Array.isArray(list) ? list : [])
            .map(item => normalizePersonalBgMediaHistoryEntry(item))
            .filter(Boolean)
            .sort((a, b) => Number(b.addedAt || 0) - Number(a.addedAt || 0));
        let img = 0;
        let vid = 0;
        let totalBytes = 0;
        const out = [];
        for (const item of arr) {
            const itemBytes = estimatePersonalBgMediaEntryStorageBytes(item);
            if (item.kind === 'image') {
                if (img >= PERSONAL_BG_HISTORY_MAX_IMAGE_ITEMS) continue;
            } else if (item.kind === 'video') {
                if (vid >= PERSONAL_BG_HISTORY_MAX_VIDEO_ITEMS) continue;
            } else {
                continue;
            }
            if ((totalBytes + itemBytes) > PERSONAL_BG_HISTORY_MAX_TOTAL_STORAGE_BYTES) continue;
            out.push(item);
            totalBytes += itemBytes;
            if (item.kind === 'image') img += 1;
            else if (item.kind === 'video') vid += 1;
        }
        return out;
    }


    function getPersonalBgMediaHistoryFromValues(valuesObj){
        if (!valuesObj || typeof valuesObj !== 'object') return [];
        let arr = [];
        if (Array.isArray(valuesObj.pageBgMediaHistory)) arr = valuesObj.pageBgMediaHistory;
        else if (typeof valuesObj.pageBgMediaHistoryJson === 'string' && valuesObj.pageBgMediaHistoryJson.trim()) {
            try { arr = JSON.parse(valuesObj.pageBgMediaHistoryJson); } catch(e){ arr = []; }
        }
        if (!Array.isArray(arr)) arr = [];
        return limitPersonalBgMediaHistoryList(arr);
    }

    function writePersonalBgMediaHistoryToValues(valuesObj, historyArr){
        if (!valuesObj || typeof valuesObj !== 'object') return valuesObj;
        const normalized = limitPersonalBgMediaHistoryList(historyArr);
        valuesObj.pageBgMediaHistoryJson = JSON.stringify(normalized);
        try { valuesObj.pageBgMediaHistory = normalized; } catch(e){}
        return valuesObj;
    }

    function readPersonalBackgroundStateFromValues(valuesObj){
        const base = getDefaultPersonalBackgroundState();
        const values = (valuesObj && typeof valuesObj === 'object') ? valuesObj : {};
        const next = clonePersonalBackgroundState({
            type: values.pageBgType || 'none',
            hue: values.pageBgHue,
            sat: values.pageBgSat,
            light: values.pageBgLight,
            mediaDataUrl: values.pageBgMediaDataUrl || '',
            mediaKind: values.pageBgMediaKind || '',
            glassEnabled: values.pageBgGlassEnabled === true || values.pageBgGlassEnabled === 'true',
            glassOpacity: values.pageBgGlassOpacity,
            glassBlurPx: values.pageBgGlassBlurPx,
            textOverrideEnabled: values.pageTextColorOverrideEnabled === true || values.pageTextColorOverrideEnabled === 'true',
            textHue: values.pageTextColorHue,
            textSat: values.pageTextColorSat,
            textLight: values.pageTextColorLight,
            mediaHistory: getPersonalBgMediaHistoryFromValues(values)
        });
        const hasExternalMedia = valuesUseExternalPersonalBgMedia(values);
        if ((next.type === 'image' || next.type === 'video') && !next.mediaDataUrl && !hasExternalMedia) {
            next.type = 'none';
        }
        if (next.type === 'none' && values.pageBgType === 'color') {
            next.type = 'color';
        }
        return Object.assign(base, next);
    }

    function writePersonalBackgroundStateToValues(valuesObj, state){
        if (!valuesObj || typeof valuesObj !== 'object') return valuesObj;
        const s = clonePersonalBackgroundState(state);
        valuesObj.pageBgType = s.type;
        valuesObj.pageBgHue = String(Math.round(s.hue));
        valuesObj.pageBgSat = String(Math.round(s.sat));
        valuesObj.pageBgLight = String(Math.round(s.light));
        valuesObj.pageBgMediaKind = (s.type === 'image' || s.type === 'video') ? s.mediaKind || s.type : '';
        valuesObj.pageBgMediaDataUrl = (s.type === 'image' || s.type === 'video') ? (s.mediaDataUrl || '') : '';
        if (s.type === 'image' || s.type === 'video') {
            valuesObj.pageBgMediaExternal = 'false';
            valuesObj.pageBgMediaStorageKey = getPersonalBgMediaStorageKey();
        } else {
            delete valuesObj.pageBgMediaExternal;
            delete valuesObj.pageBgMediaStorageKey;
        }
        valuesObj.pageBgGlassEnabled = s.glassEnabled ? 'true' : 'false';
        valuesObj.pageBgGlassOpacity = String(Math.round(s.glassOpacity));
        valuesObj.pageBgGlassBlurPx = String(normalizePersonalGlassBlurPx(s.glassBlurPx));
        valuesObj.pageTextColorOverrideEnabled = s.textOverrideEnabled ? 'true' : 'false';
        valuesObj.pageTextColorHue = String(Math.round(s.textHue));
        valuesObj.pageTextColorSat = String(Math.round(s.textSat));
        valuesObj.pageTextColorLight = String(Math.round(s.textLight));
        writePersonalBgMediaHistoryToValues(valuesObj, s.mediaHistory || []);
        return valuesObj;
    }

    function personalBackgroundToCssColor(state){
        const s = clonePersonalBackgroundState(state);
        return `hsl(${Math.round(s.hue)} ${Math.round(s.sat)}% ${Math.round(s.light)}%)`;
    }

    function personalTextColorToCssColor(state){
        const s = clonePersonalBackgroundState(state);
        return `hsl(${Math.round(s.textHue)} ${Math.round(s.textSat)}% ${Math.round(s.textLight)}%)`;
    }

    function personalTextMutedColorToCssColor(state){
        const s = clonePersonalBackgroundState(state);
        const sat = Math.max(0, Math.min(100, Math.round(s.textSat * 0.65)));
        const lightBase = Math.round(s.textLight);
        const light = lightBase >= 50
            ? Math.max(0, Math.min(100, lightBase - 16))
            : Math.max(0, Math.min(100, lightBase + 16));
        return `hsl(${Math.round(s.textHue)} ${sat}% ${light}%)`;
    }

    function applyPersonalTextOverrideState(state, opts = {}){
        const previewMode = !!opts.preview;
        const forceOn = !!opts.forceOn;
        const s = clonePersonalBackgroundState(state);
        const shouldUseCustom = forceOn || previewMode || isPersonalCustomizationEnabled();
        const enabled = shouldUseCustom && !!s.textOverrideEnabled;
        if (!enabled) {
            document.body.classList.remove('personal-text-override-active');
            document.body.style.removeProperty('--text');
            document.body.style.removeProperty('--muted');
            return;
        }
        document.body.style.setProperty('--text', personalTextColorToCssColor(s));
        document.body.style.setProperty('--muted', personalTextMutedColorToCssColor(s));
        document.body.classList.add('personal-text-override-active');
    }

    function setPersonalRenameControlsOpen(isOpen){
        personalRenameControlsOpen = !!isOpen;
        if (personalRenameControlsWrapEl) {
            personalRenameControlsWrapEl.classList.toggle('is-open', personalRenameControlsOpen);
            personalRenameControlsWrapEl.setAttribute('aria-hidden', String(!personalRenameControlsOpen));
        }
        if (personalRenameControlsToggleButtonEl) {
            personalRenameControlsToggleButtonEl.classList.toggle('active', personalRenameControlsOpen);
            personalRenameControlsToggleButtonEl.setAttribute('aria-pressed', String(personalRenameControlsOpen));
        }
    }

    function setPersonalBgControlsOpen(isOpen){
        personalBgControlsOpen = !!isOpen;
        if (personalBgControlsWrapEl) {
            personalBgControlsWrapEl.classList.toggle('is-open', personalBgControlsOpen);
            personalBgControlsWrapEl.setAttribute('aria-hidden', String(!personalBgControlsOpen));
        }
        if (personalBgCustomizeButtonEl) {
            personalBgCustomizeButtonEl.classList.toggle('active', personalBgControlsOpen);
            personalBgCustomizeButtonEl.setAttribute('aria-pressed', String(personalBgControlsOpen));
        }
        if (!personalBgControlsOpen) setPersonalFruitigerArchiveOpen(false);
    }

    function setPersonalBgColorControlsOpen(isOpen){
        personalBgColorControlsOpen = !!isOpen;
        if (personalBgColorControlsEl) personalBgColorControlsEl.classList.toggle('is-open', personalBgColorControlsOpen);
    }

    function setPersonalBgTextColorControlsOpen(isOpen){
        personalBgTextColorControlsOpen = !!isOpen;
        if (personalBgTextColorControlsEl) {
            personalBgTextColorControlsEl.classList.toggle('is-open', personalBgTextColorControlsOpen);
            personalBgTextColorControlsEl.setAttribute('aria-hidden', String(!personalBgTextColorControlsOpen));
        }
    }

    function setPersonalBgGlassControlsOpen(isOpen){
        personalBgGlassControlsOpen = !!isOpen;
        personalBgGlassControlsOpenInitialized = true;
        if (personalBgGlassControlsEl) {
            personalBgGlassControlsEl.classList.toggle('is-open', personalBgGlassControlsOpen);
            personalBgGlassControlsEl.setAttribute('aria-hidden', String(!personalBgGlassControlsOpen));
        }
    }

    function applyPersonalGlassModeState(state, opts = {}){
        const previewMode = !!opts.preview;
        const forceOn = !!opts.forceOn;
        const s = clonePersonalBackgroundState(state);
        const shouldUseCustom = forceOn || previewMode || isPersonalCustomizationEnabled();
        const enabled = shouldUseCustom && !!s.glassEnabled;
        if (!enabled) {
            document.body.classList.remove('glass-mode-active');
            document.body.classList.remove('glass-solid-active');
            syncPersonalOverlayBackdropStrongBlur();
            return;
        }
        const opacityPct = Math.max(0, Math.min(100, Number(s.glassOpacity)));
        const solidMode = opacityPct <= 0;
        // 0% = solid, 100% = mest gjennomsiktig
        const alpha = 1 - (opacityPct / 100);
        const borderAlpha = Math.max(0.14, Math.min(0.85, alpha + 0.12));
        const blurPx = solidMode ? 0 : normalizePersonalGlassBlurPx(s.glassBlurPx);
        document.body.style.setProperty('--glass-ui-alpha', alpha.toFixed(3));
        document.body.style.setProperty('--glass-border-alpha', borderAlpha.toFixed(3));
        document.body.style.setProperty('--glass-ui-blur', `${blurPx}px`);
        document.body.classList.add('glass-mode-active');
        document.body.classList.toggle('glass-solid-active', solidMode);
        syncPersonalOverlayBackdropStrongBlur();
    }

    let personalGlassOpacityPreviewRaf = 0;
    function schedulePersonalGlassOpacityPreview(state){
        const nextState = clonePersonalBackgroundState(state);
        if (personalGlassOpacityPreviewRaf) {
            try { cancelAnimationFrame(personalGlassOpacityPreviewRaf); } catch(e){}
            personalGlassOpacityPreviewRaf = 0;
        }
        const runner = () => {
            personalGlassOpacityPreviewRaf = 0;
            applyPersonalGlassModeState(nextState, { preview: true, forceOn: true });
        };
        if (typeof requestAnimationFrame === 'function') {
            personalGlassOpacityPreviewRaf = requestAnimationFrame(runner);
        } else {
            runner();
        }
    }

    function updatePersonalBgPreviewChip(){
        if (!personalBgPreviewChipEl) return;
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
        if (s.type === 'color') {
            personalBgPreviewChipEl.style.background = personalBackgroundToCssColor(s);
            personalBgPreviewChipEl.textContent = `Farge (${Math.round(s.hue)}° / ${Math.round(s.sat)}% / ${Math.round(s.light)}%)`;
        } else if (s.type === 'image') {
            personalBgPreviewChipEl.style.background = 'linear-gradient(135deg, rgba(59,130,246,0.9), rgba(16,185,129,0.8))';
            personalBgPreviewChipEl.textContent = 'Bilde valgt';
        } else if (s.type === 'video') {
            personalBgPreviewChipEl.style.background = 'linear-gradient(135deg, rgba(168,85,247,0.9), rgba(244,63,94,0.8))';
            personalBgPreviewChipEl.textContent = 'Video valgt';
        } else {
            personalBgPreviewChipEl.style.background = 'var(--bg)';
            personalBgPreviewChipEl.textContent = 'Ingen egendefinert bakgrunn';
        }
    }

    function setPersonalBgMediaHistoryOpen(isOpen){
        personalBgMediaHistoryOpen = !!isOpen;
        if (personalCustomizeOverlayEl) {
            personalCustomizeOverlayEl.classList.toggle('history-only', personalBgMediaHistoryOpen);
        }
        if (!personalBgMediaHistoryDropdownEl) return;
        personalBgMediaHistoryDropdownEl.classList.toggle('is-open', personalBgMediaHistoryOpen);
        personalBgMediaHistoryDropdownEl.setAttribute('aria-hidden', String(!personalBgMediaHistoryOpen));
    }

    function upsertMediaHistoryInDraft(kind, dataUrl, fileName){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        const entry = normalizePersonalBgMediaHistoryEntry({ kind, dataUrl, name: fileName || (kind === 'video' ? 'Video' : 'Bilde'), addedAt: Date.now() });
        if (!entry) return s;
        const nextRaw = [entry].concat((s.mediaHistory || []).filter(item => !(item && item.dataUrl === entry.dataUrl && item.kind === entry.kind)));
        s.mediaHistory = limitPersonalBgMediaHistoryList(nextRaw);
        personalCustomizeBackgroundDraft = s;
        try {
            if (!personalCustomizationValues || typeof personalCustomizationValues !== 'object') personalCustomizationValues = {};
            // Lagre historikk umiddelbart slik at den ikke forsvinner hvis popupen lukkes uten OK
            writePersonalBgMediaHistoryToValues(personalCustomizationValues, s.mediaHistory || []);
            savePersonalCustomizationValues();
        } catch(e){}
        return s;
    }

    function clearPersonalBgMediaHistoryEverywhere(){
        const draft = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        draft.mediaHistory = [];
        personalCustomizeBackgroundDraft = draft;
        if (!personalCustomizationValues || typeof personalCustomizationValues !== 'object') {
            personalCustomizationValues = {};
        }
        writePersonalBgMediaHistoryToValues(personalCustomizationValues, []);
        savePersonalCustomizationValues();
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(draft, { preview: true, forceOn: true });
    }

    function renderPersonalBgMediaHistoryDropdown(){
        if (!personalBgMediaHistoryDropdownEl) return;
        personalBgMediaHistoryDropdownEl.innerHTML = '';
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
        const historyAll = Array.isArray(s.mediaHistory) ? limitPersonalBgMediaHistoryList(s.mediaHistory) : [];
        const images = historyAll.filter(h => h && h.kind === 'image');
        const videos = historyAll.filter(h => h && h.kind === 'video');

        if (!images.length && !videos.length) {
            const empty = document.createElement('div');
            empty.className = 'personal-bg-media-history-empty';
            empty.textContent = 'Ingen lagret historikk ennå';
            personalBgMediaHistoryDropdownEl.appendChild(empty);
            return;
        }

        const grid = document.createElement('div');
        grid.className = 'personal-bg-media-history-grid';

        const colImg = document.createElement('div');
        const colVid = document.createElement('div');

        const imgTitle = document.createElement('div');
        imgTitle.className = 'personal-bg-media-history-col-title';
        imgTitle.textContent = 'Bilder';
        colImg.appendChild(imgTitle);

        const vidTitle = document.createElement('div');
        vidTitle.className = 'personal-bg-media-history-col-title';
        vidTitle.textContent = 'Video';
        colVid.appendChild(vidTitle);

        const makeItemButton = (normalized) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'personal-bg-media-history-item thumb-only';

            const thumb = document.createElement('span');
            thumb.className = 'personal-bg-media-history-thumb';
            if (normalized.kind === 'image') {
                const img = document.createElement('img');
                img.alt = '';
                img.src = normalized.dataUrl;
                thumb.appendChild(img);
            } else {
                const v = document.createElement('video');
                v.muted = true;
                v.playsInline = true;
                v.preload = 'metadata';
                v.src = normalized.dataUrl;
                thumb.appendChild(v);
            }

            btn.appendChild(thumb);

            btn.addEventListener('click', () => {
                const d = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
                d.type = normalized.kind;
                d.mediaKind = normalized.kind;
                d.mediaDataUrl = normalized.dataUrl;
                const nextRaw = [normalized].concat((d.mediaHistory || []).filter(h => !(h && h.dataUrl === normalized.dataUrl && h.kind === normalized.kind)));
                d.mediaHistory = limitPersonalBgMediaHistoryList(nextRaw);
                d.glassEnabled = true;
                d.glassOpacity = 20;
                d.glassBlurPx = 1;
                personalCustomizeBackgroundDraft = d;
                try { applyThemeMode('dark'); } catch(e){}
                setPersonalBgControlsOpen(true);
                renderPersonalBackgroundUiFromDraft();
                applyPersonalBackgroundState(d, { preview: true, forceOn: true });
                setPersonalBgMediaHistoryOpen(false);
            });

            return btn;
        };

        images.forEach(item => {
            const normalized = normalizePersonalBgMediaHistoryEntry(item);
            if (!normalized) return;
            colImg.appendChild(makeItemButton(normalized));
        });

        videos.forEach(item => {
            const normalized = normalizePersonalBgMediaHistoryEntry(item);
            if (!normalized) return;
            colVid.appendChild(makeItemButton(normalized));
        });

        const divider = document.createElement('div');
        divider.className = 'personal-bg-media-history-divider';

        grid.appendChild(colImg);
        grid.appendChild(divider);
        grid.appendChild(colVid);
        personalBgMediaHistoryDropdownEl.appendChild(grid);
    }

    function renderPersonalTextUiFromDraftFast(){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
        personalCustomizeBackgroundDraft = s;
        if (personalTextHueRangeEl) personalTextHueRangeEl.value = String(Math.round(s.textHue));
        if (personalTextSatRangeEl) personalTextSatRangeEl.value = String(Math.round(s.textSat));
        if (personalTextLightRangeEl) personalTextLightRangeEl.value = String(Math.round(s.textLight));
        if (personalTextHueValueEl) personalTextHueValueEl.textContent = String(Math.round(s.textHue));
        if (personalTextSatValueEl) personalTextSatValueEl.textContent = `${Math.round(s.textSat)}%`;
        if (personalTextLightValueEl) personalTextLightValueEl.textContent = `${Math.round(s.textLight)}%`;
        if (personalTextPreviewChipEl) {
            const tc = personalTextColorToCssColor(s);
            personalTextPreviewChipEl.style.background = tc;
            personalTextPreviewChipEl.style.color = (Math.round(s.textLight) > 55) ? '#111827' : '#f9fafb';
            personalTextPreviewChipEl.textContent = s.textOverrideEnabled
                ? `Tekstfarge (${Math.round(s.textHue)}° / ${Math.round(s.textSat)}% / ${Math.round(s.textLight)}%)`
                : 'Tekstfarge overstyring er av';
        }
        if (personalBgTextColorButtonEl) {
            personalBgTextColorButtonEl.classList.toggle('active', !!s.textOverrideEnabled);
            personalBgTextColorButtonEl.setAttribute('aria-pressed', String(!!s.textOverrideEnabled));
        }
        setPersonalBgTextColorControlsOpen(!!s.textOverrideEnabled);
    }

    function renderPersonalBackgroundUiFromDraft(){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
        personalCustomizeBackgroundDraft = s;
        if (personalBgHueRangeEl) personalBgHueRangeEl.value = String(Math.round(s.hue));
        if (personalBgSatRangeEl) personalBgSatRangeEl.value = String(Math.round(s.sat));
        if (personalBgLightRangeEl) personalBgLightRangeEl.value = String(Math.round(s.light));
        if (personalBgHueValueEl) personalBgHueValueEl.textContent = String(Math.round(s.hue));
        if (personalBgSatValueEl) personalBgSatValueEl.textContent = `${Math.round(s.sat)}%`;
        if (personalBgLightValueEl) personalBgLightValueEl.textContent = `${Math.round(s.light)}%`;
        if (personalBgMediaStatusEl) {
            if (s.type === 'image' && s.mediaDataUrl) personalBgMediaStatusEl.textContent = 'Bilde valgt og klart for lagring';
            else if (s.type === 'video' && s.mediaDataUrl) personalBgMediaStatusEl.textContent = 'Video valgt og klart for lagring';
            else if (s.mediaDataUrl) personalBgMediaStatusEl.textContent = 'Media er valgt';
            else personalBgMediaStatusEl.textContent = 'Ingen bilde/video valgt';
        }
        if (personalBgGlassOpacityRangeEl) personalBgGlassOpacityRangeEl.value = String(Math.round(s.glassOpacity));
        if (personalBgGlassOpacityValueEl) personalBgGlassOpacityValueEl.textContent = `${Math.round(s.glassOpacity)}%`;
        const blurPx = normalizePersonalGlassBlurPx(s.glassBlurPx);
        const glassOn = !!s.glassEnabled;

        if (personalBgBlurOffButtonEl) {
            const on = !glassOn;
            personalBgBlurOffButtonEl.classList.toggle('active', on);
            personalBgBlurOffButtonEl.setAttribute('aria-pressed', String(on));
        }

        if (personalBgBlurFastButtonEl) {
            const on = glassOn && blurPx === 1;
            personalBgBlurFastButtonEl.classList.toggle('active', on);
            personalBgBlurFastButtonEl.setAttribute('aria-pressed', String(on));
        }
        if (personalBgBlurPrettyButtonEl) {
            const on = glassOn && blurPx === 12;
            personalBgBlurPrettyButtonEl.classList.toggle('active', on);
            personalBgBlurPrettyButtonEl.setAttribute('aria-pressed', String(on));
        }
        if (personalBgBlurHeavyButtonEl) {
            const on = glassOn && blurPx === 24;
            personalBgBlurHeavyButtonEl.classList.toggle('active', on);
            personalBgBlurHeavyButtonEl.setAttribute('aria-pressed', String(on));
        }

        if (personalBgGlassOpacityRangeEl) {
            personalBgGlassOpacityRangeEl.disabled = !glassOn;
        }
        if (personalBgGlassOpacityValueEl) {
            personalBgGlassOpacityValueEl.textContent = glassOn ? `${Math.round(s.glassOpacity)}%` : 'AV';
        }

if (personalTextHueRangeEl) personalTextHueRangeEl.value = String(Math.round(s.textHue));
        if (personalTextSatRangeEl) personalTextSatRangeEl.value = String(Math.round(s.textSat));
        if (personalTextLightRangeEl) personalTextLightRangeEl.value = String(Math.round(s.textLight));
        if (personalTextHueValueEl) personalTextHueValueEl.textContent = String(Math.round(s.textHue));
        if (personalTextSatValueEl) personalTextSatValueEl.textContent = `${Math.round(s.textSat)}%`;
        if (personalTextLightValueEl) personalTextLightValueEl.textContent = `${Math.round(s.textLight)}%`;
        if (personalTextPreviewChipEl) {
            const tc = personalTextColorToCssColor(s);
            personalTextPreviewChipEl.style.background = tc;
            personalTextPreviewChipEl.style.color = (Math.round(s.textLight) > 55) ? '#111827' : '#f9fafb';
            personalTextPreviewChipEl.textContent = s.textOverrideEnabled
                ? `Tekstfarge (${Math.round(s.textHue)}° / ${Math.round(s.textSat)}% / ${Math.round(s.textLight)}%)`
                : 'Tekstfarge overstyring er av';
        }
        if (personalBgGlassButtonEl) {
            personalBgGlassButtonEl.classList.toggle('active', !!s.glassEnabled);
            personalBgGlassButtonEl.setAttribute('aria-pressed', String(!!s.glassEnabled));
        }
        if (personalBgTextColorButtonEl) {
            personalBgTextColorButtonEl.classList.toggle('active', !!s.textOverrideEnabled);
            personalBgTextColorButtonEl.setAttribute('aria-pressed', String(!!s.textOverrideEnabled));
        }
        if (personalFruitigerArchiveButtonEl) {
            personalFruitigerArchiveButtonEl.classList.toggle('active', !!personalFruitigerArchiveOpen);
            personalFruitigerArchiveButtonEl.setAttribute('aria-pressed', String(!!personalFruitigerArchiveOpen));
        }
        if (personalBgColorButtonEl) {
            personalBgColorButtonEl.classList.toggle('active', !!personalBgColorControlsOpen);
            personalBgColorButtonEl.setAttribute('aria-pressed', String(!!personalBgColorControlsOpen));
        }
        if (!personalBgGlassControlsOpenInitialized) {
            personalBgGlassControlsOpen = !!s.glassEnabled;
            personalBgGlassControlsOpenInitialized = true;
        }
        setPersonalBgGlassControlsOpen(!!personalBgGlassControlsOpen);
        setPersonalBgTextColorControlsOpen(!!s.textOverrideEnabled);
        setPersonalFruitigerArchiveOpen(!!personalFruitigerArchiveOpen);
        const showAutoSwap = (s.type === 'image' && !!s.mediaDataUrl);
        if (personalBgAutoSwapWrapEl) {
            personalBgAutoSwapWrapEl.style.display = showAutoSwap ? '' : 'none';
            personalBgAutoSwapWrapEl.setAttribute('aria-hidden', String(!showAutoSwap));
        }
        if (showAutoSwap) {
            updatePersonalFruitigerArchiveIntervalUi();
            setPersonalFruitigerArchiveModeToggle(personalFruitigerArchiveHistoryMode ? 'history' : (personalFruitigerArchiveRandomCategoryMode ? 'random' : 'same'));
        }
        renderPersonalBgMediaHistoryDropdown();
        updatePersonalBgPreviewChip();
    }


    function setPersonalFruitigerArchiveOpen(isOpen){
        personalFruitigerArchiveOpen = !!isOpen;
        if (personalFruitigerArchivePanelEl) {
            personalFruitigerArchivePanelEl.classList.toggle('is-open', personalFruitigerArchiveOpen);
            personalFruitigerArchivePanelEl.setAttribute('aria-hidden', String(!personalFruitigerArchiveOpen));
        }
        if (personalFruitigerArchiveButtonEl) {
            personalFruitigerArchiveButtonEl.classList.toggle('active', personalFruitigerArchiveOpen);
            personalFruitigerArchiveButtonEl.setAttribute('aria-pressed', String(personalFruitigerArchiveOpen));
        }
        if (personalFruitigerArchiveOpen) {
            updatePersonalFruitigerArchiveIntervalUi();
            setPersonalFruitigerArchiveModeToggle(personalFruitigerArchiveHistoryMode ? 'history' : (personalFruitigerArchiveRandomCategoryMode ? 'random' : 'same'));
            if (personalFruitigerArchiveAutoRunning) schedulePersonalFruitigerArchiveAutoRotation();
        }
    }

    function setPersonalFruitigerArchiveStatus(msg, opts = {}){
        if (!personalFruitigerArchiveStatusEl) return;
        const loading = !!(opts && opts.loading);
        personalFruitigerArchiveStatusEl.classList.toggle('is-loading', loading);
        personalFruitigerArchiveStatusEl.textContent = msg || '';
    }

    function escapeHtmlText(text){
        return String(text == null ? '' : text)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    function setPersonalFruitigerArchiveStatusWithCategory(categoryLabel, suffixText){
        if (!personalFruitigerArchiveStatusEl) return;
        personalFruitigerArchiveStatusEl.classList.remove('is-loading');
        const safeCat = escapeHtmlText(categoryLabel || '');
        const safeSuffix = escapeHtmlText(suffixText || '');
        personalFruitigerArchiveStatusEl.innerHTML = `Bakgrunn satt fra «<span class="status-category">${safeCat}</span>». ${safeSuffix}`;
    }

    function updatePersonalFruitigerArchiveIntervalUi(){
        const secRaw = Number(personalFruitigerArchiveAutoIntervalSec || 0);
        const sec = Math.max(0, Math.min(600, Number.isFinite(secRaw) ? secRaw : 45));
        if (personalFruitigerArchiveIntervalValueEl) {
            let display = 'AV';
            if (sec > 0) {
                display = sec >= 60 ? `${(sec / 60).toFixed(sec % 60 === 0 ? 0 : 1)}m` : `${sec}s`;
            }
            personalFruitigerArchiveIntervalValueEl.textContent = display;
        }
        if (personalFruitigerArchiveIntervalRangeEl) {
            personalFruitigerArchiveIntervalRangeEl.value = String(sec);
        }
    }

    function setPersonalFruitigerArchiveModeToggle(mode){
        const m = String(mode || '').toLowerCase();
        if (m === 'historikk' || m === 'history') {
            personalFruitigerArchiveHistoryMode = true;
            personalFruitigerArchiveRandomCategoryMode = false;
        } else if (m === 'tilfeldig' || m === 'random') {
            personalFruitigerArchiveHistoryMode = false;
            personalFruitigerArchiveRandomCategoryMode = true;
        } else {
            personalFruitigerArchiveHistoryMode = false;
            personalFruitigerArchiveRandomCategoryMode = false;
        }
        if (personalFruitigerArchiveModeToggleEl) {
            personalFruitigerArchiveModeToggleEl.textContent = personalFruitigerArchiveHistoryMode ? 'Historikk'
                : (personalFruitigerArchiveRandomCategoryMode ? 'Tilfeldig kategori' : 'Samme kategori');
            const pressed = personalFruitigerArchiveHistoryMode || personalFruitigerArchiveRandomCategoryMode;
            personalFruitigerArchiveModeToggleEl.setAttribute('aria-pressed', String(pressed));
            personalFruitigerArchiveModeToggleEl.classList.toggle('active', pressed);
        }
    }


    function clearPersonalFruitigerArchiveAutoTimer(){
        if (personalFruitigerArchiveAutoTimer) {
            clearTimeout(personalFruitigerArchiveAutoTimer);
            personalFruitigerArchiveAutoTimer = null;
        }
    }

    function getPersonalFruitigerArchiveSelectedCategory(){
        if (!personalFruitigerArchiveSelectedCategoryHref || !Array.isArray(personalFruitigerArchiveCategories)) return null;
        return personalFruitigerArchiveCategories.find(c => c && c.href === personalFruitigerArchiveSelectedCategoryHref) || null;
    }

    function getRandomFruitigerArchiveCategory(){
        const list = Array.isArray(personalFruitigerArchiveCategories) ? personalFruitigerArchiveCategories.filter(Boolean) : [];
        if (!list.length) return null;
        return list[Math.floor(Math.random() * list.length)] || null;
    }

    function stopPersonalFruitigerArchiveAutoRotation(opts = {}){
        clearPersonalFruitigerArchiveAutoTimer();
        personalFruitigerArchiveAutoRunning = false;
        personalFruitigerArchiveAutoBusy = false;
        personalFruitigerArchiveAutoRunToken += 1;
        if (opts && opts.clearSelection) personalFruitigerArchiveSelectedCategoryHref = '';
    }

    function getPersonalBgHistoryImagesForAuto(){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
        const raw = Array.isArray(s.mediaHistory) ? s.mediaHistory : [];
        return raw.map(item => normalizePersonalBgMediaHistoryEntry(item)).filter(h => h && h.kind === 'image' && h.dataUrl);
    }

    function applyPersonalBgHistoryAutoImage(dataUrl){
        const url = String(dataUrl || '').trim();
        if (!url) return;
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
        s.type = 'image';
        s.mediaKind = 'image';
        s.mediaDataUrl = url;
        personalCustomizeBackgroundDraft = s;
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(s, { preview: true, forceOn: true });
    }

    function schedulePersonalFruitigerArchiveAutoRotation(){
        clearPersonalFruitigerArchiveAutoTimer();
        if (!personalFruitigerArchiveAutoRunning) return;
        const sec = Math.max(0, Math.min(600, Number(personalFruitigerArchiveAutoIntervalSec || 0)));
        if (sec <= 0) return;
        const delay = sec * 1000;
        const runToken = personalFruitigerArchiveAutoRunToken;
        personalFruitigerArchiveAutoTimer = setTimeout(async () => {
            if (!personalFruitigerArchiveAutoRunning || personalFruitigerArchiveAutoBusy) return;
            if (runToken !== personalFruitigerArchiveAutoRunToken) return;
            personalFruitigerArchiveAutoBusy = true;
            try {
                if (personalFruitigerArchiveHistoryMode) {
                    const list = getPersonalBgHistoryImagesForAuto();
                    if (!list.length) return;
                    const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues));
                    const current = (s.type === 'image' && s.mediaDataUrl) ? String(s.mediaDataUrl) : '';
                    let next = null;

                    const currentIdx = list.findIndex(h => String(h.dataUrl) === current);
                    if (list.length === 1) {
                        next = list[0];
                    } else if (currentIdx >= 0) {
                        next = list[(currentIdx + 1) % list.length];
                    } else {
                        next = list[0];
                    }

                    if (next && String(next.dataUrl || '') && String(next.dataUrl) !== current) {
                        personalBgHistoryAutoLastDataUrl = String(next.dataUrl);
                        applyPersonalBgHistoryAutoImage(next.dataUrl);
                    }
                    return;
                }

                let cat = null;
                if (personalFruitigerArchiveRandomCategoryMode) {
                    cat = getRandomFruitigerArchiveCategory();
                } else {
                    cat = getPersonalFruitigerArchiveSelectedCategory() || getRandomFruitigerArchiveCategory();
                }

                if (cat) {
                    await applyRandomFruitigerArchiveImage(cat, { fromAuto: true, runToken });
                }
            } catch(e) {
            } finally {
                personalFruitigerArchiveAutoBusy = false;
                if (personalFruitigerArchiveAutoRunning && runToken === personalFruitigerArchiveAutoRunToken) schedulePersonalFruitigerArchiveAutoRotation();
            }
        }, delay);
    }

    function startPersonalFruitigerArchiveAutoRotation(selectedCategory){
        if (selectedCategory && selectedCategory.href) personalFruitigerArchiveSelectedCategoryHref = selectedCategory.href;
        if (personalFruitigerArchiveHistoryMode) {
            const list = getPersonalBgHistoryImagesForAuto();
            if (!list.length) return;
        } else if (!personalFruitigerArchiveSelectedCategoryHref && !personalFruitigerArchiveRandomCategoryMode) return;
        const sec = Math.max(0, Math.min(600, Number(personalFruitigerArchiveAutoIntervalSec || 0)));
        if (sec <= 0) {
            stopPersonalFruitigerArchiveAutoRotation();
            return;
        }
        personalFruitigerArchiveAutoRunToken += 1;
        personalFruitigerArchiveAutoRunning = true;
        schedulePersonalFruitigerArchiveAutoRotation();
    }

    function renderPersonalFruitigerArchiveList(){
        if (!personalFruitigerArchiveListEl) return;
        personalFruitigerArchiveListEl.innerHTML = '';
        if (!Array.isArray(personalFruitigerArchiveCategories) || !personalFruitigerArchiveCategories.length) {
            const empty = document.createElement('div');
            empty.className = 'personal-bg-media-history-empty';
            empty.textContent = personalFruitigerArchiveLoading ? 'Laster kategorier…' : 'Ingen kategorier funnet ennå.';
            personalFruitigerArchiveListEl.appendChild(empty);
            return;
        }
        personalFruitigerArchiveCategories.forEach((cat, idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'personal-bg-archive-item';
            btn.textContent = cat && cat.label ? cat.label : `Kategori ${idx + 1}`;
            btn.dataset.archiveIndex = String(idx);
            btn.addEventListener('click', async () => {
                const selected = personalFruitigerArchiveCategories[idx];
                if (!selected) return;
                const allBtns = personalFruitigerArchiveListEl.querySelectorAll('button.personal-bg-archive-item');
                allBtns.forEach(b => b.disabled = true);
                try {
                    await applyRandomFruitigerArchiveImage(selected);
                    startPersonalFruitigerArchiveAutoRotation(selected);
                } finally {
                    allBtns.forEach(b => b.disabled = false);
                }
            });
            personalFruitigerArchiveListEl.appendChild(btn);
        });
    }

    async function applyDefaultFruitigerArchiveCategoryIfNeeded(){
        // Standardvalg når panelet åpnes: "Asadal Stock Images"
        // Overstyrer ikke dersom brukeren allerede har valgt en kategori tidligere.
        if (!Array.isArray(personalFruitigerArchiveCategories) || !personalFruitigerArchiveCategories.length) return;
        const existing = getPersonalFruitigerArchiveSelectedCategory();
        if (existing) return;

        const target = personalFruitigerArchiveCategories.find(c => {
            const label = String(c && c.label || '').trim().toLowerCase();
            return label === 'asadal stock images' || label.includes('asadal stock images');
        });
        if (!target || !target.href) return;

        personalFruitigerArchiveSelectedCategoryHref = target.href;
        const sec = Math.max(0, Math.min(600, Number(personalFruitigerArchiveAutoIntervalSec || 0)));
        if (sec <= 0) {
            setPersonalFruitigerArchiveStatus(`Standardkategori valgt: «${target.label || 'Asadal Stock Images'}». Auto-bytte er av.`);
            return;
        }

        try {
            await applyRandomFruitigerArchiveImage(target);
            startPersonalFruitigerArchiveAutoRotation(target);
        } catch(e){}
    }


    async function fetchTextWithFallbacks(targetUrl){
        const cleanUrl = String(targetUrl || '').trim();
        if (!cleanUrl) throw new Error('Mangler URL');
        const attempts = [
            cleanUrl,
            `https://api.allorigins.win/raw?url=${encodeURIComponent(cleanUrl)}`,
            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(cleanUrl)}`,
            `https://r.jina.ai/http://${cleanUrl.replace(/^https?:\/\//i, '')}`
        ];
        let lastErr = null;
        for (const candidate of attempts) {
            try {
                const ctrl = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                const t = ctrl ? setTimeout(() => ctrl.abort(), 12000) : null;
                const res = await fetch(candidate, { mode: 'cors', cache: 'no-store', signal: ctrl ? ctrl.signal : undefined });
                if (t) clearTimeout(t);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const txt = await res.text();
                if (!txt || !txt.trim()) throw new Error('Tom respons');
                return { text: txt, via: candidate };
            } catch (err) {
                lastErr = err;
            }
        }
        throw lastErr || new Error('Kunne ikke hente innhold');
    }

    function parseHtmlDocumentFromText(rawText){
        const parser = new DOMParser();
        return parser.parseFromString(String(rawText || ''), 'text/html');
    }

    function collectAnchorsFromMarkdownLikeText(rawText, baseUrl){
        const text = String(rawText || '');
        const out = [];
        const seen = new Set();
        const push = (label, href) => {
            try {
                const abs = new URL(href, baseUrl).toString();
                const key = abs;
                if (!seen.has(key)) {
                    seen.add(key);
                    out.push({ label: (label || '').trim(), href: abs, originalHref: href });
                }
            } catch(e){}
        };
        const mdRe = /\[([^\]]{1,160})\]\((https?:\/\/[^)\s]+|\/[^)\s]+|#[^)\s]+)\)/g;
        let m;
        while ((m = mdRe.exec(text))) push(m[1], m[2]);
        const urlRe = /https?:\/\/[^\s"'<>)]{5,}/g;
        while ((m = urlRe.exec(text))) push('', m[0]);
        return out;
    }

    function normalizeFruitigerCategoryLabel(raw, href){
        let label = (raw || '').replace(/\s+/g, ' ').trim();
        if (!label) {
            try {
                const u = new URL(href);
                label = decodeURIComponent((u.hash || '').replace(/^#/, '') || u.pathname.split('/').filter(Boolean).pop() || 'Kategori');
            } catch(e){ label = 'Kategori'; }
        }
        label = label.replace(/^\d+[.)\-\s]+/, '').trim();
        if (label.length > 80) label = label.slice(0, 80).trim() + '…';
        return label || 'Kategori';
    }

    function extractFruitigerCategoriesFromText(rawText, baseUrl){
        const doc = parseHtmlDocumentFromText(rawText);
        const links = [];
        const seen = new Set();
        const pushLink = (a) => {
            if (!a) return;
            const hrefRaw = (a.getAttribute && a.getAttribute('href')) ? a.getAttribute('href').trim() : '';
            if (!hrefRaw || hrefRaw.startsWith('mailto:') || hrefRaw.startsWith('javascript:')) return;
            let abs = '';
            try { abs = new URL(hrefRaw, baseUrl).toString(); } catch(e){ return; }
            const sameSite = /^https?:\/\/frutigeraeroarchive\.org\//i.test(abs);
            const isWall = /\/wallpapers(\/|$|#|\?)/i.test(abs);
            if (!sameSite || !isWall) return;
            const textLabel = (a.textContent || (a.getAttribute && a.getAttribute('title')) || '').trim();
            const key = abs;
            if (seen.has(key)) return;
            seen.add(key);
            links.push({ label: normalizeFruitigerCategoryLabel(textLabel, abs), href: abs });
        };

        let tocRoot = doc.querySelector('#table-of-contents, .table-of-contents, nav[aria-label*="Table" i], nav[aria-label*="Contents" i], [id*="toc" i], [class*="toc" i]');
        if (!tocRoot) {
            const headings = Array.from(doc.querySelectorAll('h1,h2,h3,h4,strong'));
            const tocHeading = headings.find(h => /table\s+of\s+contents/i.test((h.textContent || '').trim()));
            if (tocHeading) tocRoot = tocHeading.parentElement || tocHeading;
        }
        if (tocRoot) tocRoot.querySelectorAll('a[href]').forEach(pushLink);
        if (!links.length) doc.querySelectorAll('a[href]').forEach(pushLink);
        if (!links.length) {
            const mdAnchors = collectAnchorsFromMarkdownLikeText(rawText, baseUrl);
            mdAnchors.forEach(item => {
                const pseudoAnchor = {
                    getAttribute: (k) => (k === 'href' ? (item.originalHref || item.href) : ''),
                    textContent: item.label || ''
                };
                pushLink(pseudoAnchor);
            });
        }
        const filtered = links.filter(item => {
            try {
                const u = new URL(item.href);
                const path = u.pathname.replace(/\/+$/,'');
                if (path === '/wallpapers' && !u.hash) return false;
                return true;
            } catch(e){ return false; }
        });
        return (filtered.length ? filtered : links).slice(0, 120);
    }

    function estimateUrlResolutionHint(urlStr){
        const s = String(urlStr || '');
        let score = 0;
        const sizeMatch = s.match(/(?:^|[\/_-])(\d{2,5})x(\d{2,5})(?=\.(?:jpe?g|png|webp|gif|bmp|avif)(?:[?#]|$))/i);
        if (sizeMatch) {
            const w = Number(sizeMatch[1]) || 0;
            const h = Number(sizeMatch[2]) || 0;
            score += Math.min((w * h) / 50, 120000);
        }
        try {
            const u = new URL(s);
            const keys = ['w', 'width', 'mw', 'maxwidth', 'h', 'height'];
            keys.forEach(k => {
                const v = Number(u.searchParams.get(k) || 0);
                if (v > 0) score += Math.min(v * 5, 25000);
            });
            const q = Number(u.searchParams.get('q') || u.searchParams.get('quality') || 0);
            if (q > 0) score += Math.min(q * 10, 1000);
        } catch(e){}
        return score;
    }


    function parseExplicitResolutionFromUrl(urlStr){
        const s = String(urlStr || '');
        const out = { w: 0, h: 0 };
        const m = s.match(/(?:^|[\/_-])(\d{2,5})x(\d{2,5})(?=\.(?:jpe?g|png|webp|gif|bmp|avif)(?:[?#]|$))/i);
        if (m) {
            out.w = Number(m[1]) || 0;
            out.h = Number(m[2]) || 0;
            return out;
        }
        try {
            const u = new URL(s, window.location.href);
            out.w = Number(u.searchParams.get('w') || u.searchParams.get('width') || 0) || 0;
            out.h = Number(u.searchParams.get('h') || u.searchParams.get('height') || 0) || 0;
        } catch(e){}
        return out;
    }

    function isLowQualityFruitigerCandidateUrl(urlStr){
        const s = String(urlStr || '').toLowerCase();
        if (!s) return true;
        if (/thumb(?:nail)?/.test(s)) return true;
        if (/\bpreview\b/.test(s)) return true;
        const dim = parseExplicitResolutionFromUrl(s);
        if (dim.w && dim.h) {
            const area = dim.w * dim.h;
            if (dim.w < 1000 || dim.h < 560 || area < 700000) return true;
        }
        return false;
    }

    function filterPreferredFruitigerCandidates(list){
        const arr = Array.isArray(list) ? list.slice() : [];
        if (!arr.length) return [];
        const withoutThumbs = arr.filter(c => !/thumb(?:nail)?/i.test(String(c && c.url || '')));
        const base = withoutThumbs.length ? withoutThumbs : arr;
        const hi = base.filter(c => !isLowQualityFruitigerCandidateUrl(String(c && c.url || '')));
        return hi.length ? hi : base;
    }

    function buildHiResUrlVariants(urlCandidate){
        const raw = String(urlCandidate || '').trim();
        if (!raw) return [];
        const out = [];
        const seen = new Set();
        const add = (u) => {
            const v = String(u || '').trim();
            if (!v || seen.has(v)) return;
            seen.add(v);
            out.push(v);
        };
        add(raw);

        try {
            const u = new URL(raw, window.location.href);
            // Variant without common resize/compression query parameters.
            const resizedKeys = ['w','width','h','height','q','quality','fit','crop','dpr','auto'];
            let changed = false;
            resizedKeys.forEach(k => {
                if (u.searchParams.has(k)) { u.searchParams.delete(k); changed = true; }
            });
            if (changed) add(u.toString());

            // WordPress-style sized filename: image-768x432.jpg -> image.jpg
            const noSize = u.pathname.replace(/-\d{2,5}x\d{2,5}(?=\.(?:jpe?g|png|webp|gif|bmp|avif)$)/i, '');
            if (noSize !== u.pathname) {
                const u2 = new URL(u.toString());
                u2.pathname = noSize;
                add(u2.toString());
            }
        } catch(e) {
            const noSize = raw.replace(/-\d{2,5}x\d{2,5}(?=\.(?:jpe?g|png|webp|gif|bmp|avif)(?:[?#]|$))/i, '');
            add(noSize);
        }

        return out;
    }

    function getBestSrcFromImg(imgEl){
        if (!imgEl) return '';
        const preferredAttrs = [
            'data-orig-file','data-full-url','data-full','data-image-full','data-original','data-orig-src',
            'data-large-file','data-src','data-lazy-src','data-lazyload','data-src-large','data-bg','src'
        ];
        let best = '';
        let bestScore = -1;
        const consider = (candidateUrl, scoreBase = 0) => {
            if (!candidateUrl) return;
            buildHiResUrlVariants(candidateUrl).forEach((variant, idx) => {
                const score = Number(scoreBase || 0) + estimateUrlResolutionHint(variant) + (idx === 0 ? 0 : 2500);
                if (score >= bestScore) {
                    bestScore = score;
                    best = variant;
                }
            });
        };

        preferredAttrs.forEach((attr, idx) => {
            const v = imgEl.getAttribute && imgEl.getAttribute(attr);
            if (v) consider(v, 1000 - idx);
        });

        const srcset = (imgEl.getAttribute && (imgEl.getAttribute('srcset') || imgEl.getAttribute('data-srcset'))) || '';
        if (srcset) {
            srcset.split(',').forEach(part => {
                const t = part.trim();
                if (!t) return;
                const pieces = t.split(/\s+/);
                const u = pieces[0] || '';
                const descriptor = pieces[1] || '';
                let score = 1;
                const mw = descriptor.match(/(\d+)w/i);
                const mx = descriptor.match(/(\d+(?:\.\d+)?)x/i);
                if (mw) score += (Number(mw[1]) || 1) * 20;
                else if (mx) score += (Number(mx[1]) || 1) * 20000;
                consider(u, score);
            });
        }

        return best || '';
    }

    function collectImageCandidatesFromDocument(doc, baseUrl, opts = {}){
        if (!doc) return [];
        const scopeRoot = opts.scopeRoot || doc;
        const candidatesMap = new Map();

        const push = (urlCandidate, meta = {}) => {
            if (!urlCandidate) return;
            const scoreBase = Number(meta.score || 0);
            buildHiResUrlVariants(urlCandidate).forEach((variant, idx) => {
                let abs = '';
                try { abs = new URL(variant, baseUrl).toString(); } catch(e){ return; }
                if (!/\.(jpe?g|png|webp|gif|bmp|avif)(\?|#|$)/i.test(abs)) return;
                if (/favicon|logo|avatar|icon/i.test(abs)) return;
                let score = scoreBase + estimateUrlResolutionHint(abs);
                if (/wallpaper/i.test(abs)) score += 5000;
                if (/thumb|thumbnail/i.test(abs)) return;
                if (/\bpreview\b/i.test(abs)) score -= 4000;
                if (/small/i.test(abs)) score -= 2000;
                if (idx > 0) score += 3000; // upgraded/original variants
                const prev = candidatesMap.get(abs);
                if (!prev || score > prev.score) candidatesMap.set(abs, { url: abs, score });
            });
        };

        scopeRoot.querySelectorAll('img').forEach(img => {
            let score = 0;
            const w = Number(img.getAttribute('width') || 0);
            const h = Number(img.getAttribute('height') || 0);
            if (w && h) score += Math.min(w, 6000) + Math.min(h, 6000);
            const cls = ((img.getAttribute('class') || '') + ' ' + (img.getAttribute('sizes') || '')).toLowerCase();
            if (/thumb|thumbnail/.test(cls)) score -= 1500;
            if (/full|hero|featured/.test(cls)) score += 2500;

            // Prefer direct full-size URL if provided in image attributes or srcset.
            const src = getBestSrcFromImg(img);
            push(src, { score });

            // Harvest multiple useful attributes, not just one source.
            [
                'src','data-src','data-lazy-src','data-srcset','srcset','data-orig-file','data-full-url',
                'data-large-file','data-image-full','data-original','data-orig-src'
            ].forEach(attr => {
                const val = img.getAttribute && img.getAttribute(attr);
                if (!val) return;
                if (/srcset/i.test(attr)) {
                    String(val).split(',').forEach(part => {
                        const t = part.trim();
                        if (!t) return;
                        const pieces = t.split(/\s+/);
                        const u = pieces[0] || '';
                        const descriptor = pieces[1] || '';
                        let bonus = 0;
                        const mw = descriptor.match(/(\d+)w/i);
                        const mx = descriptor.match(/(\d+(?:\.\d+)?)x/i);
                        if (mw) bonus += (Number(mw[1]) || 0) * 20;
                        if (mx) bonus += (Number(mx[1]) || 0) * 20000;
                        push(u, { score: score + bonus });
                    });
                } else {
                    push(val, { score });
                }
            });

            // If the image is wrapped in a link, inspect the href too.
            const parentAnchor = img.closest && img.closest('a[href]');
            if (parentAnchor) {
                const href = parentAnchor.getAttribute('href') || '';
                let hrefScore = score + 3500;
                const text = (parentAnchor.textContent || '').trim();
                if (/full|original|download/i.test(text)) hrefScore += 2500;
                push(href, { score: hrefScore });
            }
        });

        scopeRoot.querySelectorAll('a[href]').forEach(a => {
            const href = a.getAttribute('href') || '';
            let score = 0;
            if (/\.(jpe?g|png|webp|gif|bmp|avif)(\?|#|$)/i.test(href)) score += 4000;
            if (/wallpaper/i.test(href)) score += 2000;
            const txt = (a.textContent || '').trim();
            if (/full|original|download/i.test(txt)) score += 3000;
            push(href, { score });
        });

        const candidates = Array.from(candidatesMap.values());
        candidates.sort((a, b) => b.score - a.score);
        return candidates;
    }

    function findScopedRootForHash(doc, hashValue){
        const hashId = String(hashValue || '').replace(/^#/, '').trim();
        if (!doc || !hashId) return null;
        let target = null;
        try {
            target = doc.getElementById(hashId) || doc.querySelector(`[name="${(typeof CSS !== 'undefined' && CSS.escape) ? CSS.escape(hashId) : hashId}"]`);
        } catch(e) {
            target = doc.getElementById(hashId);
        }
        if (!target) return null;
        const sectionRoot = target.closest && target.closest('section, article');
        if (sectionRoot) return sectionRoot;
        const wrap = target.closest && target.closest('div');
        if (wrap) return wrap;
        return target.parentElement || target;
    }

    async function getCachedFruitigerDocument(pageUrl){
        const key = String(pageUrl || '');
        if (personalFruitigerArchiveDocsCache.has(key)) return personalFruitigerArchiveDocsCache.get(key);
        const payload = await fetchTextWithFallbacks(key);
        const doc = parseHtmlDocumentFromText(payload.text);
        const cached = { doc, rawText: payload.text, via: payload.via };
        personalFruitigerArchiveDocsCache.set(key, cached);
        return cached;
    }

    async function loadFruitigerArchiveCategories(forceReload = false){
        const baseUrl = 'https://frutigeraeroarchive.org/wallpapers';
        if (!forceReload && Array.isArray(personalFruitigerArchiveCategories) && personalFruitigerArchiveCategories.length) {
            renderPersonalFruitigerArchiveList();
            return personalFruitigerArchiveCategories;
        }
        personalFruitigerArchiveLoading = true;
        setPersonalFruitigerArchiveStatus('Laster innhold...', { loading: true });
        renderPersonalFruitigerArchiveList();
        try {
            if (forceReload) personalFruitigerArchiveDocsCache.delete(baseUrl);
            const cached = await getCachedFruitigerDocument(baseUrl);
            let categories = extractFruitigerCategoriesFromText(cached.rawText, baseUrl);
            categories = categories.map(c => ({
                label: c.label,
                href: c.href,
                hash: (() => { try { return new URL(c.href).hash || ''; } catch(e){ return ''; } })()
            }));
            personalFruitigerArchiveCategories = categories;
            setPersonalFruitigerArchiveStatus(categories.length
                ? 'Velg en kategori. Etter første valg starter automatisk bytte av bilde (hvis intervall ikke står på AV).'
                : 'Fant ingen kategorier. Nettstedet kan ha endret struktur eller blokkert henting.');
            renderPersonalFruitigerArchiveList();
            return categories;
        } catch (err) {
            console.warn('Frutiger archive category load failed', err);
            personalFruitigerArchiveCategories = [];
            renderPersonalFruitigerArchiveList();
            setPersonalFruitigerArchiveStatus('Kunne ikke hente kategorier automatisk (mulig CORS/blokkering).');
            throw err;
        } finally {
            personalFruitigerArchiveLoading = false;
        }
    }

    function setFrutigerMusicPlayerVisible(isVisible){
        frutigerMusicPlayerVisible = !!isVisible;
        if (frutigerMusicPlayerWrapEl) {
            frutigerMusicPlayerWrapEl.classList.toggle('is-visible', frutigerMusicPlayerVisible);
            frutigerMusicPlayerWrapEl.setAttribute('aria-hidden', String(!frutigerMusicPlayerVisible));
        }
        if (toggleFrutigerMusicPlayerButtonEl) {
            toggleFrutigerMusicPlayerButtonEl.classList.toggle('active', frutigerMusicPlayerVisible);
            toggleFrutigerMusicPlayerButtonEl.setAttribute('aria-pressed', String(frutigerMusicPlayerVisible));
        }
        if (!frutigerMusicPlayerVisible && frutigerMusicAudioEl) {
            try { frutigerMusicAudioEl.pause(); } catch(e){}
            try { frutigerMusicAudioEl.currentTime = 0; } catch(e){}
        }
        updateFrutigerMusicPlayerUi();
    }

    function setFrutigerMusicStatus(msg){
        frutigerMusicLastError = '';
        if (frutigerMusicStatusEl) frutigerMusicStatusEl.textContent = msg || '';
    }

    function normalizeFrutigerMusicTrackTitle(rawLabel, href){
        let label = String(rawLabel || '').replace(/\s+/g, ' ').trim();
        if (label) {
            label = label.replace(/^[▶►•·\-\s]+/, '').trim();
            label = label.replace(/\s*\((?:mp3|ogg|wav|m4a|aac|opus|flac)\)$/i, '').trim();
        }
        if (!label) {
            try {
                const u = new URL(String(href || ''), window.location.href);
                const name = decodeURIComponent((u.pathname.split('/').filter(Boolean).pop() || '').replace(/\.[a-z0-9]{2,5}$/i, ''));
                label = name.replace(/[_-]+/g, ' ').trim();
            } catch(e) {
                label = 'Ukjent spor';
            }
        }
        if (label.length > 120) label = label.slice(0, 120).trim() + '…';
        return label || 'Ukjent spor';
    }

    function extractDirectAudioTracksFromDocument(doc, baseUrl){
        if (!doc) return [];
        const out = [];
        const seen = new Set();
        const audioExtRe = /\.(mp3|ogg|wav|m4a|aac|opus|flac)(\?|#|$)/i;
        const pushTrack = (hrefRaw, labelRaw, sourcePage) => {
            if (!hrefRaw) return;
            let abs = '';
            try { abs = new URL(String(hrefRaw).trim(), baseUrl).toString(); } catch(e){ return; }
            if (!audioExtRe.test(abs)) return;
            if (seen.has(abs)) return;
            seen.add(abs);
            out.push({
                title: normalizeFrutigerMusicTrackTitle(labelRaw, abs),
                url: abs,
                sourcePage: sourcePage || String(baseUrl || '')
            });
        };

        doc.querySelectorAll('audio').forEach(audio => {
            const lbl = (audio.getAttribute('title') || audio.getAttribute('aria-label') || '').trim();
            const audioSrc = (audio.getAttribute('src') || '').trim();
            if (audioSrc) pushTrack(audioSrc, lbl, baseUrl);
            audio.querySelectorAll('source[src]').forEach(srcEl => {
                pushTrack(srcEl.getAttribute('src') || '', lbl || (srcEl.getAttribute('title') || ''), baseUrl);
            });
        });

        doc.querySelectorAll('a[href]').forEach(a => {
            const href = (a.getAttribute('href') || '').trim();
            const label = (a.textContent || a.getAttribute('title') || a.getAttribute('aria-label') || '').trim();
            pushTrack(href, label, baseUrl);
        });

        return out;
    }


    function extractDirectAudioTracksFromRawText(rawText, baseUrl){
        const text = String(rawText || '');
        if (!text) return [];
        const out = [];
        const seen = new Set();
        const audioExtRe = /\.(mp3|ogg|wav|m4a|aac|opus|flac)(\?|#|$)/i;

        const pushTrack = (hrefRaw, labelRaw, sourcePage) => {
            if (!hrefRaw) return;
            let abs = '';
            try { abs = new URL(String(hrefRaw).replace(/\\\//g, '/').trim(), baseUrl).toString(); } catch(e){ return; }
            if (!audioExtRe.test(abs)) return;
            if (seen.has(abs)) return;
            seen.add(abs);
            out.push({
                title: normalizeFrutigerMusicTrackTitle(labelRaw, abs),
                url: abs,
                sourcePage: sourcePage || String(baseUrl || '')
            });
        };

        try {
            collectAnchorsFromMarkdownLikeText(text, baseUrl).forEach(item => {
                pushTrack((item && (item.href || item.originalHref)) || '', (item && item.label) || '', baseUrl);
            });
        } catch(e){}

        const textUnescaped = text.replace(/\\\//g, '/');

        const absoluteAudioRe = /https?:\/\/[^\s"'<>\\)]+?\.(?:mp3|ogg|wav|m4a|aac|opus|flac)(?:\?[^\\s"'<>]*)?/gi;
        let m;
        while ((m = absoluteAudioRe.exec(textUnescaped))) {
            pushTrack(m[0], '', baseUrl);
        }

        const quotedAudioRe = /["']([^"']+?\.(?:mp3|ogg|wav|m4a|aac|opus|flac)(?:\?[^"']*)?)["']/gi;
        while ((m = quotedAudioRe.exec(textUnescaped))) {
            pushTrack(m[1], '', baseUrl);
        }

        const attrAudioRe = /\b(?:src|href|file|audio|mp3)\b\s*[:=]\s*["']([^"']+)["']/gi;
        while ((m = attrAudioRe.exec(textUnescaped))) {
            pushTrack(m[1], '', baseUrl);
        }

        return out;
    }

    function extractMusicSubpagesFromRawText(rawText, baseUrl){
        const text = String(rawText || '');
        if (!text) return [];
        const out = [];
        const seen = new Set();

        const push = (hrefRaw) => {
            if (!hrefRaw) return;
            let abs = '';
            try { abs = new URL(String(hrefRaw).replace(/\\\//g, '/').trim(), baseUrl).toString(); } catch(e){ return; }
            if (!/^https?:\/\/frutigeraeroarchive\.org\//i.test(abs)) return;
            let u;
            try { u = new URL(abs); } catch(e){ return; }
            const path = u.pathname.replace(/\/+$/,'');
            if (!/\/music(\/|$)/i.test(path)) return;
            u.hash = '';
            const clean = u.toString();
            const baseClean = (() => { try { const bu = new URL(baseUrl); bu.hash=''; return bu.toString(); } catch(e){ return String(baseUrl || ''); } })();
            if (clean === baseClean) return;
            if (seen.has(clean)) return;
            seen.add(clean);
            out.push(clean);
        };

        try {
            collectAnchorsFromMarkdownLikeText(text, baseUrl).forEach(item => {
                push((item && (item.href || item.originalHref)) || '');
            });
        } catch(e){}

        const textUnescaped = text.replace(/\\\//g, '/');
        let m;
        const absUrlRe = /https?:\/\/[^\s"'<>\\)]+/gi;
        while ((m = absUrlRe.exec(textUnescaped))) push(m[0]);
        const relUrlRe = /["'](\/music\/[^"']+)["']/gi;
        while ((m = relUrlRe.exec(textUnescaped))) push(m[1]);

        return out;
    }

    function isLikelyFrutigerMusicContentPageUrl(absUrl){
        const s = String(absUrl || '').trim();
        if (!/^https?:\/\/frutigeraeroarchive\.org\//i.test(s)) return false;
        let u;
        try { u = new URL(s); } catch(e){ return false; }
        const path = (u.pathname || '/').replace(/\/+/g, '/');
        if (!path) return false;
        // Skip obvious assets and binary/media files (HTML pages only).
        if (/\.(?:jpg|jpeg|png|webp|gif|bmp|avif|svg|ico|css|js|mjs|map|xml|json|txt|pdf|zip|rar|7z|mp4|webm|mov|avi|m4v|mkv|mp3|m4a|ogg|wav|flac|opus)(?:$|[?#])/i.test(path)) return false;
        if (/^\/(?:wp-admin|wp-content\/uploads|wp-content\/themes|wp-content\/plugins|wp-includes)(?:\/|$)/i.test(path)) return false;
        if (/\/(?:feed|comments)\/?$/i.test(path)) return false;
        return true;
    }

    function extractBroaderSameSiteContentPagesFromDocument(doc, baseUrl){
        if (!doc) return [];
        const out = [];
        const seen = new Set();
        const push = (hrefRaw, labelRaw) => {
            if (!hrefRaw) return;
            let abs = '';
            try { abs = new URL(String(hrefRaw).trim(), baseUrl).toString(); } catch(e){ return; }
            if (!isLikelyFrutigerMusicContentPageUrl(abs)) return;
            let u;
            try { u = new URL(abs); } catch(e){ return; }
            u.hash = '';
            const clean = u.toString();
            if (seen.has(clean)) return;
            const label = String(labelRaw || '').trim();
            // Keep broad links, but slightly prefer likely song/post pages.
            if (label && /^(home|about|contact|login)$/i.test(label)) return;
            seen.add(clean);
            out.push(clean);
        };
        doc.querySelectorAll('a[href]').forEach(a => {
            push(a.getAttribute('href') || '', (a.textContent || a.getAttribute('title') || a.getAttribute('aria-label') || ''));
        });
        return out;
    }

    function extractBroaderSameSiteContentPagesFromRawText(rawText, baseUrl){
        const text = String(rawText || '');
        if (!text) return [];
        const out = [];
        const seen = new Set();
        const push = (hrefRaw) => {
            if (!hrefRaw) return;
            let abs = '';
            try { abs = new URL(String(hrefRaw).replace(/\\\//g, '/').trim(), baseUrl).toString(); } catch(e){ return; }
            if (!isLikelyFrutigerMusicContentPageUrl(abs)) return;
            let u;
            try { u = new URL(abs); } catch(e){ return; }
            u.hash = '';
            const clean = u.toString();
            if (seen.has(clean)) return;
            seen.add(clean);
            out.push(clean);
        };
        try {
            collectAnchorsFromMarkdownLikeText(text, baseUrl).forEach(item => push((item && (item.href || item.originalHref)) || ''));
        } catch(e){}
        let m;
        const absUrlRe = /https?:\/\/frutigeraeroarchive\.org\/[^\s"'<>\\)]+/gi;
        while ((m = absUrlRe.exec(text.replace(/\\\//g, '/')))) push(m[0]);
        const relPageRe = /["'](\/(?!wp-content\/uploads\/)[^"']+)["']/gi;
        while ((m = relPageRe.exec(text))) push(m[1]);
        return out;
    }

    function extractMusicSubpagesFromDocument(doc, baseUrl){
        if (!doc) return [];
        const out = [];
        const seen = new Set();
        doc.querySelectorAll('a[href]').forEach(a => {
            const hrefRaw = (a.getAttribute('href') || '').trim();
            if (!hrefRaw || hrefRaw.startsWith('#') || /^mailto:|^javascript:/i.test(hrefRaw)) return;
            let abs = '';
            try { abs = new URL(hrefRaw, baseUrl).toString(); } catch(e){ return; }
            if (!/^https?:\/\/frutigeraeroarchive\.org\//i.test(abs)) return;
            let u;
            try { u = new URL(abs); } catch(e){ return; }
            const path = u.pathname.replace(/\/+$/,'');
            if (!/\/music(\/|$)/i.test(path)) return;
            u.hash = '';
            const clean = u.toString();
            const baseClean = (() => { try { const bu = new URL(baseUrl); bu.hash=''; return bu.toString(); } catch(e){ return String(baseUrl || ''); } })();
            if (clean === baseClean) return;
            if (seen.has(clean)) return;
            seen.add(clean);
            out.push(clean);
        });
        return out;
    }

    async function getCachedFrutigerMusicDocument(pageUrl){
        const key = String(pageUrl || '');
        if (!key) throw new Error('Mangler URL');
        if (frutigerMusicPageCache.has(key)) return frutigerMusicPageCache.get(key);
        const payload = await fetchTextWithFallbacks(key);
        const doc = parseHtmlDocumentFromText(payload.text);
        const cached = { doc, rawText: payload.text, via: payload.via, pageUrl: key };
        frutigerMusicPageCache.set(key, cached);
        return cached;
    }

    function buildFrutigerMusicPlaybackCandidates(audioUrl){
        const raw = String(audioUrl || '').trim();
        if (!raw) return [];
        const out = [];
        const seen = new Set();
        const push = (u) => {
            const clean = String(u || '').trim();
            if (!clean || seen.has(clean)) return;
            seen.add(clean);
            out.push(clean);
        };
        push(raw);
        push(`https://api.allorigins.win/raw?url=${encodeURIComponent(raw)}`);
        push(`https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(raw)}`);
        push(`https://corsproxy.io/?${encodeURIComponent(raw)}`);
        try {
            const abs = new URL(raw).toString();
            push(`https://r.jina.ai/http://${abs.replace(/^https?:\/\//i, '')}`);
        } catch(e){}
        return out;
    }

    function extractArchiveOrgEmbedUrlsFromRawText(rawText, baseUrl){
        const text = String(rawText || '');
        if (!text) return [];
        const out = [];
        const seen = new Set();
        const push = (hrefRaw) => {
            if (!hrefRaw) return;
            let abs = '';
            try { abs = new URL(String(hrefRaw).replace(/\\\//g, '/').trim(), baseUrl).toString(); } catch(e){ return; }
            if (!/^https?:\/\/(?:www\.)?archive\.org\/(?:embed|details)\//i.test(abs)) return;
            abs = abs.replace(/#.*$/, '');
            if (seen.has(abs)) return;
            seen.add(abs);
            out.push(abs);
        };
        let m;
        const re = /https?:\/\/(?:www\.)?archive\.org\/(?:embed|details)\/[^\s"'<>\\)]+/gi;
        while ((m = re.exec(text.replace(/\\\//g, '/')))) push(m[0]);
        const quotedRe = /["']((?:https?:\/\/)?(?:www\.)?archive\.org\/(?:embed|details)\/[^"']+)["']/gi;
        while ((m = quotedRe.exec(text))) push(m[1]);
        return out;
    }

    function extractArchiveOrgEmbedUrlsFromDocument(doc, baseUrl){
        if (!doc) return [];
        const out = [];
        const seen = new Set();
        doc.querySelectorAll('iframe[src], a[href]').forEach(el => {
            const raw = (el.getAttribute('src') || el.getAttribute('href') || '').trim();
            if (!raw) return;
            let abs = '';
            try { abs = new URL(raw, baseUrl).toString(); } catch(e){ return; }
            if (!/^https?:\/\/(?:www\.)?archive\.org\/(?:embed|details)\//i.test(abs)) return;
            abs = abs.replace(/#.*$/, '');
            if (seen.has(abs)) return;
            seen.add(abs);
            out.push(abs);
        });
        return out;
    }

    async function extractArchiveOrgTracksFromEmbedUrl(embedUrl){
        const key = String(embedUrl || '').trim();
        if (!key) return [];
        if (frutigerMusicArchiveOrgMetaCache.has(key)) return frutigerMusicArchiveOrgMetaCache.get(key) || [];
        let identifier = '';
        try {
            const u = new URL(key);
            const parts = u.pathname.split('/').filter(Boolean);
            if (parts.length >= 2 && /^(embed|details)$/i.test(parts[0])) identifier = decodeURIComponent(parts[1]);
        } catch(e){}
        if (!identifier) {
            frutigerMusicArchiveOrgMetaCache.set(key, []);
            return [];
        }
        const metadataUrl = `https://archive.org/metadata/${encodeURIComponent(identifier)}`;
        try {
            const payload = await fetchTextWithFallbacks(metadataUrl);
            let json = null;
            try { json = JSON.parse(payload.text); } catch(e){ json = null; }
            const files = Array.isArray(json && json.files) ? json.files : [];
            const audioExtRe = /\.(mp3|ogg|wav|m4a|aac|opus|flac)$/i;
            const tracks = [];
            const seen = new Set();
            files.forEach(f => {
                const name = String((f && f.name) || '').trim();
                if (!name || !audioExtRe.test(name)) return;
                const abs = `https://archive.org/download/${encodeURIComponent(identifier)}/${name.split('/').map(encodeURIComponent).join('/')}`;
                if (seen.has(abs)) return;
                seen.add(abs);
                tracks.push({
                    title: normalizeFrutigerMusicTrackTitle((f && (f.title || f.name)) || identifier, abs),
                    url: abs,
                    sourcePage: key
                });
            });
            frutigerMusicArchiveOrgMetaCache.set(key, tracks);
            return tracks;
        } catch(e){
            frutigerMusicArchiveOrgMetaCache.set(key, []);
            return [];
        }
    }

    function updateFrutigerMusicPlayerUi(){
        const audio = frutigerMusicAudioEl;
        const hasTracks = Array.isArray(frutigerMusicPlaylist) && frutigerMusicPlaylist.length > 0;
        const idx = (frutigerMusicCurrentIndex >= 0 && frutigerMusicCurrentIndex < (frutigerMusicPlaylist || []).length) ? frutigerMusicCurrentIndex : -1;
        const track = idx >= 0 ? frutigerMusicPlaylist[idx] : null;
        const isPlaying = !!(audio && !audio.paused && !audio.ended && audio.currentSrc);
        const isPausedWithTrack = !!(audio && audio.currentSrc && audio.paused && !audio.ended);

        if (frutigerMusicTrackNameEl) {
            if (track) {
                frutigerMusicTrackNameEl.textContent = `Spiller: ${track.title} (${idx + 1}/${frutigerMusicPlaylist.length})`;
            } else if (frutigerMusicLoading) {
                frutigerMusicTrackNameEl.textContent = 'Laster spilleliste fra Frutiger Aero Archive…';
            } else if (hasTracks) {
                frutigerMusicTrackNameEl.textContent = `Spilleliste klar (${frutigerMusicPlaylist.length} spor). Trykk Start.` + (frutigerMusicPlaylist.length <= 1 ? ' (Prøver utvidet skanning ved neste oppdatering)' : '');
            } else {
                frutigerMusicTrackNameEl.textContent = 'Ingen sang valgt';
            }
        }

        if (frutigerMusicStatusEl) {
            if (!frutigerMusicPlayerVisible) frutigerMusicStatusEl.textContent = 'Av';
            else if (frutigerMusicLoading) frutigerMusicStatusEl.textContent = 'Laster…';
            else if (isPlaying) frutigerMusicStatusEl.textContent = 'Spiller';
            else if (isPausedWithTrack) frutigerMusicStatusEl.textContent = 'Pauset';
            else if (hasTracks) frutigerMusicStatusEl.textContent = 'Klar';
            else if (frutigerMusicLastError) frutigerMusicStatusEl.textContent = 'Feil';
            else frutigerMusicStatusEl.textContent = 'Venter';
        }

        if (frutigerMusicStartStopButtonEl) {
            frutigerMusicStartStopButtonEl.textContent = isPlaying ? 'Stopp' : 'Start';
        }

        [frutigerMusicPauseButtonEl, frutigerMusicPrevButtonEl, frutigerMusicNextButtonEl].forEach(btn => {
            if (!btn) return;
            btn.disabled = !frutigerMusicPlayerVisible || (!hasTracks && !frutigerMusicLoading);
        });
        if (frutigerMusicPauseButtonEl) {
            frutigerMusicPauseButtonEl.disabled = !frutigerMusicPlayerVisible || !audio || !audio.currentSrc;
        }
    }

    async function loadFrutigerMusicPlaylist(forceReload = false){
        const siteRoot = 'https://frutigeraeroarchive.org';
        const baseUrl = 'https://frutigeraeroarchive.org/music';
        if (!forceReload && Array.isArray(frutigerMusicPlaylist) && frutigerMusicPlaylist.length) return frutigerMusicPlaylist;
        frutigerMusicLoading = true;
        updateFrutigerMusicPlayerUi();
        setFrutigerMusicStatus('Laster…');
        try {
            if (forceReload) {
                frutigerMusicPageCache.clear();
                frutigerMusicArchiveOrgMetaCache.clear();
            }

            const all = [];
            const seenTracks = new Set();
            const visitedPages = new Set();
            const queuedPages = new Set();
            const queue = [];

            const pushTracks = (tracks) => {
                (Array.isArray(tracks) ? tracks : []).forEach(t => {
                    if (!t || !t.url) return;
                    const k = String(t.url);
                    if (!k || seenTracks.has(k)) return;
                    seenTracks.add(k);
                    all.push(t);
                });
            };

            const pushPage = (hrefRaw, opts = {}) => {
                if (!hrefRaw) return;
                let abs = '';
                try { abs = new URL(String(hrefRaw).replace(/\\\//g, '/').trim(), baseUrl).toString(); } catch(e){ return; }
                if (!/^https?:\/\/frutigeraeroarchive\.org\//i.test(abs)) return;
                let u;
                try { u = new URL(abs); } catch(e){ return; }
                const path = (u.pathname || '/').replace(/\/+/g,'/').replace(/\/+$/,'') || '/';
                const isMusicPath = /(?:^|\/)music(?:\/|$)/i.test(path);
                const isWpJson = /^\/wp-json(?:\/|$)/i.test(path);
                const isSitemap = /(?:^|\/)sitemap(?:[-_a-z0-9]*)?\.xml$/i.test(path) || /^\/wp-sitemap(?:[-_a-z0-9]*)?\.xml$/i.test(path);
                const allowBroad = !!(opts && opts.allowBroad);
                const looksHtmlPage = isLikelyFrutigerMusicContentPageUrl(abs);
                if (!(isMusicPath || isWpJson || isSitemap || (allowBroad && looksHtmlPage))) return;
                u.hash = '';
                const clean = u.toString();
                if (visitedPages.has(clean) || queuedPages.has(clean)) return;
                queuedPages.add(clean);
                queue.push(clean);
            };

            [
                baseUrl,
                `${siteRoot}/music/`,
                `${siteRoot}/wp-sitemap.xml`,
                `${siteRoot}/sitemap.xml`,
                `${siteRoot}/sitemap_index.xml`,
                `${siteRoot}/wp-json/`,
                `${siteRoot}/wp-json/wp/v2/pages?search=music&per_page=100&_fields=id,link,slug,title,content,parent`,
                `${siteRoot}/wp-json/wp/v2/posts?search=music&per_page=100&_fields=id,link,slug,title,content`,
                `${siteRoot}/wp-json/wp/v2/media?search=mp3&per_page=100&_fields=id,source_url,title,caption,description`,
                `${siteRoot}/wp-json/wp/v2/media?search=m4a&per_page=100&_fields=id,source_url,title,caption,description`,
                `${siteRoot}/wp-json/wp/v2/media?search=ogg&per_page=100&_fields=id,source_url,title,caption,description`,
                `${siteRoot}/wp-json/wp/v2/categories?search=music&per_page=100&_fields=id,name,slug,link,count`,
                `${siteRoot}/wp-json/wp/v2/tags?search=music&per_page=100&_fields=id,name,slug,link,count`
            ].forEach(pushPage);

            const maxPages = 420;
            while (queue.length && visitedPages.size < maxPages) {
                const page = queue.shift();
                if (!page || visitedPages.has(page)) continue;
                queuedPages.delete(page);
                visitedPages.add(page);

                let payload = null;
                try {
                    payload = await getCachedFrutigerMusicDocument(page);
                } catch (e) {
                    continue;
                }
                if (!payload) continue;

                try { pushTracks(extractDirectAudioTracksFromDocument(payload.doc, page)); } catch(e){}
                try { pushTracks(extractDirectAudioTracksFromRawText(payload.rawText, page)); } catch(e){}

                try { extractMusicSubpagesFromDocument(payload.doc, page).forEach(pushPage); } catch(e){}
                try { extractMusicSubpagesFromRawText(payload.rawText, page).forEach(pushPage); } catch(e){}

                // Some song posts may live outside /music while being linked from the /music index.
                try {
                    const uPage = new URL(page);
                    const pagePath = (uPage.pathname || '/').replace(/\/+/g, '/');
                    const shouldBroadScan = /(?:^|\/)music(?:\/|$)/i.test(pagePath) || /\/wp-json\//i.test(pagePath);
                    if (shouldBroadScan) {
                        try { extractBroaderSameSiteContentPagesFromDocument(payload.doc, page).forEach((u) => pushPage(u, { allowBroad: true })); } catch(e){}
                        try { extractBroaderSameSiteContentPagesFromRawText(payload.rawText, page).forEach((u) => pushPage(u, { allowBroad: true })); } catch(e){}
                    }
                } catch(e){}

                // Broader same-site discovery from JSON/XML/inline script content
                try {
                    const textUnescaped = String(payload.rawText || '').replace(/\\\//g, '/');
                    let m;
                    const sameSiteUrlRe = /https?:\/\/frutigeraeroarchive\.org\/[^\s"'<>\\)]+/gi;
                    while ((m = sameSiteUrlRe.exec(textUnescaped))) {
                        const candidate = m[0];
                        pushPage(candidate);
                        try { if (isLikelyFrutigerMusicContentPageUrl(candidate)) pushPage(candidate, { allowBroad: true }); } catch(e){}
                    }
                    const relMusicishRe = /["']((?:\/wp-json\/[^"']+|\/wp-sitemap[^"']+\.xml|\/sitemap[^"']*\.xml|\/music\/[^"']*))["']/gi;
                    while ((m = relMusicishRe.exec(textUnescaped))) pushPage(m[1]);
                } catch(e){}

                // Archive.org embeds often hide many tracks behind iframes; resolve metadata when possible
                try {
                    const archiveUrls = [];
                    const seenArchive = new Set();
                    const collect = (u) => {
                        const k = String(u || '').trim();
                        if (!k || seenArchive.has(k)) return;
                        seenArchive.add(k);
                        archiveUrls.push(k);
                    };
                    try { extractArchiveOrgEmbedUrlsFromDocument(payload.doc, page).forEach(collect); } catch(e){}
                    try { extractArchiveOrgEmbedUrlsFromRawText(payload.rawText, page).forEach(collect); } catch(e){}
                    for (let i = 0; i < archiveUrls.length && i < 40; i++) {
                        try { pushTracks(await extractArchiveOrgTracksFromEmbedUrl(archiveUrls[i])); } catch(e){}
                    }
                } catch(e){}

                try {
                    payload.doc && payload.doc.querySelectorAll && payload.doc.querySelectorAll('iframe[src], source[src], audio[src]').forEach(el => {
                        const src = (el.getAttribute && el.getAttribute('src')) ? el.getAttribute('src') : '';
                        if (!src) return;
                        if (/\.(mp3|ogg|wav|m4a|aac|opus|flac)(\?|#|$)/i.test(src)) {
                            try {
                                const abs = new URL(src, page).toString();
                                pushTracks([{ title: normalizeFrutigerMusicTrackTitle('', abs), url: abs, sourcePage: page }]);
                            } catch(e){}
                            return;
                        }
                        if (/^https?:\/\/(?:www\.)?archive\.org\/(?:embed|details)\//i.test(src)) return;
                        if (/(?:^|\/)music(?:\/|$)/i.test(src) || /\/wp-json\//i.test(src) || /sitemap/i.test(src)) pushPage(src);
                    });
                } catch(e){}
            }

            // Final quality pass: favor direct source URLs before proxied duplicates
            all.sort((a, b) => {
                const ap = /^https?:\/\/(?:api\.allorigins\.win|api\.codetabs\.com|corsproxy\.io)\//i.test(String(a && a.url || '')) ? 1 : 0;
                const bp = /^https?:\/\/(?:api\.allorigins\.win|api\.codetabs\.com|corsproxy\.io)\//i.test(String(b && b.url || '')) ? 1 : 0;
                if (ap !== bp) return ap - bp;
                return String(a && a.title || '').localeCompare(String(b && b.title || ''), 'nb');
            });

            frutigerMusicPlaylist = all;
            if (!all.length) {
                frutigerMusicLastError = 'Ingen lydfiler funnet';
                setFrutigerMusicStatus('Fant ingen lydfiler');
                throw new Error('Fant ingen lydfiler på /music');
            }
            frutigerMusicLastError = '';
            setFrutigerMusicStatus(`Klar (${all.length} spor)`);
            return all;
        } catch (err) {
            frutigerMusicLastError = (err && err.message) ? String(err.message) : 'Kunne ikke hente spilleliste';
            console.warn('Frutiger music load failed', err);
            setFrutigerMusicStatus('Kunne ikke hente');
            throw err;
        } finally {
            frutigerMusicLoading = false;
            updateFrutigerMusicPlayerUi();
        }
    }


    async function playFrutigerMusicTrackByIndex(index, opts = {}){
        const autoplay = opts.autoplay !== false;
        const tryNextSource = opts.nextSource === true;
        if (!frutigerMusicAudioEl) return false;
        if (!Array.isArray(frutigerMusicPlaylist) || !frutigerMusicPlaylist.length) {
            await loadFrutigerMusicPlaylist(false);
        }
        if (!frutigerMusicPlaylist.length) return false;
        const len = frutigerMusicPlaylist.length;
        let idx = Number(index);
        if (!Number.isFinite(idx)) idx = 0;
        idx = ((Math.trunc(idx) % len) + len) % len;
        const track = frutigerMusicPlaylist[idx];
        if (!track || !track.url) return false;

        const candidates = buildFrutigerMusicPlaybackCandidates(track.url);
        if (!candidates.length) return false;

        let startCandidateIndex = 0;
        const currentTrack = (frutigerMusicCurrentIndex >= 0 && frutigerMusicCurrentIndex < frutigerMusicPlaylist.length)
            ? frutigerMusicPlaylist[frutigerMusicCurrentIndex]
            : null;
        if (tryNextSource && currentTrack && currentTrack.url === track.url && Array.isArray(frutigerMusicCurrentPlaybackCandidates) && frutigerMusicCurrentPlaybackCandidates.length) {
            startCandidateIndex = Math.max(0, Number(frutigerMusicCurrentPlaybackCandidateIndex || 0) + 1);
        }

        frutigerMusicCurrentIndex = idx;
        frutigerMusicCurrentPlaybackCandidates = candidates.slice();

        let lastErr = null;
        for (let ci = startCandidateIndex; ci < candidates.length; ci++) {
            const srcToUse = candidates[ci];
            frutigerMusicCurrentPlaybackCandidateIndex = ci;
            const currentSrc = frutigerMusicAudioEl.getAttribute('src') || '';
            if (currentSrc !== srcToUse) {
                frutigerMusicAudioEl.src = srcToUse;
                try { frutigerMusicAudioEl.load(); } catch(e){}
            }
            updateFrutigerMusicPlayerUi();

            if (!autoplay) {
                setFrutigerMusicStatus('Klar');
                updateFrutigerMusicPlayerUi();
                return true;
            }

            try {
                const p = frutigerMusicAudioEl.play();
                if (p && typeof p.catch === 'function') await p.catch((e) => { throw e; });
                frutigerMusicLastError = '';
                setFrutigerMusicStatus('Spiller');
                updateFrutigerMusicPlayerUi();
                return true;
            } catch (err) {
                lastErr = err;
                frutigerMusicLastError = (err && err.message) ? String(err.message) : 'Avspilling blokkert';
                if (ci < candidates.length - 1) {
                    setFrutigerMusicStatus('Prøver alternativ kilde…');
                    continue;
                }
            }
        }

        setFrutigerMusicStatus('Trykk Start igjen');
        updateFrutigerMusicPlayerUi();
        if (lastErr) console.warn('Frutiger music play failed', lastErr);
        return false;
    }


    async function playNextFrutigerMusic(delta = 1){
        if (!Array.isArray(frutigerMusicPlaylist) || !frutigerMusicPlaylist.length) {
            await loadFrutigerMusicPlaylist(false);
        }
        if (!frutigerMusicPlaylist.length) return;
        const base = frutigerMusicCurrentIndex >= 0 ? frutigerMusicCurrentIndex : 0;
        await playFrutigerMusicTrackByIndex(base + Number(delta || 1), { autoplay: true });
    }

    async function handleFrutigerMusicStartStop(){
        if (!frutigerMusicPlayerVisible) return;
        if (!frutigerMusicAudioEl) return;
        const isPlaying = !frutigerMusicAudioEl.paused && !frutigerMusicAudioEl.ended && !!frutigerMusicAudioEl.currentSrc;
        if (isPlaying) {
            try { frutigerMusicAudioEl.pause(); } catch(e){}
            try { frutigerMusicAudioEl.currentTime = 0; } catch(e){}
            setFrutigerMusicStatus('Stoppet');
            updateFrutigerMusicPlayerUi();
            return;
        }
        if (!Array.isArray(frutigerMusicPlaylist) || !frutigerMusicPlaylist.length) {
            try { await loadFrutigerMusicPlaylist(false); } catch(e) { updateFrutigerMusicPlayerUi(); return; }
        }
        if (!frutigerMusicPlaylist.length) { updateFrutigerMusicPlayerUi(); return; }
        const idx = frutigerMusicCurrentIndex >= 0 ? frutigerMusicCurrentIndex : 0;
        await playFrutigerMusicTrackByIndex(idx, { autoplay: true });
    }

    function handleFrutigerMusicPause(){
        if (!frutigerMusicAudioEl) return;
        try { frutigerMusicAudioEl.pause(); } catch(e){}
        setFrutigerMusicStatus('Pauset');
        updateFrutigerMusicPlayerUi();
    }

    function applyFruitigerArchiveImageUrl(imageUrl, categoryLabel){
        const cleanUrl = String(imageUrl || '').trim();
        if (!cleanUrl) return;
        let s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        s.type = 'image';
        s.mediaKind = 'image';
        s.mediaDataUrl = cleanUrl;
        s.glassEnabled = true;
        s.glassOpacity = 20;
        s.glassBlurPx = 1;
        personalCustomizeBackgroundDraft = s;
        s = upsertMediaHistoryInDraft('image', cleanUrl, categoryLabel ? `FEA – ${categoryLabel}` : 'FEA bilde');
        try { applyThemeMode('dark'); } catch(e){}
        setPersonalBgControlsOpen(true);
        setPersonalBgMediaHistoryOpen(false);
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(s, { preview: true, forceOn: true });
    }

    async function applyRandomFruitigerArchiveImage(category, opts = {}){
        if (!category || !category.href) return;
        const categoryUrl = String(category.href);
        const categoryLabel = category.label || 'Kategori';
        const fromAuto = !!(opts && opts.fromAuto);
        const runToken = Number(opts && opts.runToken || 0);
        setPersonalFruitigerArchiveStatus('Laster innhold...', { loading: true });
        try {
            const targetNoHash = (() => { try { const u = new URL(categoryUrl); u.hash = ''; return u.toString(); } catch(e){ return categoryUrl; } })();
            const cached = await getCachedFruitigerDocument(targetNoHash);
            let scopedCandidates = [];
            if (category.hash) {
                const scopedRoot = findScopedRootForHash(cached.doc, category.hash);
                if (scopedRoot) scopedCandidates = collectImageCandidatesFromDocument(cached.doc, targetNoHash, { scopeRoot: scopedRoot });
            }
            const allCandidates = collectImageCandidatesFromDocument(cached.doc, targetNoHash);
            const candidatesRaw = (scopedCandidates && scopedCandidates.length) ? scopedCandidates : allCandidates;
            const candidates = filterPreferredFruitigerCandidates(candidatesRaw);
            if (!candidates.length) throw new Error('Ingen bilder funnet');
            let pool = candidates;
            if (personalFruitigerArchiveLastImageUrl && candidates.length > 1) {
                const filteredPool = candidates.filter(c => String(c && c.url || '') !== personalFruitigerArchiveLastImageUrl);
                if (filteredPool.length) pool = filteredPool;
            }
            const pick = pool[Math.floor(Math.random() * pool.length)];
            if (fromAuto && runToken && runToken !== personalFruitigerArchiveAutoRunToken) return;
            personalFruitigerArchiveLastImageUrl = String(pick && pick.url || '');
            applyFruitigerArchiveImageUrl(pick.url, categoryLabel);
            const sec = Math.max(0, Math.min(600, Number(personalFruitigerArchiveAutoIntervalSec || 0)));
            const secLabel = sec <= 0 ? 'AV' : `${sec}s`;
            setPersonalFruitigerArchiveStatusWithCategory(categoryLabel, `Auto-bytte: ${secLabel} (${personalFruitigerArchiveHistoryMode ? 'historikk' : (personalFruitigerArchiveRandomCategoryMode ? 'tilfeldig kategori' : 'samme kategori')}). Trykk igjen for nytt bilde nå.`);
            if (personalBgMediaStatusEl) personalBgMediaStatusEl.textContent = `FEA: «${categoryLabel}» valgt og klart for lagring`;
        } catch (err) {
            console.warn('Frutiger archive image apply failed', err);
            setPersonalFruitigerArchiveStatus(`Kunne ikke hente bilde fra «${categoryLabel}». Nettstedet kan blokkere henting.`);
        }
    }

    function applyPersonalBackgroundState(state, opts = {}){
        const previewMode = !!opts.preview;
        const forceOn = !!opts.forceOn;
        const s = clonePersonalBackgroundState(state);
        const applyToken = ++personalBgVisualApplyToken;
        applyPersonalGlassModeState(s, opts);
        applyPersonalTextOverrideState(s, opts);
        const shouldUseCustom = forceOn || previewMode || isPersonalCustomizationEnabled();
        const hasMediaBg = shouldUseCustom && (s.type === 'image' || s.type === 'video') && !!s.mediaDataUrl;
        const shouldEnable = shouldUseCustom && (s.type === 'color' || hasMediaBg);
        syncThemeButtonMediaPulse(hasMediaBg);

        const isLatestApply = () => applyToken === personalBgVisualApplyToken;
        const clearImageHandlers = () => {
            if (!customPageBgImageEl) return;
            customPageBgImageEl.onload = null;
            customPageBgImageEl.onerror = null;
        };
        const clearVideoHandlers = () => {
            if (!customPageBgVideoEl) return;
            customPageBgVideoEl.onloadeddata = null;
            customPageBgVideoEl.oncanplay = null;
            customPageBgVideoEl.onerror = null;
        };
        const hideImage = (clearSrc = false) => {
            if (!customPageBgImageEl) return;
            clearImageHandlers();
            customPageBgImageEl.style.visibility = 'hidden';
            if (customPageBgImageEl.style.display !== 'none') customPageBgImageEl.style.display = 'none';
            if (clearSrc && customPageBgImageEl.getAttribute('src')) customPageBgImageEl.removeAttribute('src');
        };
        const hideVideo = (clearSrc = false) => {
            if (!customPageBgVideoEl) return;
            clearVideoHandlers();
            try { customPageBgVideoEl.pause(); } catch(e){}
            customPageBgVideoEl.style.visibility = 'hidden';
            if (customPageBgVideoEl.style.display !== 'none') customPageBgVideoEl.style.display = 'none';
            const hadSrc = !!customPageBgVideoEl.getAttribute('src');
            if (clearSrc && hadSrc) {
                customPageBgVideoEl.removeAttribute('src');
                try { customPageBgVideoEl.load(); } catch(e){}
            }
        };
        const syncVideoPlayback = () => {
            if (!customPageBgVideoEl) return;
            if (isPersonalCustomizeModalOpen()) {
                try { customPageBgVideoEl.pause(); } catch(e){}
                return;
            }
            const p = customPageBgVideoEl.play();
            if (p && typeof p.catch === 'function') p.catch(() => {});
        };

        if (!shouldEnable) {
            hideImage(true);
            hideVideo(true);
            if (customPageBgFillEl) customPageBgFillEl.style.background = 'var(--bg)';
            document.body.classList.remove('custom-page-bg-active');
            return;
        }

        if (hasMediaBg) {
            enforceAmoledThemeForMediaBackground(true);
        }

        document.body.classList.add('custom-page-bg-active');
        if (customPageBgFillEl) {
            customPageBgFillEl.style.background = (s.type === 'color') ? personalBackgroundToCssColor(s) : 'var(--bg)';
        }

        if (s.type === 'image' && customPageBgImageEl && s.mediaDataUrl) {
            const nextImageSrc = String(s.mediaDataUrl || '');
            const currentImgSrc = customPageBgImageEl.getAttribute('src') || '';
            const sameImage = currentImgSrc === nextImageSrc;

            const revealImage = (() => {
                let done = false;
                return () => {
                    if (done || !isLatestApply()) return;
                    done = true;
                    clearImageHandlers();
                    customPageBgImageEl.style.visibility = 'visible';
                    if (customPageBgImageEl.style.display !== 'block') customPageBgImageEl.style.display = 'block';
                };
            })();

            const commitImage = () => {
                if (!isLatestApply()) return;
                hideVideo(true);
                clearImageHandlers();
                try { customPageBgImageEl.decoding = 'sync'; } catch(e){}

                if (sameImage && customPageBgImageEl.complete) {
                    revealImage();
                    return;
                }

                customPageBgImageEl.style.visibility = 'hidden';
                if (customPageBgImageEl.style.display !== 'block') customPageBgImageEl.style.display = 'block';
                customPageBgImageEl.onload = revealImage;
                customPageBgImageEl.onerror = revealImage;

                if ((customPageBgImageEl.getAttribute('src') || '') !== nextImageSrc) {
                    customPageBgImageEl.src = nextImageSrc;
                }

                try {
                    const decodePromise = (typeof customPageBgImageEl.decode === 'function') ? customPageBgImageEl.decode() : null;
                    if (decodePromise && typeof decodePromise.then === 'function') {
                        decodePromise.then(revealImage).catch(revealImage);
                    }
                } catch(e){}
            };

            if (sameImage && customPageBgImageEl.complete) {
                commitImage();
                return;
            }

            const preloadImage = new Image();
            try { preloadImage.decoding = 'sync'; } catch(e){}
            const finalizePreload = () => {
                if (!isLatestApply()) return;
                commitImage();
            };
            preloadImage.onload = () => {
                try {
                    const decodePromise = (typeof preloadImage.decode === 'function') ? preloadImage.decode() : null;
                    if (decodePromise && typeof decodePromise.then === 'function') {
                        decodePromise.then(finalizePreload).catch(finalizePreload);
                        return;
                    }
                } catch(e){}
                finalizePreload();
            };
            preloadImage.onerror = finalizePreload;
            preloadImage.src = nextImageSrc;
            return;
        }

        if (s.type === 'video' && customPageBgVideoEl && s.mediaDataUrl) {
            const nextVideoSrc = String(s.mediaDataUrl || '');
            const commitVideo = () => {
                if (!isLatestApply()) return;
                hideImage(true);
                clearVideoHandlers();
                if ((customPageBgVideoEl.getAttribute('src') || '') !== nextVideoSrc) {
                    customPageBgVideoEl.src = nextVideoSrc;
                }
                customPageBgVideoEl.style.visibility = 'visible';
                if (customPageBgVideoEl.style.display !== 'block') customPageBgVideoEl.style.display = 'block';
                syncVideoPlayback();
            };
            const currentVideoSrc = customPageBgVideoEl.getAttribute('src') || '';
            const sameVideo = currentVideoSrc === nextVideoSrc;
            if (sameVideo && Number(customPageBgVideoEl.readyState || 0) >= 2) {
                commitVideo();
                return;
            }
            clearVideoHandlers();
            customPageBgVideoEl.style.visibility = 'hidden';
            if (customPageBgVideoEl.style.display !== 'block') customPageBgVideoEl.style.display = 'block';
            customPageBgVideoEl.onloadeddata = commitVideo;
            customPageBgVideoEl.oncanplay = commitVideo;
            customPageBgVideoEl.onerror = commitVideo;
            if (!sameVideo) {
                customPageBgVideoEl.src = nextVideoSrc;
                try { customPageBgVideoEl.load(); } catch(e){}
            }
            return;
        }

        hideImage(true);
        hideVideo(true);
    }

    function applyPersonalCustomizationBackground(){
        const modalOpen = isPersonalCustomizeModalOpen();
        const activeState = modalOpen
            ? clonePersonalBackgroundState(personalCustomizeBackgroundDraft || readPersonalBackgroundStateFromValues(personalCustomizationValues))
            : readPersonalBackgroundStateFromValues(personalCustomizationValues);
        const expectsExternalMedia = valuesUseExternalPersonalBgMedia(personalCustomizationValues)
            && (activeState.type === 'image' || activeState.type === 'video');
        if (expectsExternalMedia && !activeState.mediaDataUrl) {
            const activeImageSrc = customPageBgImageEl ? String(customPageBgImageEl.getAttribute('src') || '') : '';
            const activeVideoSrc = customPageBgVideoEl ? String(customPageBgVideoEl.getAttribute('src') || '') : '';
            const hasVisibleImage = activeState.type === 'image' && !!activeImageSrc;
            const hasVisibleVideo = activeState.type === 'video' && !!activeVideoSrc;
            if (hasVisibleImage || hasVisibleVideo) {
                document.body.classList.add('custom-page-bg-active');
                if (customPageBgFillEl) customPageBgFillEl.style.background = 'var(--bg)';
                if (hasVisibleImage) {
                    if (customPageBgImageEl.style.display !== 'block') customPageBgImageEl.style.display = 'block';
                    if (customPageBgVideoEl) {
                        try { customPageBgVideoEl.pause(); } catch(e){}
                        customPageBgVideoEl.style.display = 'none';
                    }
                }
                if (hasVisibleVideo) {
                    if (customPageBgVideoEl.style.display !== 'block') customPageBgVideoEl.style.display = 'block';
                    if (customPageBgImageEl) customPageBgImageEl.style.display = 'none';
                }
                hydratePersonalBgMediaForCurrentProfile({ apply: true });
                return;
            }
            hydratePersonalBgMediaForCurrentProfile({ apply: true });
            return;
        }
        applyPersonalBackgroundState(activeState, modalOpen ? { preview: true, forceOn: true } : { preview: false });
    }

    function syncPersonalBgDraftFromSliderInputs(){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        if (personalBgHueRangeEl) s.hue = Number(personalBgHueRangeEl.value || s.hue);
        if (personalBgSatRangeEl) s.sat = Number(personalBgSatRangeEl.value || s.sat);
        if (personalBgLightRangeEl) s.light = Number(personalBgLightRangeEl.value || s.light);
        s.type = 'color';
        personalCustomizeBackgroundDraft = s;
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(s, { preview: true, forceOn: true });
    }

    function handlePersonalBgMediaFile(file){
        if (!file) return;
        const isImage = /^image\//i.test(file.type || '');
        const isVideo = /^video\//i.test(file.type || '');
        if (!isImage && !isVideo) {
            if (personalBgMediaStatusEl) personalBgMediaStatusEl.textContent = 'Filtype støttes ikke. Velg bilde eller video.';
            return;
        }
        const maxBytes = isVideo ? PERSONAL_BG_MAX_UPLOAD_VIDEO_BYTES : PERSONAL_BG_MAX_UPLOAD_IMAGE_BYTES;
        if (Number(file.size || 0) > maxBytes) {
            const maxMb = (maxBytes / (1024 * 1024)).toFixed(0);
            if (personalBgMediaStatusEl) {
                personalBgMediaStatusEl.textContent = `${isVideo ? 'Videoen' : 'Bildet'} er for stor. Maks anbefalt størrelse er ${maxMb} MB for å unngå treghet og lagringsfeil.`;
            }
            return;
        }
        const reader = new FileReader();
        reader.onload = () => {
            const dataUrl = typeof reader.result === 'string' ? reader.result : '';
            if (!dataUrl) return;
            let s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
            s.type = isVideo ? 'video' : 'image';
            s.mediaKind = s.type;
            s.mediaDataUrl = dataUrl;
            s.glassEnabled = true;
            s.glassOpacity = 20;
            s.glassBlurPx = 1;
            personalCustomizeBackgroundDraft = s;
            s = upsertMediaHistoryInDraft(s.type, dataUrl, file && file.name ? file.name : '');
            try { applyThemeMode('dark'); } catch(e){}
            setPersonalBgControlsOpen(true);
            setPersonalBgMediaHistoryOpen(false);
            setPersonalFruitigerArchiveOpen(false);
            renderPersonalBackgroundUiFromDraft();
            applyPersonalBackgroundState(s, { preview: true, forceOn: true });
        };
        reader.onerror = () => {
            if (personalBgMediaStatusEl) personalBgMediaStatusEl.textContent = 'Kunne ikke lese filen.';
        };
        reader.readAsDataURL(file);
    }

    function initPersonalBackgroundDraftForModal(){
        personalCustomizeBackgroundSavedSnapshot = readPersonalBackgroundStateFromValues(personalCustomizationValues);
        personalCustomizeBackgroundDraft = clonePersonalBackgroundState(personalCustomizeBackgroundSavedSnapshot);
        personalBgControlsOpen = false;
        personalRenameControlsOpen = false;
        personalBgColorControlsOpen = false;
        personalBgGlassControlsOpen = false;
        personalBgTextColorControlsOpen = false;
        personalBgMediaHistoryOpen = false;
        personalFruitigerArchiveOpen = false;
        // Behold auto-bytte aktivt i bakgrunnen selv om popupen åpnes/lukkes.
        updatePersonalFruitigerArchiveIntervalUi();
        setPersonalFruitigerArchiveModeToggle(personalFruitigerArchiveHistoryMode ? 'history' : (personalFruitigerArchiveRandomCategoryMode ? 'random' : 'same'));
        setPersonalBgControlsOpen(false);
        setPersonalRenameControlsOpen(false);
        setPersonalBgColorControlsOpen(false);
        setPersonalBgGlassControlsOpen(false);
        setPersonalBgTextColorControlsOpen(false);
        setPersonalBgMediaHistoryOpen(false);
        setPersonalFruitigerArchiveOpen(false);
        if (personalFruitigerArchiveStatusEl) personalFruitigerArchiveStatusEl.classList.remove('is-loading');
        personalFruitigerArchiveStatusEl.textContent = 'Trykk på knappen for å hente kategorier fra Frutiger Aero Archive.';
        renderPersonalFruitigerArchiveList();
        renderPersonalBackgroundUiFromDraft();
    }

function clampInt(v, min, max) {
        v = parseInt(v, 10);
        if (isNaN(v)) v = min;
        return Math.max(min, Math.min(max, v));
    }

    function loadDayTimelineSettings() {
        const key = getTimelineKey();
        const raw = localStorage.getItem(key);
        
        dayTimelineSettings = {
            dayStartMin: 7 * 60, dayEndMin: 17 * 60,
            coreStartMin: 9 * 60, coreEndMin: 15 * 60,
            lunchStartMin: 11 * 60 + 30, lunchEndMin: 12 * 60
        };

        if (!raw) return;
        try {
            const parsed = JSON.parse(raw);
            if (!parsed || typeof parsed !== "object") return;

            dayTimelineSettings.dayStartMin = clampInt(parsed.dayStartMin, 0, 1439);
            dayTimelineSettings.dayEndMin = clampInt(parsed.dayEndMin, 1, 1440);
            dayTimelineSettings.coreStartMin = clampInt(parsed.coreStartMin, 0, 1439);
            dayTimelineSettings.coreEndMin = clampInt(parsed.coreEndMin, 1, 1440);
            dayTimelineSettings.lunchStartMin = clampInt(parsed.lunchStartMin, 0, 1439);
            dayTimelineSettings.lunchEndMin = clampInt(parsed.lunchEndMin, 1, 1440);

            validateDayTimelineSettings();
        } catch (e) {}
    }

    function saveDayTimelineSettings() {
        const key = getTimelineKey();
        localStorage.setItem(key, JSON.stringify(dayTimelineSettings));
    }

    function validateDayTimelineSettings() {
        if (dayTimelineSettings.dayEndMin <= dayTimelineSettings.dayStartMin) {
            dayTimelineSettings.dayEndMin = Math.min(1440, dayTimelineSettings.dayStartMin + 60);
        }
        dayTimelineSettings.coreStartMin = Math.max(dayTimelineSettings.dayStartMin, Math.min(dayTimelineSettings.coreStartMin, dayTimelineSettings.dayEndMin - 1));
        dayTimelineSettings.coreEndMin = Math.max(dayTimelineSettings.dayStartMin + 1, Math.min(dayTimelineSettings.coreEndMin, dayTimelineSettings.dayEndMin));
        if (dayTimelineSettings.coreEndMin <= dayTimelineSettings.coreStartMin) {
            dayTimelineSettings.coreEndMin = Math.min(dayTimelineSettings.dayEndMin, dayTimelineSettings.coreStartMin + 60);
        }
        dayTimelineSettings.lunchStartMin = Math.max(dayTimelineSettings.dayStartMin, Math.min(dayTimelineSettings.lunchStartMin, dayTimelineSettings.dayEndMin - 1));
        dayTimelineSettings.lunchEndMin = Math.max(dayTimelineSettings.dayStartMin + 1, Math.min(dayTimelineSettings.lunchEndMin, dayTimelineSettings.dayEndMin));
        if (dayTimelineSettings.lunchEndMin <= dayTimelineSettings.lunchStartMin) {
            dayTimelineSettings.lunchEndMin = Math.min(dayTimelineSettings.dayEndMin, dayTimelineSettings.lunchStartMin + 30);
        }
        if (dayTimelineSettings.lunchStartMin < dayTimelineSettings.coreStartMin) dayTimelineSettings.coreStartMin = dayTimelineSettings.lunchStartMin;
        if (dayTimelineSettings.lunchEndMin > dayTimelineSettings.coreEndMin) dayTimelineSettings.coreEndMin = dayTimelineSettings.lunchEndMin;
        dayTimelineSettings.coreStartMin = Math.max(dayTimelineSettings.dayStartMin, Math.min(dayTimelineSettings.coreStartMin, dayTimelineSettings.dayEndMin - 1));
        dayTimelineSettings.coreEndMin = Math.max(dayTimelineSettings.dayStartMin + 1, Math.min(dayTimelineSettings.coreEndMin, dayTimelineSettings.dayEndMin));
    }

    function minutesToLabel(mins) {
        mins = Math.max(0, Math.min(1440, mins));
        const h = Math.floor(mins / 60);
        const m = mins % 60;
        const hh = String(h).padStart(2, "0");
        const mm = String(m).padStart(2, "0");
        return `${hh}.${mm}`;
    }

    function minutesToLabelColon(mins) {
        mins = Math.max(0, Math.min(1440, mins));
        const h = Math.floor(mins / 60);
        const m = mins % 60;
        const hh = String(h).padStart(2, "0");
        const mm = String(m).padStart(2, "0");
        return `${hh}:${mm}`;
    }

    function updateTimelineNowDot() {
        if (!timelineNowDotEl || !dayTimelineBarEl) return;
        const ds = dayTimelineSettings.dayStartMin;
        const de = dayTimelineSettings.dayEndMin;
        const total = Math.max(1, de - ds);
        const now = new Date();
        const nowMin = now.getHours() * 60 + now.getMinutes() + (now.getSeconds() / 60);
        let pct = ((nowMin - ds) / total) * 100;
        pct = Math.max(0, Math.min(100, pct));
        timelineNowDotEl.style.left = `${pct}%`;
        const hh = String(now.getHours()).padStart(2, "0");
        const mm = String(now.getMinutes()).padStart(2, "0");
        const ss = String(now.getSeconds()).padStart(2, "0");
        timelineNowDotEl.title = `${hh}:${mm}:${ss}`;
    }

    function createTimelineSegment(leftPct, widthPct, color, opacity, mode, id) {
        const div = document.createElement("div");
        div.className = "timeline-seg";
        if (mode === 'setup') {
            div.classList.add("clickable");
            div.classList.add(color); // 'blue', 'orange', 'green' classes
            if (id === 'day') div.title = "Juster arbeidsdag";
            else if (id === 'core') div.title = "Juster kjernetid";
            else if (id === 'lunch') div.title = "Juster lunsj";
            
            div.addEventListener("dblclick", (e) => {
                e.preventDefault();
                e.stopPropagation();
                openDayTimelineCurtain(id);
            });
        } else {
            div.style.backgroundColor = color;
            div.style.opacity = opacity;
        }
        div.style.left = `${leftPct}%`;
        div.style.width = `${widthPct}%`;
        return div;
    }

    function getTaskColor(task, index, allTasks) {
        if (allTasks.length === 1 && task.isActive) {
             return "#2563eb"; 
        } else if (allTasks.every(t => !t.isActive)) {
            const n = allTasks.length;
            const hue = (index / n) * 360;
            return `hsl(${hue}, 65%, 55%)`;
        } else {
            // Mixed
            if (task.isActive) return "#2563eb"; 
            
            const nonActiveTasks = allTasks.filter(t => !t.isActive);
            const nonActiveCount = nonActiveTasks.length || 1;
            // Find index among inactive tasks
            const inactiveIdx = nonActiveTasks.findIndex(t => t.id === task.id);
            
            const frac = inactiveIdx / Math.max(nonActiveCount - 1, 1);
            const lightness = 30 + frac * 50;
            return `hsl(0, 0%, ${lightness}%)`;
        }
    }

    function renderTimelineSetupGuide(ds, de, total) {
        const cs = dayTimelineSettings.coreStartMin;
        const ce = dayTimelineSettings.coreEndMin;
        const ls = dayTimelineSettings.lunchStartMin;
        const le = dayTimelineSettings.lunchEndMin;

        dayTimelineBarEl.appendChild(createTimelineSegment(0, 100, 'blue', null, 'setup', 'day'));

        const coreLeft = ((Math.max(ds, cs) - ds) / total) * 100;
        const coreRight = ((Math.min(de, ce) - ds) / total) * 100;
        const coreWidth = Math.max(0, coreRight - coreLeft);
        dayTimelineBarEl.appendChild(createTimelineSegment(coreLeft, coreWidth, 'orange', null, 'setup', 'core'));

        const lunchLeft = ((Math.max(ds, ls) - ds) / total) * 100;
        const lunchRight = ((Math.min(de, le) - ds) / total) * 100;
        const lunchWidth = Math.max(0, lunchRight - lunchLeft);
        dayTimelineBarEl.appendChild(createTimelineSegment(lunchLeft, lunchWidth, 'green', null, 'setup', 'lunch'));
    }

    function scheduleCrossBrowserTimelineRefresh() {
        const redraw = () => {
            try { renderDayTimeline(); } catch (e) {}
            try { updateTimelineNowDot(); } catch (e) {}
        };

        redraw();

        if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(() => {
                redraw();
                requestAnimationFrame(() => redraw());
            });
        } else {
            setTimeout(redraw, 0);
            setTimeout(redraw, 60);
        }

        setTimeout(redraw, 120);
    }

    function renderDayTimeline() {
        if (!dayTimelineBarEl || !dayTimelineTicksEl) return;
        validateDayTimelineSettings();
        
        dayTimelineBarEl.innerHTML = "";
        dayTimelineTicksEl.innerHTML = "";

        const ds = dayTimelineSettings.dayStartMin;
        const de = dayTimelineSettings.dayEndMin;
        const total = Math.max(1, de - ds);

        // Render based on automated timelineMode
        if (timelineMode === 'setup') {
            dayTimelineBarEl.title = "Dobbeltklikk på en farge for å justere tid.";
            dayTimelineBarEl.style.cursor = "default";
            renderTimelineSetupGuide(ds, de, total);

        } else {
            // WORK MODE
            dayTimelineBarEl.title = "Viser arbeidsfordeling.";
            dayTimelineBarEl.style.cursor = "default";
            let renderedWorkSegments = 0;
            
            data.tasks.forEach((task, idx) => {
                const d = new Date(task.firstStartAt || task.createdAt);
                const startMins = d.getHours() * 60 + d.getMinutes();
                const elapsedMs = task.isActive ? getTaskElapsedMs(task) : (task.totalMs || 0);
                const durMins = elapsedMs / 60000;
                
                // Only render if within day range (roughly)
                // We clamp visual range
                const taskEndMins = startMins + durMins;
                
                const visibleStart = Math.max(ds, startMins);
                const visibleEnd = Math.min(de, taskEndMins);
                
                if (visibleEnd > visibleStart) {
                    const leftPct = ((visibleStart - ds) / total) * 100;
                    const widthPct = ((visibleEnd - visibleStart) / total) * 100;
                    const color = getTaskColor(task, idx, data.tasks);
                    
                    const seg = createTimelineSegment(leftPct, widthPct, color, 0.9, 'work', null);
                    seg.title = `${task.name} (${formatDuration(elapsedMs, false)})`;
                    dayTimelineBarEl.appendChild(seg);
                    renderedWorkSegments++;
                }
            });

            // Firefox can occasionally paint the first empty work-mode render without visible segmentation.
            // Show the configured day/core/lunch guide until real work segments exist.
            if (renderedWorkSegments === 0) {
                renderTimelineSetupGuide(ds, de, total);
            }
        }

        // Ticks Logic
        const labelMinsSet = new Set([ds, de]);
        if (timelineMode === 'setup') {
            labelMinsSet.add(dayTimelineSettings.coreStartMin);
            labelMinsSet.add(dayTimelineSettings.coreEndMin);
            labelMinsSet.add(dayTimelineSettings.lunchStartMin);
            labelMinsSet.add(dayTimelineSettings.lunchEndMin);
        }

        const startHour = Math.ceil(ds / 60);
        const endHour = Math.floor(de / 60);

        for (let h = startHour; h <= endHour; h++) {
            const m = h * 60;
            if (m < ds || m > de) continue;
            const x = ((m - ds) / total) * 100;
            const tick = document.createElement("div");
            tick.className = "timeline-tick";
            tick.style.left = `${x}%`;
            dayTimelineTicksEl.appendChild(tick);

            if (labelMinsSet.has(m) || timelineMode === 'work') {
                // In work mode show hourly labels, in setup show specific boundaries
                if (timelineMode === 'setup' && !labelMinsSet.has(m)) continue; 
                
                const lab = document.createElement("div");
                lab.className = "timeline-label";
                lab.style.left = `${x}%`;
                lab.textContent = minutesToLabel(m);
                dayTimelineTicksEl.appendChild(lab);
            }
        }
        
        // Add specific non-hour labels for setup
        if (timelineMode === 'setup') {
            [dayTimelineSettings.lunchStartMin, dayTimelineSettings.lunchEndMin, dayTimelineSettings.coreStartMin, dayTimelineSettings.coreEndMin, ds, de].forEach(m => {
                if ((m % 60) !== 0 && m >= ds && m <= de) {
                    const x = ((m - ds) / total) * 100;
                    const tick = document.createElement("div");
                    tick.className = "timeline-tick";
                    tick.style.left = `${x}%`;
                    tick.style.height = "14px";
                    dayTimelineTicksEl.appendChild(tick);
                    
                    const lab = document.createElement("div");
                    lab.className = "timeline-label";
                    lab.style.left = `${x}%`;
                    lab.textContent = minutesToLabel(m);
                    dayTimelineTicksEl.appendChild(lab);
                }
            });
            // Ensure boundaries have labels
             function ensureEdgeLabel(m) {
                if (m < ds || m > de) return;
                const x = ((m - ds) / total) * 100;
                // Simple check if label exists at this position
                const existing = Array.from(dayTimelineTicksEl.querySelectorAll(".timeline-label"))
                    .some(el => Math.abs(parseFloat(el.style.left) - x) < 0.001);
                if (existing) return;

                const lab = document.createElement("div");
                lab.className = "timeline-label";
                lab.style.left = `${x}%`;
                lab.textContent = minutesToLabel(m);
                dayTimelineTicksEl.appendChild(lab);
            }
            ensureEdgeLabel(ds);
            ensureEdgeLabel(de);
        }

        updateTimelineNowDot();
    }

    function buildTimelineTimeOptions(selectEl) {
        if (!selectEl) return;
        if (selectEl.options.length > 0) return;
        for (let m = 0; m <= 1440; m += 5) {
            const opt = document.createElement("option");
            opt.value = String(m);
            opt.textContent = minutesToLabelColon(m);
            selectEl.appendChild(opt);
        }
    }

    function setDayTimelineToVisibility(isVisible) {
        const displayValue = isVisible ? "" : "none";
        if (dayTimelineToLabelEl) dayTimelineToLabelEl.style.display = displayValue;
        if (dayTimelineToEl) dayTimelineToEl.style.display = displayValue;
    }

    function handleDayTimelineFromChanged() {
        if (!dayTimelineFromEl || !dayTimelineToEl) return;
        if (dayTimelineBlockChange || !dayTimelineEditing) return;

        if (dayTimelineEditing === "lunch") {
            const fromMin = clampInt(dayTimelineFromEl.value, 0, 1440);
            const autoTo = Math.min(1440, fromMin + 30);
            dayTimelineToEl.value = String(autoTo);
            dayTimelineLunchAwaitingFromSelection = false;
            setDayTimelineToVisibility(true);
        }

        applyDayTimelineCurtainChange();
    }

    function openDayTimelineCurtain(mode) {
        dayTimelineEditing = mode;
        buildTimelineTimeOptions(dayTimelineFromEl);
        buildTimelineTimeOptions(dayTimelineToEl);
        dayTimelineBlockChange = true;

        if (mode === "lunch") {
            dayTimelineCurtainTitleEl.textContent = "Juster lunsj";
            dayTimelineFromEl.value = String(dayTimelineSettings.lunchStartMin);
            dayTimelineToEl.value = String(dayTimelineSettings.lunchEndMin);
            dayTimelineLunchAwaitingFromSelection = true;
            setDayTimelineToVisibility(false);
            dayTimelineCurtainHintEl.textContent = `Nå: ${minutesToLabel(dayTimelineSettings.lunchStartMin)}–${minutesToLabel(dayTimelineSettings.lunchEndMin)}`;
        } else if (mode === "core") {
            dayTimelineLunchAwaitingFromSelection = false;
            setDayTimelineToVisibility(true);
            dayTimelineCurtainTitleEl.textContent = "Juster kjernetid";
            dayTimelineFromEl.value = String(dayTimelineSettings.coreStartMin);
            dayTimelineToEl.value = String(dayTimelineSettings.coreEndMin);
            dayTimelineCurtainHintEl.textContent = `Nå: ${minutesToLabel(dayTimelineSettings.coreStartMin)}–${minutesToLabel(dayTimelineSettings.coreEndMin)}`;
        } else {
            dayTimelineLunchAwaitingFromSelection = false;
            setDayTimelineToVisibility(true);
            dayTimelineCurtainTitleEl.textContent = "Juster arbeidsdag";
            dayTimelineFromEl.value = String(dayTimelineSettings.dayStartMin);
            dayTimelineToEl.value = String(dayTimelineSettings.dayEndMin);
            dayTimelineCurtainHintEl.textContent = `Nå: ${minutesToLabel(dayTimelineSettings.dayStartMin)}–${minutesToLabel(dayTimelineSettings.dayEndMin)}`;
        }
        dayTimelineBlockChange = false;
        dayTimelineCurtainEl.classList.add("open");
    }

    function closeDayTimelineCurtain() {
        dayTimelineCurtainEl.classList.remove("open");
        dayTimelineEditing = null;
        dayTimelineLunchAwaitingFromSelection = false;
        setDayTimelineToVisibility(true);
    }

    function applyDayTimelineCurtainChange() {
        if (dayTimelineBlockChange) return;
        if (!dayTimelineEditing) return;

        const fromMin = clampInt(dayTimelineFromEl.value, 0, 1440);
        const toMin = clampInt(dayTimelineToEl.value, 0, 1440);

        if (dayTimelineEditing === "lunch") {
            dayTimelineSettings.lunchStartMin = fromMin;
            dayTimelineSettings.lunchEndMin = toMin;
        } else if (dayTimelineEditing === "core") {
            dayTimelineSettings.coreStartMin = fromMin;
            dayTimelineSettings.coreEndMin = toMin;
        } else {
            dayTimelineSettings.dayStartMin = fromMin;
            dayTimelineSettings.dayEndMin = toMin;
        }

        validateDayTimelineSettings();
        saveDayTimelineSettings();
        renderDayTimeline();

        if (dayTimelineEditing === "lunch") {
            dayTimelineCurtainHintEl.textContent = `Nå: ${minutesToLabel(dayTimelineSettings.lunchStartMin)}–${minutesToLabel(dayTimelineSettings.lunchEndMin)}`;
        } else if (dayTimelineEditing === "core") {
            dayTimelineCurtainHintEl.textContent = `Nå: ${minutesToLabel(dayTimelineSettings.coreStartMin)}–${minutesToLabel(dayTimelineSettings.coreEndMin)}`;
        } else {
            dayTimelineCurtainHintEl.textContent = `Nå: ${minutesToLabel(dayTimelineSettings.dayStartMin)}–${minutesToLabel(dayTimelineSettings.dayEndMin)}`;
        }
        updateTimelineNowDot();
    }

    function formatDuration(ms, showSeconds = true) {
        ms = Math.max(0, ms || 0);
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const pad = (n) => n.toString().padStart(2, "0");
        if (showSeconds) {
            const seconds = totalSeconds % 60;
            return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        } else {
            return `${pad(hours)}:${pad(minutes)}`;
        }
    }


    function formatDurationWorkList(ms, forceShowSeconds = false) {
        const safeMs = Math.max(0, Number(ms) || 0);
        return formatDuration(safeMs, forceShowSeconds || safeMs < 60000);
    }

    function isActiveProjectDivisionSelection(selection) {
        if (!selection) return false;
        const activeTask = getActiveTask();
        if (!activeTask) return false;
        return normalizeTaskName(activeTask.parentProject || '') === normalizeTaskName(selection.projectName || '')
            && normalizeTaskName(activeTask.subTaskName || '') === normalizeTaskName(selection.subTaskName || '');
    }

    function formatColoredDuration(ms) {
        ms = Math.max(0, ms || 0);
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const pad = (n) => n.toString().padStart(2, "0");
        const hClass = hours > 0 ? 'time-digit-h-active' : 'time-digit-neutral';
        const mClass = minutes > 0 ? 'time-digit-m-active' : 'time-digit-neutral';
        const sClass = seconds > 0 ? 'time-digit-s-active' : 'time-digit-neutral';
        return `<span class="${hClass}">${pad(hours)}</span>:<span class="${mClass}">${pad(minutes)}</span>:<span class="${sClass}">${pad(seconds)}</span>`;
    }

    function formatHoursMinutes(ms) {
        if (ms == null) return "";
        ms = Math.max(0, ms || 0);
        const totalMinutes = Math.floor(ms / 60000);
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        const h = hours.toString().padStart(2, "0");
        const m = minutes.toString().padStart(2, "0");
        return `${h}:${m}`;
    }

    function getRoundedTooltipText(ms) {
        const r = getRoundedMs(ms);
        const h = Math.floor(r / 3600000);
        const m = Math.floor((r % 3600000) / 60000);
        return `Avrundet tid: ${h}t ${m}min`;
    }

    function formatTimeOfDay(ts) {
        if (!ts) return "";
        const d = new Date(ts);
        if (isNaN(d.getTime())) return "";
        const h = d.getHours().toString().padStart(2, "0");
        const m = d.getMinutes().toString().padStart(2, "0");
        return `${h}:${m}`;
    }

    function sameLocalDate(tsA, tsB) {
        if (!tsA || !tsB) return false;
        const a = new Date(tsA);
        const b = new Date(tsB);
        return (a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate());
    }

    function getRoundedMs(ms) {
        if (ms <= 0) return 0;
        const totalMinutes = ms / 60000;
        const wholeHours = Math.floor(totalMinutes / 60);
        const remainderMinutes = totalMinutes % 60;
        if (remainderMinutes >= 45) return (wholeHours + 1) * 60 * 60000;
        if (remainderMinutes > 15 && remainderMinutes < 30) return (wholeHours * 60 + 30) * 60000;
        return ms;
    }

    function getTaskElapsedMs(task) {
        if (!task) return 0;
        const base = Math.max(0, task.totalMs || 0);
        if (!task.isActive || !task.lastStartMs) return base;
        const diff = Date.now() - task.lastStartMs;
        const running = Math.max(0, diff);
        return base + running;
    }

    function getTaskCurrentRunMs(task) {
        if (!task || !task.isActive || !task.lastStartMs) return 0;
        return Math.max(0, Date.now() - task.lastStartMs);
    }

    function shouldShowWorkListSecondsForTask(task) {
        return !!(task && task.isActive && getTaskCurrentRunMs(task) < 60000);
    }

    function getActiveTaskIndex() { return data.tasks.findIndex(t => t.isActive); }
    function getActiveTask() { const idx = getActiveTaskIndex(); return idx >= 0 ? data.tasks[idx] : null; }

    function normalizeActivePosition() {
        const idx = getActiveTaskIndex();
        if (idx > 0) {
            const task = data.tasks[idx];
            data.tasks.splice(idx, 1);
            data.tasks.unshift(task);
        }
    }

    function finalizeActiveTask() {
        const idx = getActiveTaskIndex();
        if (idx === -1) return;
        const task = data.tasks[idx];
        task.totalMs = getTaskElapsedMs(task);
        task.isActive = false;
        task.lastEndAt = Date.now();
        task.lastStartMs = null;
    }

    function finalizeActiveTaskAt(hour, minute) {
        const idx = getActiveTaskIndex();
        if (idx === -1) return;
        const task = data.tasks[idx];
        const baseMs = Math.max(0, task.totalMs || 0);
        const startMs = task.lastStartMs;
        if (!startMs) { finalizeActiveTask(); return; }

        const startDate = new Date(startMs);
        const endDate = new Date(startDate);
        endDate.setHours(hour, minute, 0, 0);
        if (endDate.getTime() < startMs) endDate.setDate(endDate.getDate() + 1);
        const deltaRaw = endDate.getTime() - startMs;
        const delta = Math.max(0, deltaRaw);
        task.totalMs = baseMs + delta;
        task.isActive = false;
        task.lastEndAt = endDate.getTime();
        task.lastStartMs = null;
    }

    function addTaskNameToHistory(name) {
        if (!name) return;
        if (!Array.isArray(data.taskNames)) data.taskNames = [];
        const trimmed = name.trim();
        if (!trimmed) return;
        const existingIndex = data.taskNames.indexOf(trimmed);
        if (existingIndex !== -1) data.taskNames.splice(existingIndex, 1);
        data.taskNames.unshift(trimmed);
    }

    function removeTaskNameFromHistory(name) {
        if (!Array.isArray(data.taskNames)) return;
        const idx = data.taskNames.indexOf(name);
        if (idx !== -1) {
            data.taskNames.splice(idx, 1);
            const key = normalizeTaskName(name);

            if (key && data.projectNumbers && Object.prototype.hasOwnProperty.call(data.projectNumbers, key)) {
                delete data.projectNumbers[key];
            }

            // also remove favorite flag + ordering
            if (key && data.favorites && Object.prototype.hasOwnProperty.call(data.favorites, key)) {
                delete data.favorites[key];
            }
            if (Array.isArray(data.favoritesOrder) && key) {
                data.favoritesOrder = data.favoritesOrder.filter(k => k !== key);
            }

            saveToStorage();
        }
    }

    function setProjectSuggestionsLayerState(isOpen) {
        const card = document.getElementById('projectInputCard');
        if (!card) return;
        if (isOpen) card.classList.add('suggestions-open');
        else card.classList.remove('suggestions-open');
    }

    function clearSuggestions() {
        suggestionIndex = -1;
        filteredSuggestions = [];
        if (taskSuggestionsEl) {
            taskSuggestionsEl.innerHTML = "";
            taskSuggestionsEl.style.display = "none";
        }
        setProjectSuggestionsLayerState(false);
    }


    function getFavoriteRankForName(name) {
        const key = normalizeTaskName(name);
        if (!key) return 999999;
        if (!Array.isArray(data.favoritesOrder)) data.favoritesOrder = [];
        const idx = data.favoritesOrder.indexOf(key);
        return (idx === -1) ? 999999 : idx;
    }


    function ensureOutdatedData(){
        if (!data.outdated || typeof data.outdated !== "object") data.outdated = {};
    }

    function getLastUsedMsForName(name){
        const key = normalizeTaskName(name);
        if (!key) return 0;
        let best = 0;

        // Active list
        (data.tasks || []).forEach(t => {
            if (!t || normalizeTaskName(t.name) !== key) return;
            best = Math.max(best, t.lastEndAt || 0, t.firstStartAt || 0, t.createdAt || 0, t.lastStartMs || 0);
        });

        // Archives
        (data.archives || []).forEach(a => {
            (a.tasks || []).forEach(t => {
                if (!t || normalizeTaskName(t.name) !== key) return;
                best = Math.max(best, t.lastEndAt || 0, t.firstStartAt || 0, t.createdAt || 0);
            });
        });

        // Fallback: if never used, treat as old
        return best || 0;
    }

    function isOutdatedForName(name){
        ensureOutdatedData();
        const key = normalizeTaskName(name);
        if (!key) return false;

        const entry = data.outdated[key];
        const lastUsed = getLastUsedMsForName(name);
        const THIRTY_DAYS_MS = 30 * 24 * 60 * 60 * 1000;
        const autoOutdated = lastUsed > 0 && (Date.now() - lastUsed) >= THIRTY_DAYS_MS;

        // Manual override always wins
        if (entry && typeof entry === "object" && entry.manual === true) return true;

        // Auto: only if lastUsed qualifies
        if (entry && typeof entry === "object" && entry.manual === false) {
            if (autoOutdated) return true;
            // Auto flag no longer valid -> clear it
            delete data.outdated[key];
            return false;
        }

        // No entry: auto mark if qualifies
        if (autoOutdated) {
            data.outdated[key] = { manual: false };
            return true;
        }
        return false;
    }

    function setOutdatedForName(name, isOutdated, manual = true){
        ensureOutdatedData();
        const key = normalizeTaskName(name);
        if (!key) return;
        if (isOutdated) data.outdated[key] = { manual: !!manual };
        else delete data.outdated[key];
    }

    function clearAutoOutdatedForName(name){
        ensureOutdatedData();
        const key = normalizeTaskName(name);
        if (!key) return;
        const entry = data.outdated[key];
        if (entry && typeof entry === "object" && entry.manual === false) {
            delete data.outdated[key];
        }
    }

    function reorderFavoriteKeys(srcKey, targetKey, insertAfter) {
        if (!srcKey || !targetKey) return;
        if (!Array.isArray(data.favoritesOrder)) data.favoritesOrder = [];
        // Ensure both are present
        if (data.favoritesOrder.indexOf(srcKey) === -1) data.favoritesOrder.unshift(srcKey);
        if (data.favoritesOrder.indexOf(targetKey) === -1) data.favoritesOrder.push(targetKey);

        const list = data.favoritesOrder.filter(k => k !== srcKey);
        const tIdx = list.indexOf(targetKey);
        if (tIdx === -1) {
            // fallback: append
            list.push(srcKey);
        } else {
            const insertIdx = insertAfter ? (tIdx + 1) : tIdx;
            list.splice(insertIdx, 0, srcKey);
        }
        data.favoritesOrder = list;
        saveToStorage();
    }

    
    function ensureGroupData(){
        if (!data.groups || !Array.isArray(data.groups)) data.groups = [];
        if (!data.taskToGroup || typeof data.taskToGroup !== "object") data.taskToGroup = {};
        if (typeof data.nextGroupIndex !== "number" || !isFinite(data.nextGroupIndex) || data.nextGroupIndex < 1) data.nextGroupIndex = 1;

        // Clean up: remove missing tasks from groups, and drop empty groups
        const keyToName = {};
        (data.taskNames || []).forEach(n => { const k = normalizeTaskName(n); if (k) keyToName[k] = n; });

        data.groups = data.groups.map(g => {
            if (!g || typeof g !== "object") return null;
            if (!g.id) g.id = "g_" + Math.random().toString(36).slice(2, 10);
            if (!g.name) g.name = "Gruppe";
            if (!Array.isArray(g.items)) g.items = [];
            if (typeof g.color !== 'string') g.color = '';
            g.items = g.items.filter(k => !!keyToName[k]);
            return g;
        }).filter(g => g && Array.isArray(g.items) && g.items.length >= 2);

        // Rebuild taskToGroup based on groups
        const newMap = {};
        data.groups.forEach(g => g.items.forEach(k => { newMap[k] = g.id; }));
        data.taskToGroup = newMap;

        // If we were inside a group that got removed, exit
        if (currentGroupId && !data.groups.some(g => g.id === currentGroupId)) currentGroupId = null;
    }

    function getGroupById(groupId){
        ensureGroupData();
        return data.groups.find(g => g.id === groupId) || null;
    }

    function getGroupIdForTaskKey(taskKey){
        ensureGroupData();
        return data.taskToGroup[taskKey] || null;
    }

    function makeNextGroupName(){
        ensureGroupData();
        const name = "Gruppe " + data.nextGroupIndex;
        data.nextGroupIndex += 1;
        return name;
    }

    function createGroupWithKeys(taskKeys){
        ensureGroupData();
        const unique = Array.from(new Set((taskKeys || []).filter(Boolean)));
        if (unique.length < 2) return null;
        const g = {
            id: "g_" + Math.random().toString(36).slice(2, 10),
            name: makeNextGroupName(),
            items: unique,
            color: ''
        };
        data.groups.unshift(g);
        unique.forEach(k => { data.taskToGroup[k] = g.id; });
        saveToStorage();
        return g;
    }

    function addTaskKeyToGroup(taskKey, groupId){
        ensureGroupData();
        const g = getGroupById(groupId);
        if (!g) return;
        if (!g.items.includes(taskKey)) g.items.push(taskKey);
        data.taskToGroup[taskKey] = g.id;
        saveToStorage();
    }

    function mergeGroups(intoGroupId, fromGroupId){
        ensureGroupData();
        if (!intoGroupId || !fromGroupId || intoGroupId === fromGroupId) return;
        const into = getGroupById(intoGroupId);
        const from = getGroupById(fromGroupId);
        if (!into || !from) return;

        from.items.forEach(k => {
            if (!into.items.includes(k)) into.items.push(k);
            data.taskToGroup[k] = into.id;
        });

        data.groups = data.groups.filter(g => g.id !== from.id);
        saveToStorage();
    }

    function groupTasksByKeys(srcKey, targetKey){
        ensureGroupData();
        if (!srcKey || !targetKey || srcKey === targetKey) return;

        const srcGroupId = getGroupIdForTaskKey(srcKey);
        const tgtGroupId = getGroupIdForTaskKey(targetKey);

        if (!srcGroupId && !tgtGroupId) {
            // Group creation by dragging project onto another project is disabled.
            return;
        }
        if (srcGroupId && !tgtGroupId) {
            addTaskKeyToGroup(targetKey, srcGroupId);
            return;
        }
        if (!srcGroupId && tgtGroupId) {
            addTaskKeyToGroup(srcKey, tgtGroupId);
            return;
        }
        // Both grouped
        if (srcGroupId === tgtGroupId) return;
        // Merge src into target's group (stable expectation: drop ON target -> target wins)
        mergeGroups(tgtGroupId, srcGroupId);
    }

    function enterGroupView(groupId){
        currentGroupId = groupId || null;
        renderSuggestions();
        taskSuggestionsEl && (taskSuggestionsEl.style.display = "block");
        setProjectSuggestionsLayerState(true);
    }

    function exitGroupView(){
        currentGroupId = null;
        renderSuggestions();
        taskSuggestionsEl && (taskSuggestionsEl.style.display = "block");
        setProjectSuggestionsLayerState(true);
    }

    function renderSuggestions() {
        if (!taskSuggestionsEl) return;

        // Ensure ESC handler exists (one-time)
        if (!escListenerAdded) {
            escListenerAdded = true;
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape" || e.key === "Esc") {
                    if (currentGroupId) {
                        e.preventDefault();
                        exitGroupView();
                        taskInputEl && taskInputEl.focus();
                    }
                }
            }, true);
        }

        const focused = document.activeElement === taskInputEl;
        const overlayOpen = (projectOverlayEl && projectOverlayEl.classList.contains("show"));
        // Allow suggestions to stay rendered/refresh while project edit popup is open
        if ((!focused && !overlayOpen) || !Array.isArray(data.taskNames) || data.taskNames.length === 0) {
            clearSuggestions();
            return;
        }

        ensureGroupData();

        const query = taskInputEl.value.trim().toLowerCase();
        const visibleTaskNames = (data.taskNames || []).filter(n => !isProjectDivisionHistoryName(n));
        const keyToName = {};
        visibleTaskNames.forEach(n => { const k = normalizeTaskName(n); if (k) keyToName[k] = n; });

        const nameMatches = (name) => {
            if (!query) return true;
            return (name || "").toLowerCase().includes(query);
        };

        // ---- Build view model: group header + groups + tasks
        const rows = [];

        if (currentGroupId) {
            const g = getGroupById(currentGroupId);
            if (!g) {
                currentGroupId = null;
            } else {
                // Optional back row
                rows.push({ type: "groupHeader", label: "← Tilbake", groupId: currentGroupId });

                const namesInGroup = g.items
                    .map(k => keyToName[k])
                    .filter(Boolean)
                    .filter(nameMatches);

                // Favorites first (and ordered) within group too
                namesInGroup.sort((a, b) => {
                    const fa = isFavoriteForName(a);
                    const fb = isFavoriteForName(b);
                    if (fa && fb) return getFavoriteRankForName(a) - getFavoriteRankForName(b);
                    if (fa !== fb) return fa ? -1 : 1;
                    return visibleTaskNames.indexOf(a) - visibleTaskNames.indexOf(b);
                });

                namesInGroup.forEach(n => rows.push({ type: "task", name: n }));
            }
        }

        if (!currentGroupId) {
            // Groups (shown as rows)
            const groupRows = data.groups
                .map(g => {
                    const memberNames = (g.items || []).map(k => keyToName[k]).filter(Boolean);
                    const matches = (!query)
                        ? true
                        : (g.name || "").toLowerCase().includes(query) || memberNames.some(n => nameMatches(n));
                    return matches ? { type: "group", group: g, count: memberNames.length } : null;
                })
                .filter(Boolean);

            // Ungrouped tasks
            let taskRows = visibleTaskNames
                .filter(name => {
                    const k = normalizeTaskName(name);
                    if (!k) return false;
                    if (data.taskToGroup[k]) return false; // grouped -> hidden in main
                    return nameMatches(name);
                });

            // Favorites first (and ordered)
            taskRows.sort((a, b) => {
                const fa = isFavoriteForName(a);
                const fb = isFavoriteForName(b);
                if (fa && fb) return getFavoriteRankForName(a) - getFavoriteRankForName(b);
                if (fa !== fb) return fa ? -1 : 1;
                return visibleTaskNames.indexOf(a) - visibleTaskNames.indexOf(b);
            });

            // Favorites ALWAYS on top, regardless of groups
            const favTasks = taskRows.filter(n => isFavoriteForName(n));
            const nonFavTasks = taskRows.filter(n => !isFavoriteForName(n));

            favTasks.forEach(n => rows.push({ type: "task", name: n }));
            groupRows.forEach(gr => rows.push(gr));
            const activeNonFav = nonFavTasks.filter(n => !isOutdatedForName(n));
            const outdatedNonFav = nonFavTasks.filter(n => isOutdatedForName(n));
            activeNonFav.forEach(n => rows.push({ type: "task", name: n }));
            if (outdatedNonFav.length > 0) rows.push({ type: "outdatedDivider" });
            outdatedNonFav.forEach(n => rows.push({ type: "task", name: n }));
        }

        if (rows.length === 0) {
            clearSuggestions();
            return;
        }

        // selection index only applies to task rows
        const taskRowIndexes = rows.map((r, i) => (r.type === "task" ? i : -1)).filter(i => i !== -1);
        if (suggestionIndex >= taskRowIndexes.length) suggestionIndex = -1;

        // Arrow navigation + Enter uses this list
        const orderedTaskNames = rows.filter(r => r.type === "task").map(r => r.name);
        filteredSuggestions = orderedTaskNames;

        // Insert divider after the last favorite (only if there are non-favorites below)
        let lastFavTaskIndex = -1;
        orderedTaskNames.forEach((n, i) => { if (isFavoriteForName(n)) lastFavTaskIndex = i; });

        taskSuggestionsEl.innerHTML = "";

        const clearDragIndicators = () => {
            document.querySelectorAll(".suggestion-item.drop-above, .suggestion-item.drop-below, .suggestion-item.drop-into, .suggestion-item.dragging")
                .forEach(el => el.classList.remove("drop-above", "drop-below", "drop-into", "dragging"));
        };

        let taskCounter = -1;
        rows.forEach((row) => {

            if (row.type === "groupHeader") {
                const item = document.createElement("div");
                item.className = "suggestion-item group-header";
                const labelSpan = document.createElement("span");
                labelSpan.className = "suggestion-label";
                labelSpan.textContent = row.label || "← Tilbake";
                const actions = document.createElement("span");
                actions.className = "suggestion-actions";
                item.appendChild(labelSpan);
                item.appendChild(actions);
                // Allow dropping tasks onto the group row (adds task into group)
                item.addEventListener("dragover", (e) => {
                    if (!dragTaskKey) return;
                    e.preventDefault();
                    });
                item.addEventListener("dragleave", () => {
                    });
                item.addEventListener("drop", (e) => {
                    if (!dragTaskKey) return;
                    e.preventDefault();
                    const srcKey = dragTaskKey;
                    const srcGroupId = getGroupIdForTaskKey(srcKey);
                    const tgtGroupId = g.id;

                    if (srcGroupId && srcGroupId !== tgtGroupId) {
                        // merge groups into target
                        mergeGroups(tgtGroupId, srcGroupId);
                    } else if (!srcGroupId) {
                        addTaskKeyToGroup(srcKey, tgtGroupId);
                    }
                    suppressNextSuggestionClick = true;
                    renderSuggestions();
                    taskInputEl && taskInputEl.focus();
                });

                item.addEventListener("click", (e) => {
                    e.preventDefault();
                    exitGroupView();
                    taskInputEl && taskInputEl.focus();
                });
                taskSuggestionsEl.appendChild(item);
                return;
            }

            if (row.type === "group") {
                const g = row.group;
                const item = document.createElement("div");
                item.className = "suggestion-item group-item";
                const labelSpan = document.createElement("span");
                labelSpan.className = "suggestion-label";
                labelSpan.textContent = (g.name || "Gruppe") + " (" + (row.count || 0) + ")";
                if (g.color) { labelSpan.style.color = g.color; }

                const actions = document.createElement("span");
                actions.className = "suggestion-actions";
                item.appendChild(labelSpan);
                item.appendChild(actions);
                item.addEventListener("click", (e) => {
                    // don't start project, open group
                    e.preventDefault();
                    enterGroupView(g.id);
                    taskInputEl && taskInputEl.focus();
                });
                item.addEventListener("dblclick", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    openGroupEditModal(g.id);
                });
                taskSuggestionsEl.appendChild(item);
                return;
            }

            if (row.type === "outdatedDivider") {
                const divider = document.createElement("div");
                divider.className = "suggestion-divider";
                taskSuggestionsEl.appendChild(divider);
                return;
            }

            // ---- Task row
            const name = row.name;
            taskCounter += 1;

            const item = document.createElement("div");
            item.className = "suggestion-item";
            if (isOutdatedForName(name)) item.classList.add("task-outdated");
            if (taskCounter === suggestionIndex) item.classList.add("selected");

            const labelSpan = document.createElement("span");
            labelSpan.className = "suggestion-label";
            labelSpan.textContent = name;

            const actions = document.createElement("span");
            actions.className = "suggestion-actions";

            const favBtn = document.createElement("button");
            favBtn.className = "suggestion-fav";
            const favOn = isFavoriteForName(name);
            const taskKey = normalizeTaskName(name);
            const favKey = taskKey;

            // Drag: always allow dragging tasks (used for grouping),
            // but favorite rows also support reorder among favorites.
            if (taskKey) {
                item.draggable = true;

                item.addEventListener("dragstart", (e) => {
                    dragTaskKey = taskKey;

                    if (favOn && favKey) {
                        isReorderingFavorites = true;
                        dragFavKey = favKey;
                        dragOverFavKey = null;
                        dragInsertAfter = false;
                        item.classList.add("dragging");
                        e.dataTransfer.effectAllowed = "move";
                        try { e.dataTransfer.setData("text/plain", favKey); } catch (err) {}
                    } else {
                        isReorderingFavorites = false;
                        dragFavKey = null;
                        dragOverFavKey = null;
                        dragInsertAfter = false;
                        item.classList.add("dragging");
                        e.dataTransfer.effectAllowed = "move";
                        try { e.dataTransfer.setData("text/plain", taskKey); } catch (err) {}
                    }
                });

                item.addEventListener("dragend", () => {
                    isReorderingFavorites = false;
                    dragFavKey = null;
                    dragOverFavKey = null;
                    dragInsertAfter = false;
                    dragTaskKey = null;
                    clearDragIndicators();
                });

                item.addEventListener("dragover", (e) => {
                    if (!dragTaskKey || !taskKey || dragTaskKey === taskKey) return;

                    // Allow drop
                    e.preventDefault();

                    const targetIsFav = !!data.favorites && !!data.favorites[taskKey];
                    const srcIsFav = !!data.favorites && !!data.favorites[dragTaskKey];

                    clearDragIndicators();

                    // If both are favorites AND we are in reorder mode -> show above/below indicator
                    if (isReorderingFavorites && srcIsFav && targetIsFav) {
                        const rect = item.getBoundingClientRect();
                        const after = (e.clientY - rect.top) > (rect.height / 2);
                        dragOverFavKey = taskKey;
                        dragInsertAfter = after;
                        item.classList.add(after ? "drop-below" : "drop-above");
                    } else {
                        // Otherwise: grouping drop
                        }
                });

                item.addEventListener("drop", (e) => {
                    if (!dragTaskKey || !taskKey || dragTaskKey === taskKey) return;
                    e.preventDefault();

                    const targetIsFav = !!data.favorites && !!data.favorites[taskKey];
                    const srcIsFav = !!data.favorites && !!data.favorites[dragTaskKey];

                    // Reorder favorites only if both are favorites and reorder mode is active
                    if (isReorderingFavorites && srcIsFav && targetIsFav && dragFavKey && dragOverFavKey) {
                        reorderFavoriteKeys(dragFavKey, dragOverFavKey, dragInsertAfter);
                        suppressNextSuggestionClick = true;
                        renderSuggestions();
                        taskInputEl && taskInputEl.focus();
                        return;
                    }

                    // Grouping: drop a task ON another task
                    groupTasksByKeys(dragTaskKey, taskKey);
                    suppressNextSuggestionClick = true;
                    renderSuggestions();
                    taskInputEl && taskInputEl.focus();
                });
            }

            // Keep cursor affordance for favorites
            if (favOn && favKey) item.classList.add("is-fav-row");

            favBtn.textContent = favOn ? "★" : "☆";
            if (favOn) favBtn.classList.add("is-fav");
            favBtn.title = favOn ? "Fjern favoritt" : "Merk som favoritt";
            favBtn.addEventListener("mousedown", (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFavoriteForName(name);
                renderSuggestions();
                taskInputEl.focus();
            });

            const editBtn = document.createElement("button");
            editBtn.className = "suggestion-edit";
            editBtn.innerHTML = '<span class="pencil-icon" aria-hidden="true">✎</span>';
            editBtn.title = "Rediger prosjektnummer";
            editBtn.addEventListener("mousedown", (e) => {
                e.preventDefault();
                e.stopPropagation();
                showProjectEditPopup(name);
            });

            const deleteBtn = document.createElement("button");
            deleteBtn.className = "suggestion-delete";
            deleteBtn.textContent = "X";
            deleteBtn.title = "Fjern fra historikk";
            deleteBtn.addEventListener("mousedown", (e) => {
                e.preventDefault();
                e.stopPropagation();
                showDeleteTaskPopup(name);
                taskInputEl && taskInputEl.blur();
            });

            actions.appendChild(favBtn);
            actions.appendChild(editBtn);
            actions.appendChild(deleteBtn);

            item.appendChild(labelSpan);
            item.appendChild(actions);

            item.addEventListener("click", (e) => {
                // Ignore clicks from action buttons
                if (e.target && (e.target.closest && e.target.closest(".suggestion-actions"))) return;
                if (suppressNextSuggestionClick) { suppressNextSuggestionClick = false; return; }
                selectedTaskId = null;
                selectedProjectDivisionTarget = null;
                startOrResumeByName(name);
            });

            taskSuggestionsEl.appendChild(item);

            if (taskCounter === lastFavTaskIndex && lastFavTaskIndex !== -1 && lastFavTaskIndex < orderedTaskNames.length - 1) {
                const div = document.createElement("div");
                div.className = "suggestion-divider";
                taskSuggestionsEl.appendChild(div);
            }
        });

        taskSuggestionsEl.style.display = "block";
        setProjectSuggestionsLayerState(true);
    }


    function getStoredProjectNumberForName(name) {
        const key = normalizeTaskName(name);
        if (!key) return "";
        if (!data.projectNumbers || typeof data.projectNumbers !== "object") data.projectNumbers = {};
        const val = data.projectNumbers[key];
        return (typeof val === "string") ? val : "";
    }

    function setStoredProjectNumberForName(name, projectNumber) {
        const key = normalizeTaskName(name);
        if (!key) return;
        if (!data.projectNumbers || typeof data.projectNumbers !== "object") data.projectNumbers = {};
        const val = (projectNumber || "").trim();
        if (val) data.projectNumbers[key] = val;
        else delete data.projectNumbers[key];
    }

    function getStoredProjectDivisionForName(name) {
        const key = normalizeTaskName(name);
        if (!key) return [];
        if (!data.projectDivisions || typeof data.projectDivisions !== "object") data.projectDivisions = {};
        const val = data.projectDivisions[key];
        return Array.isArray(val) ? val.filter(v => typeof v === 'string' && v.trim()) : [];
    }

    function setStoredProjectDivisionForName(name, items) {
        const key = normalizeTaskName(name);
        if (!key) return;
        if (!data.projectDivisions || typeof data.projectDivisions !== "object") data.projectDivisions = {};
        const cleaned = Array.isArray(items) ? items.map(v => String(v || '').trim()).filter(Boolean) : [];
        if (cleaned.length) data.projectDivisions[key] = cleaned;
        else delete data.projectDivisions[key];
    }

    function updateProjectTaskDivisionButtonState() {
        if (!projectTaskDivisionButtonEl) return;
        const name = (pendingNewTaskName || '').trim();
        const hasItems = name ? getStoredProjectDivisionForName(name).length > 0 : false;
        projectTaskDivisionButtonEl.setAttribute('aria-pressed', hasItems ? 'true' : 'false');
        projectTaskDivisionButtonEl.style.background = hasItems ? 'var(--accent)' : '';
        projectTaskDivisionButtonEl.style.color = hasItems ? '#111' : '';
        projectTaskDivisionButtonEl.style.borderColor = hasItems ? 'var(--accent)' : '';
    }

    function updateProjectTaskDivisionVisibility() {
        if (!projectTaskDivisionButtonRowEl) return;
        projectTaskDivisionButtonRowEl.style.display = projectDivisionEnabled ? 'flex' : 'none';
        updateProjectTaskDivisionButtonState();
    }

    function updateProjectTaskDivisionLineNumbers() {
        if (!projectTaskDivisionTextareaEl || !projectTaskDivisionLineNumbersEl) return;
        const lines = Math.max(1, projectTaskDivisionTextareaEl.value.split('\n').length);
        let out = '';
        for (let i = 1; i <= lines; i++) out += i + (i < lines ? '\n' : '');
        projectTaskDivisionLineNumbersEl.textContent = out;
        projectTaskDivisionLineNumbersEl.scrollTop = projectTaskDivisionTextareaEl.scrollTop;
    }

    function getCurrentProjectPopupTaskName() {
        const fromPending = String(pendingNewTaskName || '').trim();
        if (fromPending) return fromPending;
        const fromLabel = projectTaskNameEl ? String(projectTaskNameEl.textContent || '').trim() : '';
        if (fromLabel) return fromLabel;
        const fromInput = taskInputEl ? String(taskInputEl.value || '').trim() : '';
        return fromInput;
    }

    function refreshProjectTaskDivisionPopupState() {
        const currentName = getCurrentProjectPopupTaskName();
        if (currentName) pendingNewTaskName = currentName;
        updateProjectTaskDivisionVisibility();
        if (!projectTaskDivisionTextareaEl) return;
        const items = currentName ? getStoredProjectDivisionForName(currentName) : [];
        projectTaskDivisionTextareaEl.value = items.join('\n');
        updateProjectTaskDivisionLineNumbers();
    }

    function openProjectTaskDivisionModal() {
        if (!projectDivisionEnabled || !projectTaskDivisionOverlayEl || !projectTaskDivisionTextareaEl) return;
        const currentName = getCurrentProjectPopupTaskName();
        if (!currentName) return;
        pendingNewTaskName = currentName;
        refreshProjectTaskDivisionPopupState();
        projectTaskDivisionOverlayEl.classList.add('show');
        requestAnimationFrame(() => {
            refreshProjectTaskDivisionPopupState();
            projectTaskDivisionTextareaEl.focus();
            projectTaskDivisionTextareaEl.selectionStart = projectTaskDivisionTextareaEl.value.length;
            projectTaskDivisionTextareaEl.selectionEnd = projectTaskDivisionTextareaEl.value.length;
        });
    }

    function closeProjectTaskDivisionModal() {
        if (!projectTaskDivisionOverlayEl) return;
        projectTaskDivisionOverlayEl.classList.remove('show');
    }

    function saveProjectTaskDivisionFromModal() {
        if (!pendingNewTaskName || !projectTaskDivisionTextareaEl) return;
        const items = projectTaskDivisionTextareaEl.value.split('\n').map(v => v.trim()).filter(Boolean);
        setStoredProjectDivisionForName(pendingNewTaskName, items);
        saveToStorage();
        updateProjectTaskDivisionButtonState();
        closeProjectTaskDivisionModal();
    }

    function getStoredProjectDivisionItemsForDisplay(taskOrName) {
        const projectName = typeof taskOrName === 'string'
            ? String(taskOrName || '').trim()
            : String((taskOrName && taskOrName.name) || '').trim();
        if (!projectName) return [];
        return getStoredProjectDivisionForName(projectName);
    }

    function getWorkListProjectDivisionItems(task) {
        if (!projectDivisionEnabled || !task || !task.name) return [];
        return getStoredProjectDivisionItemsForDisplay(task);
    }

    function taskHasWorkListProjectDivision(task) {
        return getStoredProjectDivisionItemsForDisplay(task).length > 0;
    }

    function toggleWorkListProjectDivision(taskId) {
        const id = Number(taskId) || 0;
        if (!id) return false;
        const task = data.tasks.find(t => t.id === id);
        if (!taskHasWorkListProjectDivision(task)) return false;
        expandedProjectDivisionTaskId = (expandedProjectDivisionTaskId === id) ? null : id;
        updateUI();
        return true;
    }


    function isFavoriteForName(name) {
        const key = normalizeTaskName(name);
        if (!key) return false;
        if (!data.favorites || typeof data.favorites !== "object") data.favorites = {};
        return !!data.favorites[key];
    }

    function toggleFavoriteForName(name) {
        const key = normalizeTaskName(name);
        if (!key) return;
        if (!data.favorites || typeof data.favorites !== "object") data.favorites = {};
        if (!Array.isArray(data.favoritesOrder)) data.favoritesOrder = [];

        if (data.favorites[key]) {
            delete data.favorites[key];
            // remove from order list
            data.favoritesOrder = data.favoritesOrder.filter(k => k !== key);
        } else {
            data.favorites[key] = true;
            // move to top of favorites list
            data.favoritesOrder = data.favoritesOrder.filter(k => k !== key);
            data.favoritesOrder.unshift(key);
        }
        saveToStorage();
    }


    function renameTaskNameEverywhere(oldName, newName) {
        const oldKey = normalizeTaskName(oldName);
        const newKey = normalizeTaskName(newName);
        if (!oldKey || !newKey) return;
        if (oldKey === newKey) return;

        data.tasks.forEach(t => {
            if (normalizeTaskName(t.name) === oldKey) t.name = newName;
        });

        (data.archives || []).forEach(a => {
            (a.tasks || []).forEach(t => {
                if (normalizeTaskName(t.name) === oldKey) t.name = newName;
            });
        });

        if (Array.isArray(data.taskNames)) {
            data.taskNames = data.taskNames.map(n => (normalizeTaskName(n) === oldKey ? newName : n));

            const seen = new Set();
            data.taskNames = data.taskNames.filter(n => {
                const k = normalizeTaskName(n);
                if (!k) return false;
                if (seen.has(k)) return false;
                seen.add(k);
                return true;
            });
        }

        if (data.projectNumbers && typeof data.projectNumbers === "object") {
            const oldVal = data.projectNumbers[oldKey];
            if (oldVal && !data.projectNumbers[newKey]) {
                data.projectNumbers[newKey] = oldVal;
            }
            delete data.projectNumbers[oldKey];
            if (data.projectDivisions && typeof data.projectDivisions === "object") {
                const oldDiv = data.projectDivisions[oldKey];
                if (Array.isArray(oldDiv) && !Array.isArray(data.projectDivisions[newKey])) {
                    data.projectDivisions[newKey] = oldDiv.slice();
                }
                delete data.projectDivisions[oldKey];
            }
        
        ensureOutdatedData();
        if (data.outdated && typeof data.outdated === "object") {
            const entry = data.outdated[oldKey];
            if (entry && !data.outdated[newKey]) {
                data.outdated[newKey] = entry;
            }
            delete data.outdated[oldKey];
        }

}

        if (selectedTaskId) {
            const exists = data.tasks.some(t => t.id === selectedTaskId);
            if (!exists) selectedTaskId = null;
        }
    }
    function findTaskByName(name) {
        const key = normalizeTaskName(name);
        if (!key) return null;
        return data.tasks.find(t => normalizeTaskName(t.name) === key) || null;
    }

    function makeProjectDivisionTaskName(projectName, subTaskName) {
        const p = String(projectName || '').trim();
        const s = String(subTaskName || '').trim();
        if (!p || !s) return '';
        return p + ' — ' + s;
    }

    function getTaskDisplayLabel(task) {
        if (!task) return '';
        if (isProjectDivisionSubTask(task)) {
            return makeProjectDivisionTaskName(task.parentProject || '', task.subTaskName || '') || (task.name || '');
        }
        return task.name || '';
    }

    function isProjectDivisionSubTask(task) {
        return !!(task && typeof task.parentProject === 'string' && task.parentProject.trim() && typeof task.subTaskName === 'string' && task.subTaskName.trim());
    }

    function isProjectDivisionHistoryName(name) {
        const trimmed = String(name || '').trim();
        if (!trimmed || !data.projectDivisions || typeof data.projectDivisions !== 'object') return false;
        return Object.keys(data.projectDivisions).some((projectKey) => {
            const items = Array.isArray(data.projectDivisions[projectKey]) ? data.projectDivisions[projectKey] : [];
            const projectName = (data.taskNames || []).find(n => normalizeTaskName(n) === projectKey) || projectKey;
            return items.some(item => makeProjectDivisionTaskName(projectName, item) === trimmed);
        });
    }

    function findProjectDivisionTask(projectName, subTaskName) {
        const projectKey = normalizeTaskName(projectName);
        const subKey = normalizeTaskName(subTaskName);
        if (!projectKey || !subKey) return null;
        const compositeKey = normalizeTaskName(makeProjectDivisionTaskName(projectName, subTaskName));
        const matches = data.tasks.filter(t => {
            const directMatch = normalizeTaskName(t.parentProject || '') === projectKey && normalizeTaskName(t.subTaskName || '') === subKey;
            const legacyMatch = !directMatch && normalizeTaskName(t.name || '') === compositeKey;
            return directMatch || legacyMatch;
        });
        if (!matches.length) return null;
        matches.sort((a, b) => {
            if (!!a.isActive !== !!b.isActive) return a.isActive ? -1 : 1;
            const aStamp = Number(a.lastStartMs || a.createdAt || 0);
            const bStamp = Number(b.lastStartMs || b.createdAt || 0);
            if (aStamp !== bStamp) return bStamp - aStamp;
            return getTaskElapsedMs(b) - getTaskElapsedMs(a);
        });
        return matches[0] || null;
    }

    function startOrResumeProjectDivisionTask(projectName, subTaskName) {
        const project = String(projectName || '').trim();
        const subTask = String(subTaskName || '').trim();
        if (!project || !subTask) return;
        const nextSelection = makeProjectDivisionSelection(project, subTask);
        const existing = findProjectDivisionTask(project, subTask);
        if (existing) {
            selectedProjectDivisionTarget = nextSelection;
            if (existing.isActive) {
                selectedTaskId = null;
                saveToStorage();
                updateUI();
                return;
            }
            const isFreshCommentOnlyInstance = !existing.firstStartAt && !existing.lastStartMs && !existing.isActive && Number(existing.totalMs || 0) <= 0;
            if (isFreshCommentOnlyInstance) {
                finalizeActiveTask();
                const idx = data.tasks.findIndex(t => t.id === existing.id);
                if (idx > 0) {
                    data.tasks.splice(idx, 1);
                    data.tasks.unshift(existing);
                }
                const now = Date.now();
                existing.isActive = true;
                existing.lastStartMs = now;
                existing.firstStartAt = existing.firstStartAt || now;
                existing.lastEndAt = null;
                existing.resumed = false;
                existing.resumeCount = Number(existing.resumeCount || 0);
                selectedTaskId = null;
                saveToStorage();
                updateUI();
                return;
            }
            resumeTask(existing.id);
            selectedProjectDivisionTarget = nextSelection;
            updateUI();
            return;
        }
        const compositeName = makeProjectDivisionTaskName(project, subTask);
        const storedPN = getStoredProjectNumberForName(project).trim();
        startNewTask(compositeName, storedPN, {
            parentProject: project,
            subTaskName: subTask
        });
        selectedProjectDivisionTarget = nextSelection;
        updateUI();
    }

    function getProjectDivisionTaskDisplayMs(task) {
        if (!task) return 0;
        const rawMs = task.isActive ? getTaskElapsedMs(task) : (task.totalMs || getTaskElapsedMs(task));
        return isRoundingEnabled ? getRoundedMs(rawMs) : rawMs;
    }

    function getProjectDivisionParentRawMs(projectName) {
        const projectKey = normalizeTaskName(projectName);
        if (!projectKey) return 0;
        return data.tasks.reduce((sum, task) => {
            if (isProjectDivisionSubTask(task)) return sum;
            if (normalizeTaskName(task.name || '') !== projectKey) return sum;
            return sum + (task.isActive ? getTaskElapsedMs(task) : (task.totalMs || 0));
        }, 0);
    }

    function getProjectDivisionTotalRawMs(projectName) {
        const projectKey = normalizeTaskName(projectName);
        if (!projectKey) return 0;
        return data.tasks.reduce((sum, task) => {
            if (normalizeTaskName(task.name || '') === projectKey || normalizeTaskName(task.parentProject || '') === projectKey) {
                return sum + (task.isActive ? getTaskElapsedMs(task) : (task.totalMs || 0));
            }
            return sum;
        }, 0);
    }

    function getProjectDivisionParentDisplayRawMs(projectName) {
        return projectDivisionEnabled
            ? getProjectDivisionParentRawMs(projectName)
            : getProjectDivisionTotalRawMs(projectName);
    }

    function hasLiveProjectDivisionSeconds(projectName) {
        const projectKey = normalizeTaskName(projectName);
        if (!projectKey) return false;
        return data.tasks.some(task => {
            if (!(normalizeTaskName(task.name || '') === projectKey || normalizeTaskName(task.parentProject || '') === projectKey)) return false;
            return shouldShowWorkListSecondsForTask(task);
        });
    }

    function getProjectDivisionSubtaskRawMs(projectName) {
        const projectKey = normalizeTaskName(projectName);
        if (!projectKey) return 0;
        return data.tasks.reduce((sum, task) => {
            if (normalizeTaskName(task.parentProject || '') !== projectKey) return sum;
            return sum + (task.isActive ? getTaskElapsedMs(task) : (task.totalMs || 0));
        }, 0);
    }

    function shouldShowProjectDivisionArrow(task) {
        if (!task) return false;
        const storedItems = getStoredProjectDivisionItemsForDisplay(task);
        if (!storedItems.length) return false;
        return projectDivisionEnabled || getProjectDivisionSubtaskRawMs(task.name) > 0;
    }

    function resolveLiveProjectDivisionTask(projectName, subTaskName, fallbackTaskId = 0) {
        const liveTask = findProjectDivisionTask(projectName, subTaskName);
        if (liveTask) return liveTask;
        const fallbackId = Number(fallbackTaskId || 0);
        if (!fallbackId) return null;
        return data.tasks.find(t => Number(t.id) === fallbackId) || null;
    }

    function makeProjectDivisionSelection(projectName, subTaskName) {
        const project = String(projectName || '').trim();
        const subTask = String(subTaskName || '').trim();
        if (!project || !subTask) return null;
        return { projectName: project, subTaskName: subTask };
    }

    function isSameProjectDivisionSelection(a, b) {
        if (!a || !b) return false;
        return normalizeTaskName(a.projectName) === normalizeTaskName(b.projectName)
            && normalizeTaskName(a.subTaskName) === normalizeTaskName(b.subTaskName);
    }

    function isSelectedProjectDivision(projectName, subTaskName) {
        return isSameProjectDivisionSelection(selectedProjectDivisionTarget, makeProjectDivisionSelection(projectName, subTaskName));
    }

    function getProjectDivisionTotalDisplayMs(projectName) {
        const projectKey = normalizeTaskName(projectName);
        if (!projectKey) return 0;
        return data.tasks.reduce((sum, task) => {
            if (normalizeTaskName(task.name || '') === projectKey || normalizeTaskName(task.parentProject || '') === projectKey) {
                return sum + getProjectDivisionTaskDisplayMs(task);
            }
            return sum;
        }, 0);
    }

    function startOrResumeByName(name) {
        if (!canStartOrResumeWorkNow(true)) return;
        const trimmed = (name || "").trim();
        if (!trimmed) return;
        const existing = findTaskByName(trimmed);
        
        // Reset to Setup mode when starting/resuming a task
        saveTimelineMode('setup');

        clearAutoOutdatedForName(trimmed);
        if (existing) {
            if (existing.isActive) {
                selectedTaskId = null;
                taskInputEl.value = "";
                clearSuggestions();
                overduePopupShown = false;
                saveToStorage();
                updateUI();
                disableCompactMode(); 
                return;
            }
            resumeTask(existing.id);
            return;
        }
        const storedPN = getStoredProjectNumberForName(trimmed).trim();
        taskInputEl.value = "";
        clearSuggestions();
        if (storedPN) {
            startNewTask(trimmed, storedPN);
            return;
        }
        showProjectPopup(trimmed);
    }

    function startNewTask(name, projectNumber, extra = null) {
        if (!canStartOrResumeWorkNow(true)) return;
        if (!name) return;
        // Reset to Setup mode when starting a new task
        saveTimelineMode('setup');
        
        finalizeActiveTask();
        const now = Date.now();
        const pn = (typeof projectNumber === "string") ? projectNumber.trim() : "";
        const newTask = {
            id: now, name: name, totalMs: 0, isActive: true, lastStartMs: now, resumed: false,
            createdAt: now, firstStartAt: now, lastEndAt: null, resumeCount: 0,
            comment: "", startAdjusted: false, projectNumber: pn,
            parentProject: extra && typeof extra.parentProject === 'string' ? extra.parentProject.trim() : '',
            subTaskName: extra && typeof extra.subTaskName === 'string' ? extra.subTaskName.trim() : ''
        };
        if (pn) setStoredProjectNumberForName(name, pn);
        data.tasks.unshift(newTask);
        selectedTaskId = null;
        selectedProjectDivisionTarget = null;
        expandedCommentTaskId = null;
        addTaskNameToHistory(name);
        taskInputEl.value = "";
        clearSuggestions();
        overduePopupShown = false;
        oneNoteReminderCurrentTasksCopySignature = "";
        saveToStorage();
        disableCompactMode(); 
        updateUI();
    }

    function resumeTask(taskId) {
        if (!canStartOrResumeWorkNow(true)) return;
        if (!taskId) return;
        
        // Reset to Setup mode when resuming a task
        saveTimelineMode('setup');

        const idx = data.tasks.findIndex(t => t.id === taskId);
        if (idx === -1) return;
        const activeIdx = getActiveTaskIndex();
        if (activeIdx !== -1 && data.tasks[activeIdx].id !== taskId) finalizeActiveTask();
        
        const task = data.tasks[idx];
        if (idx > 0) {
            data.tasks.splice(idx, 1);
            data.tasks.unshift(task);
        }
        task.isActive = true;
        task.lastStartMs = Date.now();
        task.resumed = true;
        task.resumeCount = (task.resumeCount || 0) + 1;
        if (typeof task.comment !== "string") task.comment = "";
        if (typeof task.startAdjusted !== "boolean") task.startAdjusted = false;
        if (typeof task.projectNumber !== "string") task.projectNumber = "";
        if (typeof task.parentProject !== "string") task.parentProject = "";
        if (typeof task.subTaskName !== "string") task.subTaskName = "";
        
        const pn = (task.projectNumber || "").trim();
        if (pn) setStoredProjectNumberForName(task.name, pn);
        addTaskNameToHistory(task.name);
        selectedTaskId = null;
        expandedCommentTaskId = null;
        taskInputEl.value = "";
        clearSuggestions();
        overduePopupShown = false;
        saveToStorage();
        disableCompactMode(); 
        updateUI();
    }

    function clearAndArchiveTasks(archiveBaseTs = null) {
        overduePopupShown = false;
        finalizeTemporaryMidnightGuardSuspend();
        const tasksToCopy = copySourceTasks || data.tasks;
            if (tasksToCopy.length === 0) return;
        const now = new Date();
        const archiveTimestamp = (archiveBaseTs && !isNaN(archiveBaseTs)) ? archiveBaseTs : now.getTime();
        const archiveDateObj = new Date(archiveTimestamp);
        
        const snapshotTasks = data.tasks.map(t => {
            const totalMs = getTaskElapsedMs(t);
            let lastEndAt = t.lastEndAt;
            if (!lastEndAt) lastEndAt = archiveTimestamp;
            const createdAt = t.createdAt || t.firstStartAt || archiveTimestamp;
            const firstStartAt = t.firstStartAt || t.createdAt || archiveTimestamp;
            const resumeCount = t.resumeCount || 0;
            const comment = typeof t.comment === "string" ? t.comment : "";
            const projectNumber = typeof t.projectNumber === "string" ? t.projectNumber : "";
            if (projectNumber.trim()) setStoredProjectNumberForName(t.name, projectNumber);
            return {
                id: t.id, name: t.name, totalMs, resumed: !!t.resumed,
                createdAt, firstStartAt, lastEndAt, resumeCount, projectNumber, comment
            };
        });

        const label = archiveDateObj.toLocaleDateString("nb-NO", {
            weekday: "long", year: "numeric", month: "short", day: "numeric"
        });
        const archiveEntry = {
            id: now.getTime(), label, createdAt: archiveDateObj.toISOString(), tasks: snapshotTasks
        };
        try {
            const adhdRowsSnapshot = buildAdhdBreakdownRows().map((r, i) => ({
                index: Number.isFinite(Number(r && r.index)) ? Number(r.index) : i,
                name: (r && typeof r.name === 'string') ? r.name : '',
                comment: (r && typeof r.comment === 'string') ? r.comment : '',
                elapsedMs: (r && Number.isFinite(Number(r.elapsedMs)) && Number(r.elapsedMs) > 0) ? Number(r.elapsedMs) : 0,
                startMs: (r && Number.isFinite(Number(r.startMs))) ? Number(r.startMs) : null,
                endMs: (r && Number.isFinite(Number(r.endMs))) ? Number(r.endMs) : null
            })).filter(r => (r.name || '').trim() !== '' || (r.comment || '').trim() !== '' || (r.elapsedMs || 0) > 0);
            if (adhdRowsSnapshot.length) {
                archiveEntry.adhdBreakdown = {
                    rows: adhdRowsSnapshot,
                    totalMs: adhdRowsSnapshot.reduce((sum, r) => sum + (r.elapsedMs || 0), 0),
                    savedAt: new Date().toISOString()
                };
            }
        } catch (e) {}
        data.archives.unshift(archiveEntry);
        data.tasks = [];
        selectedTaskId = null;
        expandedCommentTaskId = null;
        showAllComments = false;
        overduePopupShown = false;

        // Reset timeline to default view
        saveTimelineMode('setup');

        saveToStorage();
        disableCompactMode(); 
        updateUI();
    }

    function showProjectPopup(taskName) {
        projectPopupMode = "start";
        projectEditOriginalName = null;
        if (projectNameEditRowEl) projectNameEditRowEl.style.display = "none";
        if (projectOutdatedWrapEl) projectOutdatedWrapEl.style.display = "none";
        if (projectNameEditInputEl) projectNameEditInputEl.value = "";
        if (projectOutdatedCheckboxEl) projectOutdatedCheckboxEl.checked = false;
        if (projectOutdatedWrapEl) projectOutdatedWrapEl.style.display = "none";
        if (projectConfirmButtonEl) projectConfirmButtonEl.textContent = projectConfirmDefaultText;

        loadProjectDivisionToggleSetting();
        pendingNewTaskName = (taskName || "").trim();
        if (!pendingNewTaskName) return;
        projectTaskNameEl.textContent = pendingNewTaskName;
        projectNumberInputEl.value = getStoredProjectNumberForName(pendingNewTaskName) || "";
        if (projectOutdatedCheckboxEl) projectOutdatedCheckboxEl.checked = isOutdatedForName(pendingNewTaskName);
        refreshProjectTaskDivisionPopupState();
        projectOverlayEl.classList.add("show");
        requestAnimationFrame(() => refreshProjectTaskDivisionPopupState());
        setTimeout(() => {
            refreshProjectTaskDivisionPopupState();
            if (projectPopupMode === "edit" && projectNameEditInputEl) projectNameEditInputEl.focus();
            else projectNumberInputEl.focus();
        }, 0);
    }

    // Opens the same popup, but only for editing the stored project number (no task start)
    function showProjectEditPopup(taskName) {
        projectPopupMode = "edit";
        if (projectConfirmButtonEl) projectConfirmButtonEl.textContent = "Lagre";

        loadProjectDivisionToggleSetting();
        pendingNewTaskName = (taskName || "").trim();
        projectEditOriginalName = pendingNewTaskName;
        if (projectNameEditRowEl) projectNameEditRowEl.style.display = "block";
        if (projectOutdatedWrapEl) projectOutdatedWrapEl.style.display = "flex";
        if (projectNameEditInputEl) projectNameEditInputEl.value = pendingNewTaskName;
        if (!pendingNewTaskName) return;
        projectTaskNameEl.textContent = pendingNewTaskName;
        projectNumberInputEl.value = getStoredProjectNumberForName(pendingNewTaskName) || "";

        // Ensure checkbox visual state doesn't carry over from previously edited projects
        if (projectOutdatedCheckboxEl) {
            projectOutdatedCheckboxEl.checked = isOutdatedForName(pendingNewTaskName);
        }

        refreshProjectTaskDivisionPopupState();
        projectOverlayEl.classList.add("show");
        requestAnimationFrame(() => refreshProjectTaskDivisionPopupState());
        setTimeout(() => {
            refreshProjectTaskDivisionPopupState();
            if (projectPopupMode === "edit" && projectNameEditInputEl) projectNameEditInputEl.focus();
            else projectNumberInputEl.focus();
        }, 0);
    }

    function hideProjectPopup() {
        projectOverlayEl.classList.remove("show");
        pendingNewTaskName = null;
        projectEditOriginalName = null;
        projectNumberInputEl.value = "";
        if (projectNameEditInputEl) projectNameEditInputEl.value = "";
        if (projectNameEditRowEl) projectNameEditRowEl.style.display = "none";
        updateProjectTaskDivisionVisibility();
        closeProjectTaskDivisionModal();
        projectPopupMode = "start";
        if (projectConfirmButtonEl) projectConfirmButtonEl.textContent = projectConfirmDefaultText;
    }

    function confirmProjectPopup() {
        if (!pendingNewTaskName) return;
        const projectNo = (projectNumberInputEl.value || "").trim();

        if (projectPopupMode === "edit") {
            const newName = (projectNameEditInputEl ? projectNameEditInputEl.value : pendingNewTaskName || "").trim();
            const finalName = newName || pendingNewTaskName;

            if (projectEditOriginalName && finalName && normalizeTaskName(finalName) !== normalizeTaskName(projectEditOriginalName)) {
                renameTaskNameEverywhere(projectEditOriginalName, finalName);
            }

            setStoredProjectNumberForName(finalName, projectNo);

            // Utgått (manuell markering)
            if (projectOutdatedCheckboxEl) {
                setOutdatedForName(finalName, projectOutdatedCheckboxEl.checked, true);
            }

            const key = normalizeTaskName(finalName);
            if (key) {
                data.tasks.forEach(t => {
                    if (normalizeTaskName(t.name) === key) t.projectNumber = projectNo;
                });
                (data.archives || []).forEach(a => {
                    (a.tasks || []).forEach(t => {
                        if (normalizeTaskName(t.name) === key) t.projectNumber = projectNo;
                    });
                });
            }

            saveToStorage();
            updateUI();
            hideProjectPopup();
            return;
        }
startNewTask(pendingNewTaskName, projectNo);
        hideProjectPopup();
    }

    function ensureProjectDivisionTask(projectName, subTaskName) {
        const existing = findProjectDivisionTask(projectName, subTaskName);
        if (existing) {
            if (typeof existing.comment !== "string") existing.comment = "";
            return existing;
        }
        const now = Date.now() + Math.floor(Math.random() * 1000);
        const compositeName = makeProjectDivisionTaskName(projectName, subTaskName);
        const pn = getStoredProjectNumberForName(projectName).trim();
        const newTask = {
            id: now,
            name: compositeName,
            totalMs: 0,
            isActive: false,
            lastStartMs: null,
            resumed: false,
            createdAt: now,
            firstStartAt: null,
            lastEndAt: now,
            resumeCount: 0,
            comment: "",
            startAdjusted: false,
            projectNumber: pn,
            parentProject: String(projectName || '').trim(),
            subTaskName: String(subTaskName || '').trim()
        };
        data.tasks.push(newTask);
        return newTask;
    }

    function showCommentPopup(task) {
        if (!task) return;
        commentEditingTaskId = task.id;
        commentTaskNameEl.textContent = task.name || "";
        commentTextareaEl.value = typeof task.comment === "string" ? task.comment : "";
        commentOverlayEl.classList.add("show");
        setTimeout(() => commentTextareaEl.focus(), 0);
    }
    function hideCommentPopup() {
        commentOverlayEl.classList.remove("show");
        commentEditingTaskId = null;
        commentTextareaEl.oninput = null;
    }
    function saveComment() {
        if (!commentEditingTaskId) return;
        const task = data.tasks.find(t => t.id === commentEditingTaskId);
        if (!task) return;
        task.comment = commentTextareaEl.value || "";
        saveToStorage();
        updateUI();
        hideCommentPopup();
    }

    function toggleCommentDropdown(taskId) {
        if (!taskId) return;
        if (expandedCommentTaskId === taskId) expandedCommentTaskId = null;
        else expandedCommentTaskId = taskId;
    }
    function hasAnyCommentsInTasks() {
        return Array.isArray(data.tasks) && data.tasks.some(t => (t && typeof t.comment === "string" && t.comment.trim().length > 0));
    }

    function initTransferSelects() {
        if (transferHoursEl.options.length === 0) {
            for (let h = 0; h <= 12; h++) {
                const opt = document.createElement("option");
                opt.value = h;
                opt.textContent = String(h).padStart(2, "0");
                transferHoursEl.appendChild(opt);
            }
        }
        if (transferMinutesEl.options.length === 0) {
            for (let m = 0; m < 60; m += 1) {
                const opt = document.createElement("option");
                opt.value = m;
                opt.textContent = String(m).padStart(2, "0");
                transferMinutesEl.appendChild(opt);
            }
        }
    }
    function getTransferAmountMs() {
        const h = parseInt(transferHoursEl.value, 10) || 0;
        const m = parseInt(transferMinutesEl.value, 10) || 0;
        return (h * 60 + m) * 60 * 1000;
    }
    function getTaskAvailableMs(task) {
        if (!task) return 0;
        return getTaskElapsedMs(task);
    }
    function getProjectAggregateTasks(projectTask) {
        if (!projectTask) return [];
        const projectKey = normalizeTaskName(projectTask.name || '');
        if (!projectKey) return projectTask ? [projectTask] : [];
        const matches = data.tasks.filter(task => {
            if (!task) return false;
            if (Number(task.id) === Number(projectTask.id)) return true;
            return normalizeTaskName(task.parentProject || '') === projectKey;
        });
        matches.sort((a, b) => {
            const aIsParent = Number(a.id) === Number(projectTask.id);
            const bIsParent = Number(b.id) === Number(projectTask.id);
            if (aIsParent !== bIsParent) return aIsParent ? -1 : 1;
            if (!!a.isActive !== !!b.isActive) return a.isActive ? -1 : 1;
            const aStamp = Number(a.lastStartMs || a.createdAt || 0);
            const bStamp = Number(b.lastStartMs || b.createdAt || 0);
            if (aStamp !== bStamp) return bStamp - aStamp;
            return getTaskElapsedMs(b) - getTaskElapsedMs(a);
        });
        return matches;
    }
    function getProjectAggregateAvailableMs(projectTask) {
        return getProjectAggregateTasks(projectTask).reduce((sum, task) => sum + getTaskElapsedMs(task), 0);
    }
    function reduceTimeFromProjectAggregate(projectTask, amountMs) {
        let remaining = Math.max(0, amountMs || 0);
        if (!projectTask || remaining <= 0) return false;
        const matches = getProjectAggregateTasks(projectTask);
        if (!matches.length) return false;
        for (const task of matches) {
            if (remaining <= 0) break;
            const available = getTaskElapsedMs(task);
            if (available <= 0) continue;
            const slice = Math.min(remaining, available);
            reduceTimeFromTask(task, slice);
            remaining -= slice;
        }
        return remaining < amountMs;
    }
    function getTransferTopLevelTasks() {
        return data.tasks.filter(t => !isProjectDivisionSubTask(t));
    }
    function canTransferWithinSingleProject() {
        if (!projectDivisionEnabled) return false;
        const topLevelTasks = getTransferTopLevelTasks();
        if (topLevelTasks.length !== 1) return false;
        const projectTask = topLevelTasks[0] || null;
        if (!projectTask) return false;
        const items = getStoredProjectDivisionItemsForDisplay(projectTask);
        if (!items.length) return false;
        return getProjectAggregateAvailableMs(projectTask) > 0;
    }
    function canUseTransferBetweenProjectsOrSubtasks() {
        const topLevelTasks = getTransferTopLevelTasks();
        const hasAnyTime = topLevelTasks.some(t => getProjectAggregateAvailableMs(t) > 0);
        if (!hasAnyTime) return false;
        if (topLevelTasks.length >= 2) return true;
        return canTransferWithinSingleProject();
    }
    function getTransferProjectDivisionItems(taskOrName) {
        if (!projectDivisionEnabled) return [];
        const projectName = typeof taskOrName === 'string'
            ? String(taskOrName || '').trim()
            : String((taskOrName && taskOrName.name) || '').trim();
        if (!projectName) return [];
        return getStoredProjectDivisionForName(projectName);
    }
    function fillTransferSubtaskSelect(selectEl, wrapEl, projectTask, preferredValue = '', includeProjectOption = false) {
        if (!selectEl || !wrapEl) return;
        const items = getTransferProjectDivisionItems(projectTask);
        selectEl.innerHTML = '';
        if (!items.length) {
            wrapEl.style.display = 'none';
            selectEl.value = '';
            return;
        }
        if (includeProjectOption) {
            const projectOpt = document.createElement('option');
            projectOpt.value = '';
            projectOpt.textContent = 'Kun prosjektet';
            selectEl.appendChild(projectOpt);
        }
        items.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item;
            opt.textContent = item;
            selectEl.appendChild(opt);
        });
        wrapEl.style.display = 'flex';
        const nextValue = ((preferredValue === '' && includeProjectOption) || items.includes(preferredValue))
            ? preferredValue
            : (includeProjectOption ? '' : items[0]);
        selectEl.value = nextValue;
    }
    function getTransferSourceSelection() {
        const sourceId = Number(transferSourceEl.value);
        const projectTask = data.tasks.find(t => t.id === sourceId) || null;
        if (!projectTask) return { projectTask: null, effectiveTask: null, selectedSubtask: '', label: '', availableMs: 0, usesAggregate: false };
        const selectedSubtask = (transferSourceSubtaskWrapEl && transferSourceSubtaskWrapEl.style.display !== 'none')
            ? String(transferSourceSubtaskEl.value || '').trim()
            : '';
        const effectiveTask = selectedSubtask ? findProjectDivisionTask(projectTask.name, selectedSubtask) : projectTask;
        const usesAggregate = !selectedSubtask;
        const availableMs = selectedSubtask ? getTaskAvailableMs(effectiveTask) : getProjectAggregateAvailableMs(projectTask);
        const label = selectedSubtask ? `${projectTask.name} → ${selectedSubtask}` : projectTask.name;
        return { projectTask, effectiveTask, selectedSubtask, label, availableMs, usesAggregate };
    }
    function getTransferTargetSelection() {
        const targetId = Number(transferTargetEl.value);
        const projectTask = data.tasks.find(t => t.id === targetId) || null;
        if (!projectTask) return { projectTask: null, effectiveTask: null, label: '' };
        const selectedSubtask = (transferTargetSubtaskWrapEl && transferTargetSubtaskWrapEl.style.display !== 'none')
            ? String(transferTargetSubtaskEl.value || '').trim()
            : '';
        const effectiveTask = selectedSubtask ? ensureProjectDivisionTask(projectTask.name, selectedSubtask) : projectTask;
        const label = selectedSubtask ? `${projectTask.name} → ${selectedSubtask}` : projectTask.name;
        return { projectTask, effectiveTask, selectedSubtask, label };
    }
    function fillAdjustTargetSubtaskSelect(projectTask, preferredValue = '') {
        if (!adjustStartTargetSubtaskEl || !adjustStartTargetSubtaskWrapEl) return;
        const items = projectDivisionEnabled ? getStoredProjectDivisionItemsForDisplay(projectTask) : [];
        adjustStartTargetSubtaskEl.innerHTML = '';
        if (!items.length) {
            adjustStartTargetSubtaskWrapEl.style.display = 'none';
            adjustStartTargetSubtaskEl.value = '';
            return;
        }
        const projectOpt = document.createElement('option');
        projectOpt.value = '';
        projectOpt.textContent = 'Kun prosjektet';
        adjustStartTargetSubtaskEl.appendChild(projectOpt);
        items.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item;
            opt.textContent = item;
            adjustStartTargetSubtaskEl.appendChild(opt);
        });
        adjustStartTargetSubtaskWrapEl.style.display = 'flex';
        const nextValue = (preferredValue === '' || items.includes(preferredValue)) ? preferredValue : '';
        adjustStartTargetSubtaskEl.value = nextValue;
    }
    function getAdjustTargetSelection(createIfMissing = false) {
        const targetId = Number(adjustStartTargetEl && adjustStartTargetEl.value);
        const projectTask = data.tasks.find(t => Number(t.id) === targetId) || null;
        if (!projectTask) return { projectTask: null, effectiveTask: null, selectedSubtask: '', label: '' };
        const selectedSubtask = (adjustStartTargetSubtaskWrapEl && adjustStartTargetSubtaskWrapEl.style.display !== 'none')
            ? String(adjustStartTargetSubtaskEl.value || '').trim()
            : '';
        let effectiveTask = projectTask;
        if (selectedSubtask) {
            effectiveTask = findProjectDivisionTask(projectTask.name, selectedSubtask) || null;
            if (!effectiveTask && createIfMissing) {
                effectiveTask = ensureProjectDivisionTask(projectTask.name, selectedSubtask);
            }
        }
        const label = selectedSubtask ? `${projectTask.name} → ${selectedSubtask}` : projectTask.name;
        return { projectTask, effectiveTask, selectedSubtask, label };
    }
    function initAdjustTargetSelects() {
        if (!adjustStartTargetEl || !adjustStartTargetRowEl) return;
        const topLevelTasks = getTransferTopLevelTasks();
        adjustStartTargetEl.innerHTML = '';
        if (adjustStartTargetSubtaskEl) adjustStartTargetSubtaskEl.innerHTML = '';
        topLevelTasks.forEach(t => {
            const opt = document.createElement('option');
            opt.value = String(t.id);
            opt.textContent = t.isActive ? (t.name + ' (aktiv)') : t.name;
            adjustStartTargetEl.appendChild(opt);
        });
        const selectedTopLevel = selectedTaskId
            ? (data.tasks.find(t => Number(t.id) === Number(selectedTaskId)) || null)
            : null;
        const activeTask = getActiveTask();
        let preferredProjectName = '';
        let preferredSubtask = '';
        if (selectedTopLevel && !isProjectDivisionSubTask(selectedTopLevel)) {
            preferredProjectName = selectedTopLevel.name || '';
        } else if (selectedTopLevel && isProjectDivisionSubTask(selectedTopLevel)) {
            preferredProjectName = selectedTopLevel.parentProject || '';
            preferredSubtask = selectedTopLevel.subTaskName || '';
        } else if (selectedProjectDivisionTarget) {
            preferredProjectName = selectedProjectDivisionTarget.projectName || '';
            preferredSubtask = selectedProjectDivisionTarget.subTaskName || '';
        } else if (activeTask && isProjectDivisionSubTask(activeTask)) {
            preferredProjectName = activeTask.parentProject || '';
            preferredSubtask = activeTask.subTaskName || '';
        } else if (activeTask) {
            preferredProjectName = activeTask.name || '';
        }
        let preferredTask = topLevelTasks.find(t => normalizeTaskName(t.name) === normalizeTaskName(preferredProjectName)) || null;
        if (!preferredTask && activeTask) {
            preferredTask = isProjectDivisionSubTask(activeTask)
                ? topLevelTasks.find(t => normalizeTaskName(t.name) === normalizeTaskName(activeTask.parentProject || '')) || null
                : topLevelTasks.find(t => Number(t.id) === Number(activeTask.id)) || null;
        }
        if (!preferredTask && topLevelTasks.length) preferredTask = topLevelTasks[0];
        adjustStartTargetEl.value = preferredTask ? String(preferredTask.id) : '';
        fillAdjustTargetSubtaskSelect(preferredTask, preferredSubtask);
        const hasDivisionChoices = !!(projectDivisionEnabled && topLevelTasks.length);
        adjustStartTargetRowEl.style.display = hasDivisionChoices ? 'flex' : 'none';
        const refreshAdjustDialogHeading = () => {
            const selection = getAdjustTargetSelection();
            if (!selection.label) return;
            if (adjustPopupMode === 'set-start') {
                adjustStartTitleEl.textContent = `Sett starttid - ${selection.label}`;
                adjustStartDescEl.textContent = `Endre starttidspunkt for: ${selection.label}.`;
            } else if (adjustPopupMode === 'subtract') {
                adjustStartTitleEl.textContent = `Trekk tid fra: ${selection.label}`;
                adjustStartDescEl.textContent = `Trekk fra tid på: ${selection.label}.`;
            } else {
                adjustStartTitleEl.textContent = `Tilfør tid på - ${selection.label}`;
                adjustStartDescEl.textContent = `Juster tid på: ${selection.label}.`;
            }
        };
        adjustStartTargetEl.onchange = () => {
            const projectTask = data.tasks.find(t => Number(t.id) === Number(adjustStartTargetEl.value)) || null;
            fillAdjustTargetSubtaskSelect(projectTask, '');
            refreshAdjustDialogHeading();
        };
        if (adjustStartTargetSubtaskEl) {
            adjustStartTargetSubtaskEl.onchange = () => {
                refreshAdjustDialogHeading();
            };
        }
        refreshAdjustDialogHeading();
    }
    function refreshTransferHint() {
        const sourceSelection = getTransferSourceSelection();
        const source = sourceSelection.effectiveTask;
        const maxMs = Math.max(0, Number(sourceSelection.availableMs || 0));
        const showSec = sourceSelection.usesAggregate
            ? hasLiveProjectDivisionSeconds(sourceSelection.projectTask ? sourceSelection.projectTask.name : '')
            : (source ? source.isActive : false);
        transferMaxHintEl.textContent = source
            ? `Maks tilgjengelig å overføre fra valgt prosjekt: ${sourceSelection.label} — ${formatDuration(maxMs, showSec)}`
            : '';
    }
    function showTransferPopup() {
        const topLevelTasks = getTransferTopLevelTasks();
        if (!canUseTransferBetweenProjectsOrSubtasks()) return;
        initTransferSelects();
        transferSourceEl.innerHTML = '';
        transferTargetEl.innerHTML = '';
        if (transferSourceSubtaskEl) transferSourceSubtaskEl.innerHTML = '';
        if (transferTargetSubtaskEl) transferTargetSubtaskEl.innerHTML = '';
        const sources = topLevelTasks.filter(t => getProjectAggregateAvailableMs(t) > 0);
        let defaultSourceId = null;
        if (selectedProjectDivisionTarget && selectedProjectDivisionTarget.projectName) {
            const selectedParent = topLevelTasks.find(t => normalizeTaskName(t.name) === normalizeTaskName(selectedProjectDivisionTarget.projectName));
            if (selectedParent) defaultSourceId = selectedParent.id;
        }
        if (!defaultSourceId && selectedTaskId) {
            const sel = data.tasks.find(t => t.id === selectedTaskId);
            if (sel && !isProjectDivisionSubTask(sel) && sources.some(s => s.id === sel.id)) defaultSourceId = sel.id;
            if (sel && isProjectDivisionSubTask(sel)) {
                const parent = topLevelTasks.find(t => normalizeTaskName(t.name) === normalizeTaskName(sel.parentProject || ''));
                if (parent && sources.some(s => s.id === parent.id)) defaultSourceId = parent.id;
            }
        }
        if (!defaultSourceId) {
            const active = getActiveTask();
            if (active && !isProjectDivisionSubTask(active) && sources.some(s => s.id === active.id)) defaultSourceId = active.id;
            if (active && isProjectDivisionSubTask(active)) {
                const parent = topLevelTasks.find(t => normalizeTaskName(t.name) === normalizeTaskName(active.parentProject || ''));
                if (parent && sources.some(s => s.id === parent.id)) defaultSourceId = parent.id;
            }
        }
        if (!defaultSourceId && sources.length > 0) defaultSourceId = sources[0].id;
        sources.forEach(t => {
            const opt = document.createElement('option');
            opt.value = String(t.id);
            opt.textContent = t.isActive ? (t.name + ' (aktiv)') : t.name;
            transferSourceEl.appendChild(opt);
        });
        transferSourceEl.value = String(defaultSourceId || (sources[0] ? sources[0].id : ''));
        function fillTargets() {
            const sourceId = Number(transferSourceEl.value);
            const currentTargetId = Number(transferTargetEl.value);
            transferTargetEl.innerHTML = '';
            topLevelTasks.forEach(t => {
                const opt = document.createElement('option');
                opt.value = String(t.id);
                opt.textContent = t.isActive ? (t.name + ' (aktiv)') : t.name;
                transferTargetEl.appendChild(opt);
            });
            const validTargetIds = Array.from(transferTargetEl.options).map(opt => Number(opt.value));
            const nextTargetId = validTargetIds.includes(currentTargetId) ? currentTargetId : (validTargetIds[0] || sourceId || '');
            transferTargetEl.value = String(nextTargetId || sourceId || '');
            const sourceTask = data.tasks.find(t => t.id === sourceId) || null;
            const targetTask = data.tasks.find(t => t.id === Number(transferTargetEl.value)) || null;
            const preferredSourceSubtask = selectedProjectDivisionTarget && sourceTask && normalizeTaskName(selectedProjectDivisionTarget.projectName) === normalizeTaskName(sourceTask.name)
                ? String(selectedProjectDivisionTarget.subTaskName || '')
                : (sourceTask && isProjectDivisionSubTask(getActiveTask()) && normalizeTaskName(getActiveTask().parentProject || '') === normalizeTaskName(sourceTask.name)
                    ? String(getActiveTask().subTaskName || '')
                    : '');
            const preferredTargetSubtask = targetTask && isProjectDivisionSubTask(getActiveTask()) && normalizeTaskName(getActiveTask().parentProject || '') === normalizeTaskName(targetTask.name)
                ? String(getActiveTask().subTaskName || '')
                : '';
            fillTransferSubtaskSelect(transferSourceSubtaskEl, transferSourceSubtaskWrapEl, sourceTask, preferredSourceSubtask, true);
            fillTransferSubtaskSelect(transferTargetSubtaskEl, transferTargetSubtaskWrapEl, targetTask, preferredTargetSubtask, true);
        }
        fillTargets();
        transferHoursEl.value = '00';
        transferMinutesEl.value = '05';
        refreshTransferHint();
        transferSourceEl.onchange = () => { fillTargets(); refreshTransferHint(); };
        transferTargetEl.onchange = () => {
            const targetTask = data.tasks.find(t => t.id === Number(transferTargetEl.value)) || null;
            fillTransferSubtaskSelect(transferTargetSubtaskEl, transferTargetSubtaskWrapEl, targetTask, transferTargetSubtaskEl.value, true);
        };
        if (transferSourceSubtaskEl) transferSourceSubtaskEl.onchange = refreshTransferHint;
        if (transferTargetSubtaskEl) transferTargetSubtaskEl.onchange = () => {};
        transferHoursEl.onchange = refreshTransferHint;
        transferMinutesEl.onchange = refreshTransferHint;
        transferOverlayEl.classList.add('show');
    }
    function hideTransferPopup() { transferOverlayEl.classList.remove("show"); }
    function reduceTimeFromTask(task, amountMs) {
        if (!task || amountMs <= 0) return false;
        if (task.isActive && task.lastStartMs) {
            const now = Date.now();
            const base = Math.max(0, task.totalMs || 0);
            const running = Math.max(0, now - task.lastStartMs);
            const available = base + running;
            const amt = Math.min(amountMs, available);
            if (amt <= base) {
                task.totalMs = base - amt;
            } else {
                const reduceFromRunning = amt - base;
                task.totalMs = 0;
                const newLastStart = task.lastStartMs + reduceFromRunning;
                task.lastStartMs = Math.min(now, Math.max(task.lastStartMs, newLastStart));
            }
            return true;
        } else {
            const base = Math.max(0, task.totalMs || 0);
            const amt = Math.min(amountMs, base);
            task.totalMs = base - amt;
            return true;
        }
    }
    function transferTimeConfirm() {
        const sourceSelection = getTransferSourceSelection();
        const targetSelection = getTransferTargetSelection();
        const sourceProjectId = Number(transferSourceEl.value);
        const targetProjectId = Number(transferTargetEl.value);
        if (!sourceProjectId || !targetProjectId || !sourceSelection.effectiveTask || !targetSelection.effectiveTask) return;
        if (sourceSelection.effectiveTask.id === targetSelection.effectiveTask.id) return;
        const amountMsRaw = getTransferAmountMs();
        if (amountMsRaw <= 0) { hideTransferPopup(); return; }
        const available = Math.max(0, Number(sourceSelection.availableMs || 0));
        const amountMs = Math.min(amountMsRaw, available);
        if (amountMs <= 0) { hideTransferPopup(); return; }
        targetSelection.effectiveTask.totalMs = Math.max(0, targetSelection.effectiveTask.totalMs || 0) + amountMs;
        if (sourceSelection.usesAggregate) reduceTimeFromProjectAggregate(sourceSelection.projectTask, amountMs);
        else reduceTimeFromTask(sourceSelection.effectiveTask, amountMs);
        saveToStorage();
        updateUI();
        hideTransferPopup();
    }

    let addedMinutesBuffer = 0;
    
    function initAdjustStartSelects() {
        if (adjustStartHourEl.options.length === 0) {
            for (let h = 0; h < 24; h++) {
                const opt = document.createElement("option");
                opt.value = h;
                opt.textContent = String(h).padStart(2, "0");
                adjustStartHourEl.appendChild(opt);
            }
        }
        if (adjustStartMinuteEl.options.length === 0) {
            for (let m = 0; m < 60; m++) {
                const opt = document.createElement("option");
                opt.value = m;
                opt.textContent = String(m).padStart(2, "0");
                adjustStartMinuteEl.appendChild(opt);
            }
        }
    }

    function canAdjustStartForActive() {
        const active = getActiveTask();
        return !!active;
    }
    function isAdjustButtonInSetStartMode() {
        return !!(adjustStartButtonEl && String(adjustStartButtonEl.textContent || '').trim() === 'Legg til starttid');
    }
    function hasAnyManualStartAdjustment() {
        return data.tasks.some(task => !!(task && task.startAdjusted));
    }
    function applySetStartTimeToTask(targetTask, newTs) {
        if (!targetTask || !Number.isFinite(newTs)) return false;
        const now = Date.now();
        const effectiveStart = Math.min(newTs, now);
        if (!targetTask.firstStartAt || effectiveStart < Number(targetTask.firstStartAt || 0)) {
            targetTask.firstStartAt = effectiveStart;
        }
        if (!targetTask.createdAt || effectiveStart < Number(targetTask.createdAt || 0)) {
            targetTask.createdAt = effectiveStart;
        }
        if (targetTask.isActive) {
            targetTask.lastStartMs = effectiveStart;
        } else {
            const computedMs = Math.max(0, now - effectiveStart);
            targetTask.totalMs = Math.max(Number(targetTask.totalMs || 0), computedMs);
            targetTask.lastEndAt = now;
        }
        targetTask.startAdjusted = true;
        return true;
    }
    function updateAddTimeDisplay() {
        const h = Math.floor(addedMinutesBuffer / 60);
        const m = addedMinutesBuffer % 60;
        adjustAddTimeDisplayEl.textContent = `${h}t ${m}min`;
    }
    function showAdjustStartPopup() {
        const active = getActiveTask();

        if (!active) {
            if (!(endDayPressedAtMs && data.tasks.length > 0)) return;

            adjustPopupMode = "subtract";
            adjustPopupTargetId = null;

            initAdjustTargetSelects();
            const selection = getAdjustTargetSelection(true);
            if (!selection.projectTask) return;
            adjustPopupTargetId = selection.projectTask.id;

            addedMinutesBuffer = 0;
            updateAddTimeDisplay();

            adjustStartTitleEl.textContent = selection.label ? `Trekk tid fra: ${selection.label}` : `Trekk tid fra: ${selection.projectTask.name}`;
            adjustStartDescEl.textContent = selection.label
                ? `Trekk fra tid på: ${selection.label}.`
                : "Trekk fra tid på valgt prosjekt.";

            adjustStartModeTimeEl.style.display = "none";
            adjustStartModeAddEl.style.display = "block";
            if (adjustStartTargetRowEl) {
                const shouldShowTargetRow = !!(projectDivisionEnabled && getTransferTopLevelTasks().length);
                adjustStartTargetRowEl.style.display = shouldShowTargetRow ? 'flex' : 'none';
            }

            if (adjustTimeStepperBtnEl) {
                adjustTimeStepperBtnEl.textContent = "-15 min";
                adjustTimeStepperBtnEl.classList.add("danger-stepper");
                adjustTimeStepperBtnEl.title = "Enkeltrykk: -15 min | Dobbeltrykk: +15 min (angre)";
            }
            if (adjustStepperHelpEl) {
                adjustStepperHelpEl.innerHTML = "Enkeltrykk = -15 min<br>Dobbeltrykk = +15 min (angre)";
            }

            adjustStartOverlayEl.classList.add("show");
            return;
        }

        adjustPopupMode = isAdjustButtonInSetStartMode() ? "set-start" : "add-duration";
        adjustPopupTargetId = null;
        if (adjustStartConfirmButtonEl) adjustStartConfirmButtonEl.classList.remove("danger");

        initAdjustStartSelects();
        initAdjustTargetSelects();

        if (adjustPopupMode === "set-start") {
            const selection = getAdjustTargetSelection(true);
            const targetTask = selection.effectiveTask || active;
            const d = new Date((targetTask && (targetTask.firstStartAt || targetTask.createdAt)) || active.firstStartAt || active.createdAt);
            adjustStartHourEl.value = d.getHours();
            adjustStartMinuteEl.value = d.getMinutes();

            adjustStartTitleEl.textContent = selection.label ? `Sett starttid - ${selection.label}` : "Sett starttid";
            adjustStartDescEl.textContent = selection.label
                ? `Endre starttidspunkt for: ${selection.label}.`
                : "Endre starttidspunkt for valgt prosjekt.";

            adjustStartModeTimeEl.style.display = "block";
            adjustStartModeAddEl.style.display = "none";
            if (adjustStartTargetRowEl) {
                const shouldShowTargetRow = !!getTransferTopLevelTasks().length;
                adjustStartTargetRowEl.style.display = shouldShowTargetRow ? 'flex' : 'none';
            }
        } else {
            addedMinutesBuffer = 0;
            updateAddTimeDisplay();

            if (adjustTimeStepperBtnEl) {
                adjustTimeStepperBtnEl.classList.remove("danger-stepper");
                adjustTimeStepperBtnEl.textContent = "+15 min";
                adjustTimeStepperBtnEl.title = "Enkeltrykk: +15 min | Dobbeltrykk: -15 min";
            }
            if (adjustStepperHelpEl) {
                adjustStepperHelpEl.innerHTML = "Enkeltrykk = +15 min<br>Dobbeltrykk = -15 min";
            }

            adjustStartModeTimeEl.style.display = "none";
            adjustStartModeAddEl.style.display = "block";
            const selection = getAdjustTargetSelection();
            const activeLabel = selection.label || getTaskDisplayLabel(active) || 'Ukjent prosjekt';
            adjustStartTitleEl.textContent = `Tilfør tid på - ${activeLabel}`;
            adjustStartDescEl.textContent = `Juster tid på: ${activeLabel}.`;
            if (adjustStartTargetRowEl) {
                const shouldShowTargetRow = !!getTransferTopLevelTasks().length;
                adjustStartTargetRowEl.style.display = shouldShowTargetRow ? 'flex' : 'none';
            }
        }

        adjustStartOverlayEl.classList.add("show");
    }
    function hideAdjustStartPopup() {
        if (adjustStartConfirmButtonEl) adjustStartConfirmButtonEl.classList.remove("danger"); adjustStartOverlayEl.classList.remove("show"); }
    function adjustStartConfirm() {
        const active = getActiveTask();
        if (!active && adjustPopupMode !== "subtract") return;

        if (adjustPopupMode === "subtract") {
            const selection = getAdjustTargetSelection(true);
            const targetProject = selection.projectTask || (data.tasks.find(t => t.id === adjustPopupTargetId) || null);
            if (!targetProject) { hideAdjustStartPopup(); return; }
            if (addedMinutesBuffer === 0) { hideAdjustStartPopup(); return; }
            const msToReduce = addedMinutesBuffer * 60 * 1000;
            if (selection.selectedSubtask && selection.effectiveTask) {
                reduceTimeFromTask(selection.effectiveTask, msToReduce);
            } else {
                reduceTimeFromProjectAggregate(targetProject, msToReduce);
            }
            saveToStorage();
            updateUI();
            hideAdjustStartPopup();
            return;
        }

        if (adjustPopupMode === "set-start") {
            const h = parseInt(adjustStartHourEl.value, 10);
            const m = parseInt(adjustStartMinuteEl.value, 10);
            const selection = getAdjustTargetSelection(true);
            const targetTask = selection.effectiveTask || active;
            if (!targetTask) { hideAdjustStartPopup(); return; }

            const baseDate = new Date((targetTask.firstStartAt || targetTask.createdAt || active.firstStartAt || active.createdAt));
            baseDate.setHours(h, m, 0, 0);
            const newTs = baseDate.getTime();
            applySetStartTimeToTask(targetTask, newTs);
        } else {
            if (addedMinutesBuffer === 0) { hideAdjustStartPopup(); return; }
            const msToAdd = addedMinutesBuffer * 60 * 1000;
            const selection = getAdjustTargetSelection(true);
            const targetTask = selection.effectiveTask || active;
            if (!targetTask) { hideAdjustStartPopup(); return; }
            if (targetTask.isActive && targetTask.lastStartMs) {
                targetTask.lastStartMs -= msToAdd;
            } else {
                targetTask.totalMs = (targetTask.totalMs || 0) + msToAdd;
            }
            if (!targetTask.isActive && targetTask.totalMs < 0) targetTask.totalMs = 0;
        }

        saveToStorage();
        updateUI();
        hideAdjustStartPopup();
    }
    let stepperClickCount = 0;
    let stepperTimer = null;
    if (adjustTimeStepperBtnEl) {
        adjustTimeStepperBtnEl.addEventListener("click", (e) => {
            e.preventDefault();
            stepperClickCount++;
            if (stepperClickCount === 1) {
                stepperTimer = setTimeout(() => {
                    addedMinutesBuffer += 15;
                    updateAddTimeDisplay();
                    stepperClickCount = 0;
                }, 250); 
            } else if (stepperClickCount === 2) {
                clearTimeout(stepperTimer);
                addedMinutesBuffer -= 15;
                if (addedMinutesBuffer < 0) addedMinutesBuffer = 0; 
                updateAddTimeDisplay();
                stepperClickCount = 0;
                adjustTimeStepperBtnEl.classList.add('btn-orange-flash');
                setTimeout(() => { adjustTimeStepperBtnEl.classList.remove('btn-orange-flash'); }, 1000);
            }
        });
    }

    function isArchiveSameDateAsToday(archive) {
        if (!archive) return false;
        const today = Date.now();
        const ts = archive.createdAt ? new Date(archive.createdAt).getTime() : (archive.id || 0);
        return sameLocalDate(ts, today);
    }
    function showRestoreDayPopup(archiveId) {
        const archive = data.archives.find(a => a.id === archiveId);
        if (!archive) return;
        if (!isArchiveSameDateAsToday(archive)) return;
        pendingRestoreArchiveId = archiveId;
        restoreDayTextEl.textContent = `Du er i ferd med å gjenoppta: ${archive.label || "valgt dag"}.`;
        restoreDayOverlayEl.classList.add("show");
    }
    function hideRestoreDayPopup() {
        restoreDayOverlayEl.classList.remove("show");
        pendingRestoreArchiveId = null;
    }
    function restoreDayConfirm() {
        if (!pendingRestoreArchiveId) return;
        if (data.tasks.length > 0) { hideRestoreDayPopup(); return; }
        const idx = data.archives.findIndex(a => a.id === pendingRestoreArchiveId);
        if (idx === -1) return;
        const archive = data.archives[idx];
        if (!isArchiveSameDateAsToday(archive)) { hideRestoreDayPopup(); return; }
        const restoredTasks = (archive.tasks || []).map(t => {
            const id = t.id || Date.now();
            const pn = (typeof t.projectNumber === "string") ? t.projectNumber.trim() : "";
            if (pn) setStoredProjectNumberForName(t.name, pn);
            return {
                id, name: t.name || "", totalMs: Math.max(0, t.totalMs || 0), isActive: false,
                lastStartMs: null, resumed: !!t.resumed, createdAt: t.createdAt || t.firstStartAt || Date.now(),
                firstStartAt: t.firstStartAt || t.createdAt || Date.now(), lastEndAt: t.lastEndAt || null,
                resumeCount: t.resumeCount || 0, projectNumber: pn,
                comment: typeof t.comment === "string" ? t.comment : "", startAdjusted: false
            };
        });
        data.tasks = restoredTasks;
        selectedTaskId = null;
        expandedCommentTaskId = null;
        showAllComments = false;
        data.archives.splice(idx, 1);

        // Gjenoppta dagen skal midlertidig deaktivere «Hindre dobbeltelling»
        activateTemporaryMidnightGuardSuspendForRestore();
        saveToStorage();
        disableCompactMode(); 
        updateUI();
        hideRestoreDayPopup();
    }

    function updateCurrentTimeDisplay() {
        const now = new Date();
        const options = {
            weekday: "long", year: "numeric", month: "long", day: "numeric",
            hour: "2-digit", minute: "2-digit", second: "2-digit"
        };
        let text = now.toLocaleString("nb-NO", options) || "";
        if (text.length > 0) text = text.charAt(0).toUpperCase() + text.slice(1);
        timeNowEl.textContent = text;
    }

    function getISOWeek(date) {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const dayNum = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    function updateArchivesUI() {
        const hasExisting = archiveListEl.querySelectorAll("details").length > 0;
        const openDayIds = new Set();
        const openWeekKeys = new Set();
        const openMonthKeys = new Set();
        const openYearKeys = new Set();
        if (hasExisting) {
            archiveListEl.querySelectorAll("details.archive-group[open]").forEach(el => openDayIds.add(Number(el.dataset.id)));
            archiveListEl.querySelectorAll("details.week-group[open]").forEach(el => openWeekKeys.add(el.dataset.key));
            archiveListEl.querySelectorAll("details.month-group[open]").forEach(el => openMonthKeys.add(el.dataset.key));
            archiveListEl.querySelectorAll("details.year-group[open]").forEach(el => openYearKeys.add(el.dataset.year));
        }
        archiveListEl.innerHTML = "";
        
        if (!data.archives || data.archives.length === 0) {
            const txt = document.createElement("div");
            txt.className = "empty-text helper-text";
            txt.textContent = "Ingen arkiverte prosjekter ennå.";
            archiveListEl.appendChild(txt);
            if (archiveHelperEl) archiveHelperEl.classList.remove('hidden');
            return;
        } else {
            if (archiveHelperEl) archiveHelperEl.classList.add('hidden');
        }

        const sortedArchives = [...data.archives].sort((a, b) => {
            const ta = a.createdAt ? new Date(a.createdAt).getTime() : (a.id || 0);
            const tb = b.createdAt ? new Date(b.createdAt).getTime() : (b.id || 0);
            return tb - ta;
        });

        const uniqueWeeks = new Set();
        sortedArchives.forEach(arch => {
            const d = arch.createdAt ? new Date(arch.createdAt) : new Date(arch.id);
            const w = getISOWeek(d);
            const y = d.getFullYear();
            uniqueWeeks.add(`${y}-${w}`);
        });

        const showMonthHeader = uniqueWeeks.size >= 4;
        
        const currentYear = new Date().getFullYear();

        // Keep chronological (newest first) ordering exactly as sortedArchives, but split into year containers.
        const archivesByYear = new Map();
        const yearOrder = [];
        sortedArchives.forEach(arch => {
            const d = arch.createdAt ? new Date(arch.createdAt) : new Date(arch.id);
            const y = d.getFullYear();
            if (!archivesByYear.has(y)) {
                archivesByYear.set(y, []);
                yearOrder.push(y);
            }
            archivesByYear.get(y).push(arch);
        });

        yearOrder.forEach((year) => {
            let yearContainer = archiveListEl;

            // Only show a Year-level grouping when we are past that year (i.e. not the current year).
            if (year !== currentYear) {
                const yearDetails = document.createElement('details');
                yearDetails.className = 'year-group';
                yearDetails.dataset.year = String(year);
                if (hasExisting && openYearKeys.has(String(year))) yearDetails.open = true;

                // Tooltip: year total
                let totalYearMs = 0;
                (archivesByYear.get(year) || []).forEach(a => {
                    (a.tasks || []).forEach(t => totalYearMs += (t.totalMs || 0));
                });

                yearDetails.addEventListener("toggle", (e) => {
                    if (!yearDetails.open) {
                        const childDetails = yearDetails.querySelectorAll("details");
                        childDetails.forEach(cd => cd.removeAttribute("open"));
                    }
                });

                const yearSummary = document.createElement('summary');
                yearSummary.className = 'year-summary';
                yearSummary.textContent = String(year);
                yearSummary.title = getRoundedTooltipText(totalYearMs);
                yearDetails.appendChild(yearSummary);

                archiveListEl.appendChild(yearDetails);
                yearContainer = yearDetails;
            }

            const groupedData = new Map();
            (archivesByYear.get(year) || []).forEach(arch => {
                const d = arch.createdAt ? new Date(arch.createdAt) : new Date(arch.id);
                const month = d.getMonth();
                const week = getISOWeek(d);
                const monthKey = `${year}-${String(month).padStart(2, '0')}`;
                const weekKey = `${year}-${String(week).padStart(2, '0')}`;
                if (!groupedData.has(monthKey)) groupedData.set(monthKey, new Map());
                const monthMap = groupedData.get(monthKey);
                if (!monthMap.has(weekKey)) monthMap.set(weekKey, []);
                monthMap.get(weekKey).push(arch);
            });

groupedData.forEach((monthMap, monthKey) => {
            let monthContainer = yearContainer;
            if (showMonthHeader) {
                const [y, m] = monthKey.split('-').map(Number);
                const dateObj = new Date(y, m, 1);
                const monthName = dateObj.toLocaleString('nb-NO', { month: 'long', year: 'numeric' });
                const capitalizedMonth = monthName.charAt(0).toUpperCase() + monthName.slice(1);
                const monthDetails = document.createElement('details');
                monthDetails.className = 'month-group';
                monthDetails.dataset.key = monthKey;
                if (hasExisting && openMonthKeys.has(monthKey)) monthDetails.open = true;
                
                // Calculate month total
                let totalMonthMs = 0;
                monthMap.forEach((archives) => {
                    archives.forEach(a => {
                        (a.tasks || []).forEach(t => totalMonthMs += (t.totalMs || 0));
                    });
                });
                
                monthDetails.addEventListener("toggle", (e) => {
                    if (!monthDetails.open) {
                        const childDetails = monthDetails.querySelectorAll("details");
                        childDetails.forEach(cd => cd.removeAttribute("open"));
                    }
                });
                const monthSummary = document.createElement('summary');
                monthSummary.className = 'month-summary';
                monthSummary.textContent = capitalizedMonth;
                monthSummary.title = getRoundedTooltipText(totalMonthMs); // Tooltip for month
                monthDetails.appendChild(monthSummary);
                yearContainer.appendChild(monthDetails);
                monthContainer = monthDetails; 
            }
            monthMap.forEach((archivesInWeek, weekKey) => {
                const [y, w] = weekKey.split('-').map(Number);
                const weekDetails = document.createElement('details');
                weekDetails.className = 'week-group';
                weekDetails.dataset.key = weekKey;
                if (hasExisting && openWeekKeys.has(weekKey)) weekDetails.open = true;
                const weekSummary = document.createElement('summary');
                weekSummary.className = 'week-summary';
                
                // Calculate week total
                let totalWeekMs = 0;
                archivesInWeek.forEach(a => {
                    (a.tasks || []).forEach(t => totalWeekMs += (t.totalMs || 0));
                });
                weekSummary.title = getRoundedTooltipText(totalWeekMs); // Tooltip for week

                const exportDot = document.createElement('span');
                exportDot.className = 'week-export-dot';
                exportDot.title = `Eksporter Uke ${w} til Excel`;
                exportDot.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    exportArchivesToCsv(archivesInWeek);
                });
                const weekText = document.createTextNode(`Uke ${w}`);
                weekSummary.appendChild(exportDot);
                weekSummary.appendChild(weekText);

                // COLLAPSE ALL DAYS IF WEEK IS CLOSED
                weekDetails.addEventListener("toggle", (e) => {
                    if (!weekDetails.open) {
                        const innerDetails = weekDetails.querySelectorAll("details.archive-group");
                        innerDetails.forEach(d => d.removeAttribute("open"));
                    }
                });

                const weekContent = document.createElement('div');
                weekContent.className = 'week-content';
                archivesInWeek.forEach(archive => {
                    const isOpen = openDayIds.has(archive.id);
                    const dayDetails = createArchiveElement(archive, isOpen);
                    weekContent.appendChild(dayDetails);
                });
                weekDetails.appendChild(weekSummary);
                weekDetails.appendChild(weekContent);
                monthContainer.appendChild(weekDetails);
            });
        });
        });

    }

    function createArchiveElement(archive, isOpen) {
        const details = document.createElement("details");
        details.className = "archive-group";
        details.dataset.id = archive.id;
        if (isOpen) details.open = true;
        const summary = document.createElement("summary");
        summary.className = "archive-summary";
        
        let totalDayMs = 0;
        (archive.tasks || []).forEach(t => totalDayMs += (t.totalMs || 0));
        summary.title = getRoundedTooltipText(totalDayMs); // Tooltip for day

        const labelSpan = document.createElement("span");
        labelSpan.className = "archive-label";
        // In week view, day label should be weekday only (no date)
        const _d = archive.createdAt ? new Date(archive.createdAt) : new Date(archive.id);
        const _weekday = _d.toLocaleDateString(undefined, { weekday: "long" });
        labelSpan.textContent = _weekday ? (_weekday.charAt(0).toUpperCase() + _weekday.slice(1)) : (archive.label || "");

        const archiveAdhdRows = getArchiveAdhdBreakdownRows(archive);
        if (archiveAdhdRows.length) {
            const adhdDot = document.createElement('span');
            adhdDot.className = 'archive-adhd-dot';
            adhdDot.title = 'Vis Sekvensmodus – Breakdown';
            adhdDot.setAttribute('role', 'button');
            adhdDot.setAttribute('aria-label', 'Vis Sekvensmodus – Breakdown');
            adhdDot.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                renderAdhdBreakdownPopupRows(archiveAdhdRows, { summaryPrefix: labelSpan.textContent || (archive.label || '') });
            });
            summary.appendChild(adhdDot);
        }

        const actions = document.createElement("span");
        actions.className = "archive-actions";
        const restoreBtn = document.createElement("button");
        restoreBtn.className = "archive-action-btn";
        restoreBtn.type = "button";
        restoreBtn.textContent = "Gjenoppta dagen";
        restoreBtn.title = "Flytt arkiverte oppgaver tilbake til dagens arbeidsliste";
        restoreBtn.disabled = !isArchiveSameDateAsToday(archive);
        restoreBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (data.tasks.length > 0) return;
            showRestoreDayPopup(archive.id);
        });
        actions.appendChild(restoreBtn);
        summary.appendChild(labelSpan);
        summary.appendChild(actions);
        details.appendChild(summary);
        const ul = document.createElement("ul");
        ul.className = "task-list";
        (archive.tasks || []).forEach((task, taskIdx) => {
            const li = document.createElement("li");
            li.className = "task-list-item";
            const left = document.createElement("span");
            left.className = "task-left";

            if (archiveAdhdRows.length && taskIdx === 0) {
                const adhdRowDot = document.createElement('span');
                adhdRowDot.className = 'archive-adhd-dot';
                adhdRowDot.style.marginRight = '6px';
                adhdRowDot.title = 'Vis Sekvensmodus – Breakdown';
                adhdRowDot.setAttribute('role', 'button');
                adhdRowDot.setAttribute('aria-label', 'Vis Sekvensmodus – Breakdown');
                adhdRowDot.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    renderAdhdBreakdownPopupRows(archiveAdhdRows, { summaryPrefix: labelSpan.textContent || (archive.label || '') });
                });
                left.appendChild(adhdRowDot);
            }

            const nameSpan = document.createElement("span");
            nameSpan.className = "task-name";
            nameSpan.textContent = task.name || "";
            left.appendChild(nameSpan);
            const timeSpan = document.createElement("span");
            timeSpan.className = "task-time";
            timeSpan.textContent = formatDuration(task.totalMs, false);
            li.appendChild(left);
            li.appendChild(timeSpan);
            ul.appendChild(li);
        });
        details.appendChild(ul);
        return details;
    }

    function drawTaskChart() {
        if (!chartCtx || !chartCanvas) return;
        const displayWidth = chartCanvas.clientWidth;
        const displayHeight = chartCanvas.clientHeight;
        if (chartCanvas.width !== displayWidth || chartCanvas.height !== displayHeight) {
            chartCanvas.width = displayWidth;
            chartCanvas.height = displayHeight;
        }
        const w = chartCanvas.width;
        const h = chartCanvas.height;
        const ctx = chartCtx;
        const tasks = data.tasks;
        ctx.clearRect(0, 0, w, h);
        if (chartLegendEl) chartLegendEl.innerHTML = "";
        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.35;
        const hasActive = tasks.some(t => t.isActive);
        function addLegendItem(task, color, ms) {
            if (!chartLegendEl) return;
            const item = document.createElement("div");
            item.className = "chart-legend-item";
            const c = document.createElement("span");
            c.className = "chart-legend-color";
            c.style.background = color;
            const txt = document.createElement("span");
            const showSec = !!task.isActive;
            txt.textContent = `${task.name || ""} – ${formatDuration(ms, showSec)}`;
            item.appendChild(c);
            item.appendChild(txt);
            chartLegendEl.appendChild(item);
        }
        if (!tasks || tasks.length === 0) {
            if (chartGifOverlayEl) chartGifOverlayEl.style.display = "none";
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue("--timebar-base").trim() || "#e5e7eb";
            ctx.fill();
            ctx.restore();
            return;
        } else {
            if (chartGifOverlayEl) chartGifOverlayEl.style.display = "none";
        }
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue("--timebar-base").trim() || "#e5e7eb";
        ctx.fill();
        ctx.restore();
        const durations = tasks.map(getTaskElapsedMs);
        const totalMs = durations.reduce((a, b) => a + b, 0);
        const sum = totalMs > 0 ? totalMs : durations.length;
        let startAngle = -Math.PI / 2;
        let legendData = [];
        tasks.forEach((task, idx) => {
            const d = totalMs > 0 ? durations[idx] : 1;
            const angleSpan = (d / sum) * Math.PI * 2;
            const endAngle = startAngle + angleSpan;
            const color = getTaskColor(task, idx, data.tasks);
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, radius, startAngle, endAngle);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
            legendData.push({ task, color, ms: durations[idx] });
            startAngle = endAngle;
        });
        if (!hasActive) {
            legendData.sort((a, b) => b.ms - a.ms);
            legendData.forEach(item => {
                addLegendItem(item.task, item.color, item.ms);
            });
        }
    }

    function updateUI() {
        syncAdhdToActiveProject();
        applyMidnightGuardTemporaryVisualState();
        normalizeActivePosition();
        const isPrevDayArchiveRequired = hasUnarchivedPreviousDayTasks();
        const isGuardArchiveLock = isPrevDayArchiveRequired || hasGuardArchiveLockAfterStop();
        const activeTask = getActiveTask();
        // Reset temporary selection mode if it no longer applies
        if (document.body.classList.contains("temp-task-selection")) {
            if (!selectedTaskId || !activeTask || selectedTaskId === activeTask.id) {
                if (tempTaskSelectionTimer) { clearTimeout(tempTaskSelectionTimer); tempTaskSelectionTimer = null; }
                document.body.classList.remove("temp-task-selection");
            }
        }

        const currentTaskCardEl = document.getElementById("currentTaskCard");
        if (currentTaskCardEl) {
            currentTaskCardEl.classList.remove("card-active-mode", "card-active-mode-resumed");
            if (isGuardArchiveLock && !activeTask) {
            startButtonEl.textContent = (selectedTaskId !== null && !selectedProjectDivisionTarget) ? "Gjenoppta arbeid" : "Start arbeid";
            startButtonEl.style.backgroundColor = "#4b5563";
            selectionInfoEl.textContent = isPrevDayArchiveRequired
                ? "Gårsdagens timeføring må «Tøm og arkiver» før du kan starte eller gjenoppta arbeid."
                : "Når «Hindre dobbeltelling» er aktiv må arbeidslisten «Tøm og arkiver» før du kan gjenoppta eller starte ny timeføring.";
        } else if (activeTask) {
                if (activeTask.resumed) {
                    currentTaskCardEl.classList.add("card-active-mode-resumed");
                } else {
                    currentTaskCardEl.classList.add("card-active-mode");
                }
            }
        }
        const taskCount = data.tasks.length;
        const topLevelTaskCount = getTransferTopLevelTasks().length;
        if (taskCount > 1) endButtonEl.textContent = "Avslutt dagens arbeid";
        else endButtonEl.textContent = "Avslutt dagens arbeid";
        let totalDayMs = 0;
        data.tasks.forEach(t => {
            if (t.isActive) totalDayMs += getTaskElapsedMs(t);
            else totalDayMs += (t.totalMs || 0);
        });
        currentTaskTimeEl.classList.remove("text-rounded-green");
        let displayTotalMs = totalDayMs;
        if (isRoundingEnabled) {
            displayTotalMs = getRoundedMs(totalDayMs);
            currentTaskTimeEl.classList.add("text-rounded-green");
            currentTaskTimeEl.innerHTML = formatDuration(displayTotalMs, false);
        } else {
            if (totalDayMs > 0) {
                currentTaskTimeEl.innerHTML = formatColoredDuration(displayTotalMs);
            } else {
                currentTaskTimeEl.innerHTML = `<span class="time-digit-neutral">00</span>:<span class="time-digit-neutral">00</span>:<span class="time-digit-neutral">00</span>`;
            }
        }
        if (activeTask) {
            currentTaskLabelEl.textContent = "Nåværende prosjekt";
            currentTaskLabelEl.className = "current-task-label";
            currentTaskNameEl.textContent = activeTask.name;
            currentTaskNameEl.className = "current-task-title rainbow-text";
            endButtonEl.disabled = false;
            const canTransfer = canUseTransferBetweenProjectsOrSubtasks();
            transferTimeButtonEl.disabled = !canTransfer;
            const canAdjust = canAdjustStartForActive();
            adjustStartButtonEl.disabled = !canAdjust;
            adjustStartButtonEl.classList.remove("btn-hover-blue", "btn-hover-green", "btn-delete-time");
            if (topLevelTaskCount > 1 || hasAnyManualStartAdjustment()) {
                adjustStartButtonEl.textContent = "Tilfør tid";
                adjustStartButtonEl.title = "Legg til tid på valgt prosjekt eller prosjektoppgave";
                adjustStartButtonEl.classList.add("btn-hover-green");
            } else {
                adjustStartButtonEl.textContent = "Legg til starttid";
                adjustStartButtonEl.title = "";
                adjustStartButtonEl.classList.add("btn-hover-blue");
            }
            currentTaskHintEl.textContent = canAdjust
                ? "Tips: Bruk «Legg til starttid» dersom du startet tidligere enn registrert."
                : "";
        } else {
            currentTaskLabelEl.textContent = "Nåværende prosjekt";
            currentTaskLabelEl.className = "current-task-label";
            currentTaskNameEl.textContent = "Ingen aktivt prosjekt";
            currentTaskNameEl.className = "current-task-title";
            endButtonEl.disabled = true;
            const canTransfer = canUseTransferBetweenProjectsOrSubtasks();
            transferTimeButtonEl.disabled = !canTransfer;
            adjustStartButtonEl.classList.remove("btn-hover-blue", "btn-hover-green", "btn-delete-time");
            if (endDayPressedAtMs && data.tasks.length > 0) {
                adjustStartButtonEl.disabled = false;
                adjustStartButtonEl.classList.add("btn-delete-time");
                adjustStartButtonEl.textContent = "Trekk fra tid";
                adjustStartButtonEl.title = "Hvis du har ført for mye tid kan det trekkes fra her";
            } else {
                adjustStartButtonEl.disabled = true;
                adjustStartButtonEl.textContent = "Legg til starttid";
                adjustStartButtonEl.title = "";
            }
            currentTaskHintEl.textContent = "";
        }
        const anyComments = hasAnyCommentsInTasks();
        toggleAllCommentsButtonEl.disabled = !anyComments;
        toggleAllCommentsButtonEl.textContent = showAllComments ? "Skjul kommentarer" : "Vis kommentarer";
        const hasTasks = data.tasks.length > 0;
        toggleListHeightButtonEl.disabled = !hasTasks;
        if (copyOneNoteButtonEl) copyOneNoteButtonEl.disabled = !hasTasks;
        if (selectionInfoEl) {
            if (hasTasks) selectionInfoEl.classList.add('hidden');
            else selectionInfoEl.classList.remove('hidden');
        }
        if (taskListHelperEl) {
            if (hasTasks) taskListHelperEl.classList.add('hidden');
            else taskListHelperEl.classList.remove('hidden');
        }
if (taskInputEl) {
    const guardResumeMessage = "(Hindre dobbeltelling) er aktivert under Profil og Innstillinger";
    if (typeof taskInputEl.dataset.defaultPlaceholder === "undefined") {
        taskInputEl.dataset.defaultPlaceholder = taskInputEl.getAttribute("placeholder") || "";
    }
    const isPostEndGuardLock = hasGuardArchiveLockAfterStop();
    if (isPostEndGuardLock) {
        taskInputEl.disabled = true;
        taskInputEl.value = "";
        taskInputEl.setAttribute("placeholder", guardResumeMessage);
        taskInputEl.title = guardResumeMessage;
        clearSuggestions();
    } else {
        taskInputEl.disabled = false;
        taskInputEl.setAttribute("placeholder", taskInputEl.dataset.defaultPlaceholder || "");
        taskInputEl.removeAttribute("title");
    }
}
        taskListEl.innerHTML = "";
        if (!projectDivisionEnabled) {
            expandedProjectDivisionTaskId = null;
        } else if (expandedProjectDivisionTaskId !== null) {
            const expandedTask = data.tasks.find(t => t.id === expandedProjectDivisionTaskId);
            if (!taskHasWorkListProjectDivision(expandedTask)) expandedProjectDivisionTaskId = null;
        }
        if (data.tasks.length === 0) {
            emptyListTextEl.style.display = "block";
        } else {
            emptyListTextEl.style.display = "none";
            const topLevelTasks = data.tasks.filter(task => !isProjectDivisionSubTask(task));
            const visibleTasks = expandedProjectDivisionTaskId !== null
                ? topLevelTasks.filter(task => task.id === expandedProjectDivisionTaskId)
                : topLevelTasks;
            visibleTasks.forEach(task => {
                const li = document.createElement("li");
                li.className = "task-list-item";
                li.dataset.id = task.id;
                if (isFavoriteForName(task.name)) li.classList.add("task-favorite");
                if (task.isActive) li.classList.add("task-active");
                if (task.id === selectedTaskId) li.classList.add("task-selected");
                const storedDivisionItems = getStoredProjectDivisionItemsForDisplay(task);
                const divisionItems = getWorkListProjectDivisionItems(task);
                const hasStoredProjectDivision = storedDivisionItems.length > 0;
                const divisionOpen = projectDivisionEnabled && expandedProjectDivisionTaskId === task.id && divisionItems.length > 0;
                li.dataset.projectName = task.name || '';
                li.dataset.hasProjectDivision = hasStoredProjectDivision ? '1' : '0';
                if (divisionOpen) li.classList.add("project-division-open");
                const left = document.createElement("span");
                left.className = "task-left";
                const hasComment = typeof task.comment === "string" && task.comment.trim().length > 0;
                const hasProjectDivision = shouldShowProjectDivisionArrow(task);
                if (hasComment) {
                    const copyBtn = document.createElement("button");
                    copyBtn.className = "btn-comment-copy";
                    copyBtn.title = "Enkeltklikk: Vis kommentar / Dobbeltklikk: Kopier";
                    let clickCount = 0;
                    let singleClickTimer = null;
                    copyBtn.addEventListener("click", (e) => {
                        e.stopPropagation();
                        clickCount++;
                        if (clickCount === 1) {
                            singleClickTimer = setTimeout(() => {
                                clickCount = 0;
                                if (task.comment && !showAllComments) {
                                    toggleCommentDropdown(task.id);
                                    updateUI();
                                }
                            }, 250);
                        } else if (clickCount === 2) {
                            clearTimeout(singleClickTimer);
                            clickCount = 0;
                            if (task.comment) {
                                navigator.clipboard.writeText(task.comment)
                                    .then(() => {
                                        const parentLi = copyBtn.closest('.task-list-item');
                                        if (parentLi) {
                                            const nameEl = parentLi.querySelector('.task-name');
                                            if (nameEl) {
                                                nameEl.classList.remove('text-flash-anim');
                                                void nameEl.offsetWidth;
                                                nameEl.classList.add('text-flash-anim');
                                                setTimeout(() => { nameEl.classList.remove('text-flash-anim'); }, 700);
                                            }
                                        }
                                    });
                            }
                        }
                    });
                    copyBtn.addEventListener("dblclick", (e) => { e.stopPropagation(); });
                    left.appendChild(copyBtn);
                }
                if (hasProjectDivision) {
                    const arrowSpan = document.createElement("span");
                    arrowSpan.className = "project-division-arrow " + (divisionOpen ? "is-expanded" : "is-collapsed");
                    arrowSpan.setAttribute('aria-hidden', 'true');
                    arrowSpan.textContent = divisionOpen ? '▼' : '▶';
                    if (!divisionOpen) arrowSpan.style.animationDelay = `-${Date.now() % 2000}ms`;
                    left.appendChild(arrowSpan);
                }
                const infoCol = document.createElement("div");
                infoCol.className = "task-info-col";
                const nameRow = document.createElement("div");
                nameRow.className = "task-name-row";
                const nameSpan = document.createElement("span");
                nameSpan.className = "task-name";
                if (hasProjectDivision) {
                    nameSpan.classList.add('is-project-division-parent');
                    nameSpan.title = 'Dobbeltklikk for kommentar på prosjektet';
                }
                nameSpan.textContent = task.name;
                nameRow.appendChild(nameSpan);
                infoCol.appendChild(nameRow);
                if (task.projectNumber && task.projectNumber.trim().length > 0) {
                    const pnDiv = document.createElement("div");
                    pnDiv.className = "task-project-number";
                    pnDiv.textContent = task.projectNumber;
                    infoCol.appendChild(pnDiv);
                }
                left.appendChild(infoCol);
                const timeSpan = document.createElement("span");
                timeSpan.className = "task-time";
                const startLabel = formatTimeOfDay(task.firstStartAt || task.createdAt || task.lastStartMs);
                let rawMs;
                if (task.isActive) rawMs = getTaskElapsedMs(task);
                else rawMs = task.totalMs || getTaskElapsedMs(task);
                let displayMs = rawMs;
                let isRounded = false;
                if (isRoundingEnabled) {
                    displayMs = getRoundedMs(rawMs);
                    isRounded = true;
                }
                if (isRounded) timeSpan.classList.add('text-rounded');
                if (hasProjectDivision) {
                    const parentRawMs = getProjectDivisionParentDisplayRawMs(task.name);
                    const parentDisplayMs = isRoundingEnabled ? getRoundedMs(parentRawMs) : parentRawMs;
                    const showSeconds = !taskListEl.classList.contains('compact-mode')
                        && !isRoundingEnabled
                        && !projectDivisionEnabled
                        && hasLiveProjectDivisionSeconds(task.name);
                    timeSpan.textContent = formatDurationWorkList(parentDisplayMs, showSeconds);
                } else if (task.isActive) {
                    const elapsed = formatDurationWorkList(displayMs, shouldShowWorkListSecondsForTask(task));
                    timeSpan.textContent = elapsed;
                } else {
                    const total = formatDurationWorkList(displayMs);
                    timeSpan.textContent = total;
                }
                li.appendChild(left);
                li.appendChild(timeSpan);
                taskListEl.appendChild(li);
                const commentText = (typeof task.comment === "string") ? task.comment.trim() : "";
                const shouldShowComment = commentText.length > 0 && (showAllComments || expandedCommentTaskId === task.id);
                if (shouldShowComment) {
                    const commentRow = document.createElement("div");
                    commentRow.className = "task-comment-row";
                    if (isFavoriteForName(task.name)) commentRow.classList.add("task-favorite");
                    const box = document.createElement("div");
                    box.className = "task-comment-box";
                    box.textContent = task.comment;
                    commentRow.appendChild(box);
                    taskListEl.appendChild(commentRow);
                }
                if (divisionOpen) {
                    const divisionRow = document.createElement('div');
                    divisionRow.className = 'project-division-row';
                    const divisionList = document.createElement('ul');
                    divisionList.className = 'project-division-list';
                    divisionItems.forEach((item, idx) => {
                        const divisionLi = document.createElement('li');
                        divisionLi.className = 'project-division-item';
                        divisionLi.dataset.parentTaskId = String(task.id);
                        divisionLi.dataset.projectName = task.name;
                        divisionLi.dataset.subTaskName = item;
                        const subTask = resolveLiveProjectDivisionTask(task.name, item);
                        divisionLi.dataset.taskId = subTask ? String(subTask.id) : '';
                        if (subTask && subTask.isActive) divisionLi.classList.add('is-active');
                        if (isSelectedProjectDivision(task.name, item)) divisionLi.classList.add('is-selected');
                        if (subTask && typeof subTask.comment === 'string' && subTask.comment.trim().length > 0) {
                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'btn-comment-copy';
                            copyBtn.title = 'Enkeltklikk: Vis kommentar / Dobbeltklikk: Kopier';
                            let clickCount = 0;
                            let singleClickTimer = null;
                            copyBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                clickCount++;
                                if (clickCount === 1) {
                                    singleClickTimer = setTimeout(() => {
                                        clickCount = 0;
                                        if (subTask.comment && !showAllComments) {
                                            toggleCommentDropdown(subTask.id);
                                            updateUI();
                                        }
                                    }, 250);
                                } else if (clickCount === 2) {
                                    clearTimeout(singleClickTimer);
                                    clickCount = 0;
                                    navigator.clipboard.writeText(subTask.comment || '')
                                        .then(() => {
                                            const nameEl = divisionLi.querySelector('.project-division-text');
                                            if (nameEl) {
                                                nameEl.classList.remove('text-flash-anim');
                                                void nameEl.offsetWidth;
                                                nameEl.classList.add('text-flash-anim');
                                                setTimeout(() => { nameEl.classList.remove('text-flash-anim'); }, 700);
                                            }
                                        });
                                }
                            });
                            copyBtn.addEventListener('dblclick', (e) => { e.stopPropagation(); });
                            divisionLi.appendChild(copyBtn);
                        }
                        const idxSpan = document.createElement('span');
                        idxSpan.className = 'project-division-index';
                        idxSpan.textContent = String(idx + 1);
                        const textSpan = document.createElement('span');
                        textSpan.className = 'project-division-text';
                        textSpan.textContent = item;
                        textSpan.title = 'Dobbeltklikk for kommentar';
                        const timeSpan = document.createElement('span');
                        timeSpan.className = 'project-division-time';
                        if (isRoundingEnabled) timeSpan.classList.add('text-rounded');
                        const compactMode = taskListEl.classList.contains('compact-mode');
                        timeSpan.textContent = subTask
                            ? formatDurationWorkList(getProjectDivisionTaskDisplayMs(subTask), !compactMode && !isRoundingEnabled && shouldShowWorkListSecondsForTask(subTask))
                            : (compactMode ? '00:00' : '00:00:00');
                        divisionLi.appendChild(idxSpan);
                        divisionLi.appendChild(textSpan);
                        divisionLi.appendChild(timeSpan);
                        const openProjectDivisionComment = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const ensuredSubTask = ensureProjectDivisionTask(task.name, item);
                            selectedProjectDivisionTarget = makeProjectDivisionSelection(task.name, item);
                            showCommentPopup(ensuredSubTask);
                        };
                        divisionLi.addEventListener('dblclick', openProjectDivisionComment);
                        textSpan.addEventListener('dblclick', openProjectDivisionComment);
                        idxSpan.addEventListener('dblclick', openProjectDivisionComment);
                        timeSpan.addEventListener('dblclick', openProjectDivisionComment);
                        divisionList.appendChild(divisionLi);
                        const subTaskCommentText = (subTask && typeof subTask.comment === 'string') ? subTask.comment.trim() : '';
                        const shouldShowSubTaskComment = subTaskCommentText.length > 0 && (showAllComments || (subTask && expandedCommentTaskId === subTask.id));
                        if (shouldShowSubTaskComment) {
                            const subCommentRow = document.createElement('li');
                            subCommentRow.className = 'project-division-comment-row';
                            const subCommentBox = document.createElement('div');
                            subCommentBox.className = 'task-comment-box';
                            subCommentBox.textContent = subTask.comment;
                            subCommentRow.appendChild(subCommentBox);
                            divisionList.appendChild(subCommentRow);
                        }
                    });
                    divisionRow.appendChild(divisionList);
                    taskListEl.appendChild(divisionRow);
                }
            });
        }
        if (data.tasks.length > 0 && !activeTask) clearButtonEl.disabled = false;
        else clearButtonEl.disabled = true;
        const hasInput = taskInputEl.value.trim().length > 0;
        const hasSelectedProjectDivision = !!selectedProjectDivisionTarget;
        startButtonEl.style.backgroundColor = "";
        startButtonEl.style.color = "";
        if (hasSelectedProjectDivision) {
            const selectedDivisionIsActive = isActiveProjectDivisionSelection(selectedProjectDivisionTarget);
            startButtonEl.textContent = selectedDivisionIsActive ? "Arbeid pågår" : "Start arbeid";
            startButtonEl.style.backgroundColor = "#f472b6";
            startButtonEl.style.color = "#111827";
            selectionInfoEl.textContent = selectedDivisionIsActive
                ? "Timeføring pågår på valgt prosjektoppgave."
                : "Du har valgt en prosjektoppgave. Trykk for å føre tid på underoppgaven.";
        } else if (activeTask) {
            if (selectedTaskId !== null) {
                if (selectedTaskId === activeTask.id) {
                    startButtonEl.textContent = "Arbeid pågår";
                    startButtonEl.style.backgroundColor = "var(--dot-green)";
                    selectionInfoEl.textContent = "Timeføring pågår på valgt prosjekt.";
                } else {
                    startButtonEl.textContent = "Gjenoppta arbeid";
                    startButtonEl.style.backgroundColor = "var(--dot-green)";
                    selectionInfoEl.textContent = "Du har valgt et prosjekt. Trykk for å bytte til dette.";
                }
            } else if (hasInput) {
                startButtonEl.textContent = "Start arbeid";
                startButtonEl.style.backgroundColor = "var(--dot-green)";
                selectionInfoEl.textContent = "Trykk for å starte det nye prosjektet.";
            } else {
                startButtonEl.textContent = "Arbeid pågår";
                startButtonEl.style.backgroundColor = "var(--dot-green)";
                selectionInfoEl.textContent = "En oppgave er aktiv.";
            }
        } else {
            if (selectedTaskId !== null) {
                startButtonEl.textContent = "Gjenoppta arbeid";
                startButtonEl.style.backgroundColor = "var(--dot-green)";
                selectionInfoEl.textContent = "Du har valgt et prosjekt. Trykk for å gjenoppta.";
            } else if (hasInput) {
                startButtonEl.textContent = "Start arbeid";
                startButtonEl.style.backgroundColor = "var(--dot-green)";
                selectionInfoEl.textContent = "Trykk for å starte.";
            } else {
                startButtonEl.textContent = "Start arbeid";
                if (data.tasks.length > 0) startButtonEl.style.backgroundColor = "#4b5563"; 
                else startButtonEl.style.backgroundColor = "var(--dot-green)";
                selectionInfoEl.textContent = "Skriv inn et prosjekt og trykk Enter eller «Start arbeid».";
            }
        }
        // Lås gjenoppta/ny start når «Hindre dobbeltelling» krever arkivering først
        if (isGuardArchiveLock && !activeTask) {
            startButtonEl.disabled = true;
            startButtonEl.textContent = (selectedTaskId !== null) ? "Gjenoppta arbeid" : "Start arbeid";
            startButtonEl.style.backgroundColor = "#4b5563";
            if (selectionInfoEl) {
                selectionInfoEl.textContent = isPrevDayArchiveRequired
                    ? "Gårsdagens timeføring må «Tøm og arkiver» før du kan starte eller gjenoppta arbeid."
                    : "Når «Hindre dobbeltelling» er aktiv må arbeidslisten «Tøm og arkiver» før du kan gjenoppta eller starte ny timeføring.";
            }
        } else {
            startButtonEl.disabled = false;
        }

        const hasArchives = data.archives && data.archives.length > 0;
        clearArchivesButtonEl.disabled = !hasArchives;
        exportButtonEl.disabled = !hasArchives;
        updateArchivesUI();
        drawTaskChart();
        renderDayTimeline();
        applyPersonalCustomizationHeadings();
    }

    function exportArchivesToCsv(archivesInput = null) {
        const archivesToExport = archivesInput || data.archives;
        if (!archivesToExport || archivesToExport.length === 0) return false;
        const rows = [];
        rows.push([ "Uke", "Dag", "Prosjekt", "Timer og minutter", "Arbeid startet", "Arbeid avsluttet", "Gjenopptatt", "Antall", "Prosjektnummer", "Kommentar" ]);
        const archivesSorted = [...archivesToExport].sort((a, b) => {
            const ta = a.createdAt ? new Date(a.createdAt).getTime() : (a.id || 0);
            const tb = b.createdAt ? new Date(b.createdAt).getTime() : (b.id || 0);
            return tb - ta;
        });
        let previousWeek = null;
        archivesSorted.forEach(archive => {
            let dateObj = null;
            if (archive.createdAt) dateObj = new Date(archive.createdAt);
            else dateObj = new Date(archive.id);
            const currentWeek = getISOWeek(dateObj);
            if (previousWeek !== null && currentWeek !== previousWeek) rows.push([]); 
            previousWeek = currentWeek;
            let dayName = dateObj.toLocaleDateString("nb-NO", { weekday: 'long' });
            dayName = dayName.charAt(0).toUpperCase() + dayName.slice(1);
            (archive.tasks || []).forEach(task => {
                const name = task.name || "";
                const durationHM = formatHoursMinutes(task.totalMs || 0);
                const startStr = formatTimeOfDay(task.firstStartAt || task.createdAt);
                const endStr = formatTimeOfDay(task.lastEndAt || dateObj.getTime());
                const resumeCount = task.resumeCount || 0;
                const resumedText = resumeCount > 0 ? "Ja" : "Nei";
                let projectNumber = typeof task.projectNumber === "string" ? task.projectNumber : "";
                
                // Fix for large numbers displaying as E+ in Excel
                // We wrap purely numeric strings in ="value" to force Excel to treat them as text
                if (/^\d+$/.test(projectNumber) && projectNumber.length > 5) {
                    projectNumber = `="${projectNumber}"`;
                }

                const comment = typeof task.comment === "string" ? task.comment : "";
                rows.push([ String(currentWeek), dayName, name, durationHM, startStr, endStr, resumedText, String(resumeCount), projectNumber, comment ]);
            });
        });
        function toCsvField(value) {
            const s = String(value).replace(/"/g, '""');
            return `"${s}"`;
        }
        const csvContent = "\uFEFF" + rows.map(row => row.map(toCsvField).join(";")).join("\r\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const timestamp = now.toISOString().replace(/[:T]/g, "-").split(".")[0];
        let filename = "historikk_" + timestamp + ".csv";
        if (archivesInput) filename = "ukes_eksport_" + timestamp + ".csv";
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        return true;
    }

    function initOverdueSelects() {
        if (overdueHourEl.options.length === 0) {
            for (let h = 0; h < 24; h++) {
                const opt = document.createElement("option");
                opt.value = h;
                opt.textContent = String(h).padStart(2, "0");
                overdueHourEl.appendChild(opt);
            }
        }
        if (overdueMinuteEl.options.length === 0) {
            for (let m = 0; m < 60; m++) {
                const opt = document.createElement("option");
                opt.value = m;
                opt.textContent = String(m).padStart(2, "0");
                overdueMinuteEl.appendChild(opt);
            }
        }
        const now = new Date();
        overdueHourEl.value = now.getHours();
        overdueMinuteEl.value = now.getMinutes();
    }
    function showOverduePopup(task, mode = "overdue10h") {
        initOverdueSelects();
        overduePopupMode = mode || "overdue10h";
        overdueTaskNameEl.textContent = task.name;

        if (overdueTitleEl && overdueMessagePrimaryEl && overdueMessageSecondaryEl && overdueConfirmButtonEl) {
            if (overduePopupMode === "midnightGuard") {
                overdueTitleEl.textContent = "Hindre dobbeltelling";
                overdueMessagePrimaryEl.innerHTML = 'Det ser ut som at du glemte å trykke (Avslutt dagens arbeid) for den aktive timeføringen, vennligst oppgi ca tid du avsluttet arbeidet i går';
                overdueMessageSecondaryEl.textContent = "Velg ca. klokkeslett for når arbeidet ble avsluttet i går.";
                overdueConfirmButtonEl.textContent = "Fullfør gårsdagens timeføring";
                const taskDate = new Date(task.lastStartMs || task.firstStartAt || task.createdAt || Date.now());
                overdueHourEl.value = String(taskDate.getHours());
                overdueMinuteEl.value = String(taskDate.getMinutes());
            } else {
                overdueTitleEl.textContent = "Aktivt prosjekt har stått for lenge";
                overdueMessagePrimaryEl.textContent = `Prosjektet ${task.name} har vært aktivt i mer enn 10 timer.`;
                overdueMessageSecondaryEl.textContent = "Når ble dette prosjektet fullført?";
                overdueConfirmButtonEl.textContent = "Fullfør prosjekt til angitt tid og tøm og arkiver listen";
            }
        }

        overdueOverlayEl.classList.add("show");
        overduePopupShown = true;
    }
    function hideOverduePopup() { overdueOverlayEl.classList.remove("show"); }
    function checkOverdueActiveTask() { handleMidnightGuardAutoStopIfNeeded(); }
    function showClearArchivesPopup() {
        if (!data.archives || data.archives.length === 0) return;
        clearArchivesOverlayEl.classList.add("show");
    }
    function hideClearArchivesPopup() { clearArchivesOverlayEl.classList.remove("show"); }
    function deleteAllArchives() {
        data.archives = [];
        saveToStorage();
        updateUI();
    }
    function showClearTodayPopup() {
        const tasksToCopy = copySourceTasks || data.tasks;
            if (tasksToCopy.length === 0) return;
        clearTodayOverlayEl.classList.add("show");
    }
    function hideClearTodayPopup() { clearTodayOverlayEl.classList.remove("show"); }

    function showOneNoteReminderPopup() {
        if (!oneNoteReminderOverlayEl) return;
        oneNoteReminderOverlayEl.classList.add("show");
    }
    function hideOneNoteReminderPopup() {
        if (!oneNoteReminderOverlayEl) return;
        oneNoteReminderOverlayEl.classList.remove("show");
    }
    function buildOneNoteReminderSignatureForTasks(tasks) {
        const arr = Array.isArray(tasks) ? tasks : [];
        if (!arr.length) return "";
        return arr.map(t => {
            const totalMs = t && t.isActive ? getTaskElapsedMs(t) : Math.max(0, Number((t && t.totalMs) || 0));
            const name = (t && typeof t.name === "string") ? t.name : "";
            const comment = (t && typeof t.comment === "string") ? t.comment : "";
            const id = t && t.id != null ? String(t.id) : "";
            return [id, name, Math.round(totalMs), comment].join("¦");
        }).join("‖");
    }
    function hasValidOneNoteCopyForCurrentTasks() {
        if (!Array.isArray(data.tasks) || data.tasks.length === 0) return true;
        const currentSig = buildOneNoteReminderSignatureForTasks(data.tasks);
        return !!currentSig && currentSig === oneNoteReminderCurrentTasksCopySignature;
    }
    function shouldBlockClearArchiveForOneNoteReminder() {
        if (!oneNoteReminderEnabled) return false;
        const tasksToCopy = copySourceTasks || data.tasks;
        if (!Array.isArray(tasksToCopy) || tasksToCopy.length === 0) return false;
        if (copySourceTasks || selectedArchiveForCopy) return false;
        return !hasValidOneNoteCopyForCurrentTasks();
    }

    function enableCompactMode() {
        if (taskListEl) taskListEl.classList.add("compact-mode");
        if (taskListWrapperEl) taskListWrapperEl.classList.add("compact-active");
    }
    function disableCompactMode() {
        if (taskListEl) taskListEl.classList.remove("compact-mode");
        if (taskListWrapperEl) taskListWrapperEl.classList.remove("compact-active");
    }
    function autoResizeSplitter() {
        const items = document.querySelectorAll('#taskList .task-list-item');
        const divisionItems = document.querySelectorAll('#taskList .project-division-item');
        let maxW = 0;
        const tmp = document.createElement('span');
        tmp.style.visibility = 'hidden';
        tmp.style.position = 'absolute';
        tmp.style.whiteSpace = 'nowrap';
        tmp.style.fontSize = '0.95rem'; 
        tmp.style.fontFamily = 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        document.body.appendChild(tmp);
        items.forEach(row => {
            const nameEl = row.querySelector('.task-name');
            const projectEl = row.querySelector('.task-project-number');
            let rowW = 0;
            if (nameEl) {
                tmp.textContent = nameEl.textContent;
                rowW = Math.max(rowW, tmp.getBoundingClientRect().width);
            }
            if (projectEl) {
                tmp.style.fontSize = '0.75rem';
                tmp.textContent = projectEl.textContent;
                const pW = tmp.getBoundingClientRect().width;
                if (pW > rowW) rowW = pW; 
                tmp.style.fontSize = '0.95rem'; 
            }
            if (rowW > maxW) maxW = rowW;
        });
        divisionItems.forEach(row => {
            const indexEl = row.querySelector('.project-division-index');
            const textEl = row.querySelector('.project-division-text');
            let rowW = 0;
            if (indexEl) {
                tmp.style.fontWeight = '700';
                tmp.textContent = indexEl.textContent;
                rowW += tmp.getBoundingClientRect().width + 10;
            }
            if (textEl) {
                tmp.style.fontWeight = '400';
                tmp.textContent = textEl.textContent;
                rowW += tmp.getBoundingClientRect().width;
            }
            tmp.style.fontWeight = '400';
            if (rowW > maxW) maxW = rowW;
        });
        document.body.removeChild(tmp);
        const basePadding = 100; 
        const idealGap = maxW + basePadding;
        if (taskListWrapperEl) taskListWrapperEl.style.setProperty('--dynamic-gap', idealGap + "px");
    }

    function openSettingsModal() {
        renderProfileOptions();
        syncTestDataToggleUI();
        const youtubeBtn = document.getElementById('youtubeButton');
        if (Docsgoogle === "PLACEHOLDER") {
            youtubeBtn.disabled = true;
            youtubeBtn.style.opacity = "0.5";
            youtubeBtn.style.cursor = "not-allowed";
            youtubeBtn.title = "Ingen video tilgjengelig";
            youtubeBtn.onclick = null;
            youtubeBtn.classList.remove('btn-rainbow-hover');
        } else {
            youtubeBtn.disabled = false;
            youtubeBtn.style.opacity = "1";
            youtubeBtn.style.cursor = "pointer";
            youtubeBtn.title = "Åpne dokumentasjon i ny fane";
            youtubeBtn.onclick = () => window.open(Docsgoogle, '_blank');
        }
        settingsOverlayEl.classList.add("show");
        profileHelperTextEl.textContent = "";
    }
    function closeSettingsModal() {
        settingsOverlayEl.classList.remove("show");
        profileHelperTextEl.textContent = "";
    }

    function syncTestDataToggleUI() {
        if (!cpGenerateTestDataEl) return;
        const exists = profiles.includes(DEMO_PROFILE_NAME);
        cpGenerateTestDataEl.checked = exists;
        // Keep it locked ON while the generated profile exists
        cpGenerateTestDataEl.disabled = exists;
    }
    function renderProfileOptions() {
        profileSelectEl.innerHTML = "";
        profiles.forEach(p => {
            const opt = document.createElement("option");
            opt.value = p;
            opt.textContent = p;
            if (p === currentProfile) opt.selected = true;
            profileSelectEl.appendChild(opt);
        });
        if (profiles.length > 1 && currentProfile !== "Standard") {
            deleteProfileButtonEl.style.display = "inline-block";
            deleteProfileButtonEl.disabled = false;
        } else {
            deleteProfileButtonEl.style.display = "none";
            deleteProfileButtonEl.disabled = true;
        }
        updateNewProfileAttention();
    }

    function updateNewProfileAttention(){
        if (!newProfileNameEl) return;
        const shouldBlink = Array.isArray(profiles) && profiles.length <= 1;
        newProfileNameEl.classList.toggle('new-profile-attention', shouldBlink);
    }

    function switchProfile(newProfileName) {
        if (!profiles.includes(newProfileName)) return;
        if (newProfileName === currentProfile) return;
        saveToStorage(); 
        saveDayTimelineSettings();
        currentProfile = newProfileName;
        saveProfiles();
        enforceStandardProfileDefaultPanelSettings();
        loadFromStorage();
        loadDayTimelineSettings();
        loadAutoSaveSetting();
        loadMidnightDoubleCountGuardSetting();
        loadNoHelpTextSetting();
        loadProjectDivisionToggleSetting();
    updateProjectTaskDivisionVisibility();
        loadOneNoteReminderSetting();
        loadPersonalCustomizationValues();
        loadPersonalCustomizationToggle();
        loadControlPanelOpenSetting();
        loadUnderDevelopmentExpandedSetting();
    moveUnderDevelopmentOutOfControlPanelButtons();
        applyStoredSuggestionsHeight();
        applyStoredSuggestionsHeight();
        applyStoredSuggestionsHeight();
        applyStoredSuggestionsHeight();
        selectedTaskId = null;
        suggestionIndex = -1;
        filteredSuggestions = [];
        showAllComments = false;
        expandedCommentTaskId = null;
        taskInputEl.value = "";
        clearSuggestions();
        disableCompactMode();
        renderDayTimeline();
        updateUI();
        applyPersonalCustomizationHeadings();
        try { document.dispatchEvent(new Event('profileLoaded')); } catch(e){}
        updateProfileButton();
        profileHelperTextEl.textContent = `Byttet til profil: ${newProfileName}`;
        profileHelperTextEl.style.color = "var(--text)";
        renderProfileOptions();
    }
    function createNewProfile(e) {
        if(e) e.preventDefault();
        const name = newProfileNameEl.value.trim();
        if (!name) {
            profileHelperTextEl.textContent = "Vennligst skriv inn et navn.";
            profileHelperTextEl.style.color = "var(--danger)";
            return;
        }
        const exists = profiles.some(p => p.toLowerCase() === name.toLowerCase());
        if (exists) {
            profileHelperTextEl.textContent = "Profilen finnes allerede.";
            profileHelperTextEl.style.color = "var(--danger)";
            return;
        }
        saveToStorage(); 
        saveDayTimelineSettings();
        profiles.push(name);
        currentProfile = name;
        saveProfiles();
        loadFromStorage();
        loadDayTimelineSettings();
        loadAutoSaveSetting();
        loadMidnightDoubleCountGuardSetting();
        loadNoHelpTextSetting();
        loadOneNoteReminderSetting();
        loadPersonalCustomizationValues();
        loadPersonalCustomizationToggle();
        loadControlPanelOpenSetting();
        loadUnderDevelopmentExpandedSetting();
        selectedTaskId = null;
        selectedProjectDivisionTarget = null;
        taskInputEl.value = "";
        clearSuggestions();
        disableCompactMode();
        renderDayTimeline();
        updateUI();
        applyPersonalCustomizationHeadings();
        try { document.dispatchEvent(new Event('profileLoaded')); } catch(e){}
        updateProfileButton();
        newProfileNameEl.value = "";
        profileHelperTextEl.textContent = `Opprettet og byttet til: ${name}`;
        profileHelperTextEl.style.color = "var(--dot-green)";
        renderProfileOptions();
    }
    function showDeleteProfilePopup() {
        if (currentProfile === "Standard") { alert("Du kan ikke slette Standard-profilen."); return; }
        deleteProfileNameDisplayEl.textContent = currentProfile;
        deleteProfileOverlayEl.classList.add("show");
        closeSettingsModal();
        return true;
    }
    function hideDeleteProfilePopup() {
        deleteProfileOverlayEl.classList.remove("show");
        openSettingsModal(); 
    }
    function executeDeleteProfile() {
        const profileToDelete = currentProfile;
        if (profileToDelete === "Standard") return;
        deletePersonalBgMediaFromDb(getPersonalBgMediaStorageKey(profileToDelete));
        const storageKey = STORAGE_KEY_PREFIX + profileToDelete;
        const timelineKey = TIMELINE_KEY_PREFIX + profileToDelete;
        localStorage.removeItem(storageKey);
        localStorage.removeItem(timelineKey);
        profiles = profiles.filter(p => p !== profileToDelete);
        currentProfile = "Standard";
        saveProfiles();
        enforceStandardProfileDefaultPanelSettings();
        loadFromStorage();
        loadDayTimelineSettings();
        selectedTaskId = null;
        taskInputEl.value = "";
        clearSuggestions();
        disableCompactMode();
        renderDayTimeline();
        updateUI();
        updateProfileButton();
        deleteProfileOverlayEl.classList.remove("show");
        openSettingsModal();
        profileHelperTextEl.textContent = `Profil "${profileToDelete}" ble slettet.`;
        profileHelperTextEl.style.color = "var(--text)";
    }
    function executeSaveAndDeleteProfile() {
        downloadBackup();
        setTimeout(() => { executeDeleteProfile(); }, 1000);
    }
    function generateDemoData() {
        const demoProfileName = DEMO_PROFILE_NAME;
        
        // Add to profiles if missing
        if (!profiles.includes(demoProfileName)) {
            profiles.push(demoProfileName);
            saveProfiles();
        }
        
        const taskNamesList = [
            "Morgenmøte", "Prosjektering - Bygg A", "Befaring ute", "Lunsj", 
            "Dokumentasjon FDV", "Koordinering TEK", "E-post og administrasjon",
            "Tegningsrevisjon", "Kvalitetssikring (KS)", "Kundesamtale", 
            "Modellering BIM", "Statusmøte med Byggherre"
        ];
        
        const demoData = {
            tasks: [],
            archives: [],
            taskNames: taskNamesList,
            projectNumbers: {}
        };

        // Populate project numbers
        demoData.taskNames.forEach((name, i) => {
            demoData.projectNumbers[normalizeTaskName(name)] = String(1000 + i);
        });

        const longComments = [
            "Gjennomførte full revisjon av tegninger i henhold til nye krav fra byggherre. Oppdaget noen avvik i sone 3 som må utbedres snarest før neste milepæl.",
            "Langt møte med prosjektgruppen angående fremdrift og leveranser. Vi ble enige om å fremskynde fase 2 med to uker for å rekke ferien.",
            "Koordinering mot elektro og VVS på byggeplass. Det var kollisjoner i himling som krevde omprosjektering på stedet. Løsning avklart med bas.",
            "Utarbeidelse av FDV-dokumentasjon for overlevering. Sjekkliste punkt 1-50 gjennomgått og verifisert OK. Mangler kun sluttattest fra RIE.",
            "Befaring på taket for å sjekke lekkasje etter styrtregnet. Fant ingen synlige skader på tekkingen, men mistenker utett beslag rundt pipen som må byttes.",
            "Oppdatering av BIM-modell etter kollisjonskontroll i Solibri. Flyttet kanaler i korridor 2. etasje for å gi plass til kabelbroer.",
            "Gjennomgang av endringsmeldinger med entreprenør. Diskuterte kostnadskonsekvenser av endret gulvbelegg i fellesarealer.",
            "Skriving av referat fra byggemøte. Sendt ut til alle deltakere med frist for merknader innen fredag.",
            "Forberedelse til presentasjon for styringsgruppen. Laget nye visualiseringer av fasadealternativene.",
            "Generell administrasjon og sortering av innboks etter ferieavvikling. Oppdaterte timelister og fakturagrunnlag."
        ];

        const now = new Date();
        const startDate = new Date();
        startDate.setFullYear(now.getFullYear() - 3);
        // Ensure we start at the beginning of that week to look nice if needed, but simple subtraction is fine.
        
        // Iterate from today back to startDate
        let curr = new Date(now);
        curr.setHours(0,0,0,0);
        
        // Helper to check weekends
        const isWeekend = (d) => d.getDay() === 0 || d.getDay() === 6;

        while (curr >= startDate) {
            if (!isWeekend(curr)) {
                
                const tasksForDay = [];
                // Target: 5 to 8 tasks
                const numTasks = Math.floor(Math.random() * 4) + 5; // 5, 6, 7, or 8
                
                // Workday: 07:00 to 16:00 = 9 hours = 540 minutes
                const dayStartHour = 7;
                const totalMinutes = 9 * 60; 
                
                // We need random cut points. 
                // To insure no "empty space", we simply divide the 540 minutes into N segments
                // and assign them sequentially.
                
                let cuts = [0];
                while (cuts.length < numTasks) {
                    // Pick a random time between 0 and totalMinutes
                    const r = Math.floor(Math.random() * (totalMinutes - 40)) + 20; 
                    // Simple check to avoid cuts too close to each other (min 20 min tasks)
                    let valid = true;
                    for (let c of cuts) {
                        if (Math.abs(c - r) < 20) valid = false;
                    }
                    if (valid) cuts.push(r);
                }
                cuts.push(totalMinutes);
                cuts.sort((a,b) => a - b);
                
                // Base timestamp for the day at 07:00
                let dayTimestamp = new Date(curr);
                dayTimestamp.setHours(dayStartHour, 0, 0, 0);
                const dayBaseTime = dayTimestamp.getTime();
                
                for (let i = 0; i < numTasks; i++) {
                    const startMin = cuts[i];
                    const endMin = cuts[i+1];
                    const durationMins = endMin - startMin;
                    const durationMs = durationMins * 60000;
                    
                    const taskName = demoData.taskNames[Math.floor(Math.random() * demoData.taskNames.length)];
                    const comment = longComments[Math.floor(Math.random() * longComments.length)];
                    const pn = demoData.projectNumbers[normalizeTaskName(taskName)];
                    
                    const startAt = dayBaseTime + (startMin * 60000);
                    const endAt = startAt + durationMs;
                    
                    // Note: In archive lists, we usually display them as is. 
                    // In `tasks` (today), we unshift to put newest on top.
                    // For `tasksForDay` array here, let's build it chronologically first.
                    
                    tasksForDay.push({ 
                        id: startAt + i, 
                        name: taskName,
                        totalMs: durationMs,
                        isActive: false,
                        resumed: false,
                        createdAt: startAt,
                        firstStartAt: startAt,
                        lastEndAt: endAt,
                        resumeCount: 0,
                        comment: comment,
                        projectNumber: pn,
                        startAdjusted: false
                    });
                }
                
                // If it is TODAY
                if (sameLocalDate(curr, now)) {
                    // Current tasks usually displayed newest first (descending start time) in the UI list
                    demoData.tasks = [...tasksForDay].reverse();
                } else {
                    const label = new Date(curr).toLocaleDateString("nb-NO", {
                        weekday: "long", year: "numeric", month: "short", day: "numeric"
                    });
                    
                    // Archive tasks are stored chronologically in the day (morning to evening) usually?
                    // Actually, let's keep them chronological (Morning first) inside the archive array 
                    // so they list correctly if the UI renders them in order.
                    // The UI renders `archive.tasks` via iteration. If we want Morning at top, use chronological.
                    // If we want Newest (Afternoon) at top, use reverse.
                    // Standard log logic: usually time flows down. Let's do Morning at top.
                    
                    demoData.archives.push({
                        id: curr.getTime(),
                        label: label,
                        createdAt: new Date(curr).toISOString(),
                        tasks: tasksForDay // Chronological [07:00, 09:00...]
                    });
                }
            }
            
            // Go back one day
            curr.setDate(curr.getDate() - 1);
        }
        
        // Archives are sorted by Date descending (Newest date first)
        demoData.archives.sort((a,b) => b.id - a.id);

        // Sørg for at testprofilen ser realistisk ut ved oppstart:
        // - minst 8 prosjekter i arbeidslisten med 1 time hver (generiske kommentarer)
        // - ett ekstra aktivt prosjekt som ser ut til å ha startet for 8 timer siden
        const nowTs = Date.now();
        const oneHourMs = 60 * 60 * 1000;

        const genericTaskComments = [
            "Avklart med kunde og oppdatert underlag.",
            "Koordinert med fag og justert modell.",
            "Gjennomgått status og registrert avvik.",
            "Oppdatert tegning og kvalitetssikret leveranse.",
            "Kort møte og videre oppfølging avtalt.",
            "Utført kontroll og dokumentert endringer.",
            "Bearbeidet innspill og sendt tilbakemelding.",
            "Forberedt neste steg og oppdatert fremdrift."
        ];

        const dayStartTs = (() => {
            const d = new Date();
            d.setHours(7, 0, 0, 0);
            return d.getTime();
        })();

        const uniqueNames = [...demoData.taskNames];
        for (let k = uniqueNames.length - 1; k > 0; k--) {
            const r = Math.floor(Math.random() * (k + 1));
            [uniqueNames[k], uniqueNames[r]] = [uniqueNames[r], uniqueNames[k]];
        }

        const completedTodayTasks = [];
        const completedCount = Math.min(8, uniqueNames.length);

        for (let idx = 0; idx < completedCount; idx++) {
            const taskName = uniqueNames[idx];
            const taskKey = normalizeTaskName(taskName);
            const projectNumber = (demoData.projectNumbers && demoData.projectNumbers[taskKey]) ? demoData.projectNumbers[taskKey] : "";
            const slotStartTs = dayStartTs + (idx * oneHourMs);
            const slotEndTs = slotStartTs + oneHourMs;

            completedTodayTasks.push({
                id: slotStartTs + idx,
                name: taskName,
                totalMs: oneHourMs,
                isActive: false,
                resumed: false,
                createdAt: slotStartTs,
                firstStartAt: slotStartTs,
                lastEndAt: slotEndTs,
                resumeCount: 0,
                comment: genericTaskComments[idx % genericTaskComments.length],
                projectNumber: projectNumber,
                startAdjusted: false
            });
        }

        const activeStartTs = nowTs - (8 * oneHourMs);
        const activeCandidateName = uniqueNames[completedCount] || demoData.taskNames[0] || "Prosjektarbeid";
        const activeTaskKey = normalizeTaskName(activeCandidateName);
        const activeProjectNumber = (demoData.projectNumbers && demoData.projectNumbers[activeTaskKey]) ? demoData.projectNumbers[activeTaskKey] : "";

        const activeTask = {
            id: nowTs,
            name: activeCandidateName,
            totalMs: 0,
            isActive: true,
            lastStartMs: activeStartTs,
            resumed: false,
            createdAt: activeStartTs,
            firstStartAt: activeStartTs,
            lastEndAt: null,
            resumeCount: 0,
            comment: "Pågår – avklaringer, oppfølging og løpende koordinering.",
            projectNumber: activeProjectNumber,
            startAdjusted: false
        };

        // I dagens arbeidsliste vises nyere elementer øverst. Legg aktiv oppgave først.
        demoData.tasks = [activeTask, ...completedTodayTasks.reverse()];

        // Eksempelnotater for dagen (vises i Notater-vinduet)
        demoData.appNotes = [
            "08:10 – Denne personen sa at revidert underlag kommer før lunsj.",
            "09:25 – Husk å sende oppdatert PDF til prosjektleder før kl 11:30.",
            "10:40 – Må følge opp kommentar fra møte om adkomst og universell utforming.",
            "12:05 – Husk å gjøre disse tingene før kl 14:00: kontroll, eksport, og intern QA.",
            "13:35 – Kunde ønsket en enklere variant i presentasjonen, ta med begge alternativer.",
            "15:20 – Avklare prosjektnummer og kommentar før dagens arkivering."
        ].join("\n");
        // --- TRIGGER DOWNLOAD IMMEDIATELY ---
        const jsonStr = JSON.stringify({
            profile: demoProfileName,
            timestamp: new Date().toISOString(),
            timelineSettings: {
                dayStartMin: 7 * 60, dayEndMin: 16 * 60, // Set timeline to match the data (07-16)
                coreStartMin: 9 * 60, coreEndMin: 14 * 60,
                lunchStartMin: 11 * 60, lunchEndMin: 11 * 60 + 30
            },
            data: demoData
        }, null, 2);

        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "testprofil.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        // Also auto-load it for convenience
        const storageKey = STORAGE_KEY_PREFIX + demoProfileName;
        const timelineKey = TIMELINE_KEY_PREFIX + demoProfileName;
        
        localStorage.setItem(storageKey, JSON.stringify(demoData));
        localStorage.setItem(timelineKey, JSON.stringify({
            dayStartMin: 420, dayEndMin: 960, coreStartMin: 540, coreEndMin: 840, lunchStartMin: 660, lunchEndMin: 690
        }));

        currentProfile = demoProfileName;
        saveProfiles();
        loadFromStorage();
        loadDayTimelineSettings();
        selectedTaskId = null;
        disableCompactMode();
        updateUI();
        renderDayTimeline();
        updateProfileButton();
        renderProfileOptions();
        
        closeSettingsModal();
        return true;
    }

    async function downloadBackup() {
        const payload = {
            profile: currentProfile,
            timestamp: new Date().toISOString(),
            data: data,
            timelineSettings: dayTimelineSettings,
            profileSettings: collectProfileSettingsForExport(currentProfile),
            adhdProfileLocalState: collectAdhdProfileLocalStateForExport(currentProfile)
        };
        const jsonStr = JSON.stringify(payload, null, 2);
        const safeName = currentProfile.replace(/[^a-z0-9]/gi, '_');
        const filename = `${safeName}.json`;

        if (window.showSaveFilePicker) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: filename,
                    types: [{
                        description: 'JSON Backup',
                        accept: {'application/json': ['.json']},
                    }],
                });
                const writable = await handle.createWritable();
                await writable.write(jsonStr);
                await writable.close();
                return;
            } catch (err) {
                if (err.name === 'AbortError') return;
                console.warn('File System Access API error:', err);
            }
        }

        const blob = new Blob([jsonStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    function triggerUpload() {
        if (!backupFileInputEl) return;
        try { backupFileInputEl.value = ""; } catch(e) {}

        // Firefox/strict browser behavior can ignore .click() on display:none file inputs.
        // The input is placed off-screen in the DOM, and we try showPicker() first when available.
        try {
            if (typeof backupFileInputEl.showPicker === "function") {
                backupFileInputEl.showPicker();
                return;
            }
        } catch (err) {
            // fall through to click()
        }

        try {
            backupFileInputEl.click();
        } catch (err) {
            console.warn("Kunne ikke åpne filvelger for gjenoppretting:", err);
        }
    }
    function handleFileSelect(e) {
        const file = e.target.files[0];
        e.target.value = ""; 
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
            try {
                const json = JSON.parse(evt.target.result);
                if (json && json.data && (Array.isArray(json.data.tasks) || Array.isArray(json.data.archives))) {
                    if (!Array.isArray(json.data.tasks)) json.data.tasks = [];
                    if (!Array.isArray(json.data.archives)) json.data.archives = [];

                    const fileNameBase = (() => {
                        try {
                            const rawName = (file && typeof file.name === 'string') ? file.name : '';
                            const withoutPath = rawName.split(/[/\\]/).pop() || '';
                            const base = withoutPath.replace(/\.[^.]+$/, '').trim();
                            return base || '';
                        } catch (_) {
                            return '';
                        }
                    })();
                    // Viktig: bruk filnavnet som profilnavn ved import dersom brukeren har gitt filen nytt navn.
                    // Dette gjør at f.eks. "Standard.json" kan gis nytt navn og importeres som ny profil.
                    const importedProfileName = (fileNameBase || json.profile || "Importert").trim();
                    if (currentProfile !== importedProfileName) {
                        saveToStorage();
                        saveDayTimelineSettings();
                    }
                    if (!profiles.includes(importedProfileName)) {
                        profiles.push(importedProfileName);
                        saveProfiles(); 
                    }
                    const backupTimestamp = json.timestamp ? new Date(json.timestamp).getTime() : Date.now();
                    json.data.tasks.forEach(t => {
                        if (t.isActive) {
                            t.isActive = false;
                            if (t.lastStartMs && !isNaN(backupTimestamp) && backupTimestamp > t.lastStartMs) {
                                const diff = backupTimestamp - t.lastStartMs;
                                t.totalMs = (t.totalMs || 0) + diff;
                            }
                            t.lastStartMs = null;
                            t.lastEndAt = !isNaN(backupTimestamp) ? backupTimestamp : Date.now();
                        }
                    });
                    const targetStorageKey = STORAGE_KEY_PREFIX + importedProfileName;
                    const targetTimelineKey = TIMELINE_KEY_PREFIX + importedProfileName;
                    try {
                        localStorage.setItem(targetStorageKey, JSON.stringify(json.data));
                        if (json.timelineSettings) {
                            localStorage.setItem(targetTimelineKey, JSON.stringify(json.timelineSettings));
                        } else {
                            const defaults = {
                                dayStartMin: 7 * 60, dayEndMin: 17 * 60,
                                coreStartMin: 9 * 60, coreEndMin: 15 * 60,
                                lunchStartMin: 11 * 60 + 30, lunchEndMin: 12 * 60
                            };
                            localStorage.setItem(targetTimelineKey, JSON.stringify(defaults));
                        }
                    } catch (storageErr) {
                        console.error(storageErr);
                        alert("Kunne ikke gjenopprette profil. Lagringsplass i nettleseren kan være full.");
                        return;
                    }

                    applyImportedProfileSettings(importedProfileName, json.profileSettings || json.settings || null);
                    applyImportedAdhdProfileLocalState(json.adhdProfileLocalState || null);

                    currentProfile = importedProfileName;
                    saveProfiles(); 
                    enforceStandardProfileDefaultPanelSettings();
                    loadFromStorage();
                    loadDayTimelineSettings();

                    // Re-apply profile-scoped settings after import so UI/runtime state matches imported profile immediately
                    loadAutoSaveSetting();
                    loadMidnightDoubleCountGuardSetting();
                    loadNoHelpTextSetting();
                    loadProjectDivisionToggleSetting();
                    loadOneNoteReminderSetting();
                    loadPersonalCustomizationValues();
                    loadPersonalCustomizationToggle();
                    loadControlPanelOpenSetting();
                    loadUnderDevelopmentExpandedSetting();
                    syncAdhdToActiveProject();

                    applyStoredSuggestionsHeight();
                    selectedTaskId = null;
                    suggestionIndex = -1;
                    filteredSuggestions = [];
                    taskInputEl.value = "";
                    clearSuggestions();
                    disableCompactMode();
                    renderDayTimeline();
                    updateUI();
                    applyPersonalCustomizationHeadings();
                    try { document.dispatchEvent(new Event('profileLoaded')); } catch(e){}
                    updateProfileButton();
                    renderProfileOptions(); 
                    syncTestDataToggleUI();
                    closeSettingsModal();
                } else {
                    alert("Ugyldig filformat. Filen mangler nødvendige data.");
                }
            } catch (err) {
                console.error(err);
                alert("Kunne ikke lese filen.");
            }
        };
        reader.readAsText(file);
    }

    let themeClickCount = 0;
    let themeResetTimer = null;
    themeToggleButtonEl.addEventListener("click", async () => {
        clearTimeout(themeResetTimer);
        themeClickCount++;
        themeResetTimer = setTimeout(() => { themeClickCount = 0; }, 500);

        if (themeClickCount === 3) {
            applyThemeMode('black');
            themeClickCount = 0;
            clearTimeout(themeResetTimer);
        } else {
            const currentMode = getCurrentThemeMode();
            if (currentMode === 'black' || currentMode === 'dark') {
                applyThemeMode('light');
            } else {
                applyThemeMode('dark');
            }
        }
        drawTaskChart();
        renderDayTimeline();
        updateTimelineNowDot();
    });
    
    if (profileButtonEl) {
        profileButtonEl.addEventListener("click", (e) => {
            // Hurtigtast: når Personlig tilpasning er aktiv -> CTRL + klikk på Profil åpner Personlig tilpasning direkte
            const wantsPersonal = !!(e && e.ctrlKey && (typeof isPersonalCustomizationEnabled === 'function') && isPersonalCustomizationEnabled());
            if (wantsPersonal) {
                try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                try { reopenSettingsAfterPersonalCustomizeClose = false; } catch(_) {}
                if (typeof closeSettingsModal === 'function') closeSettingsModal();
                requestAnimationFrame(() => openPersonalCustomizeModal());
                return;
            }
            openSettingsModal();
        });
    }
    if (settingsCloseButtonEl) settingsCloseButtonEl.addEventListener("click", closeSettingsModal);

    

    // Tilleggsfunksjoner: only UI show/hide (no actions attached to the placeholder toggles)
    function syncControlPanelUi(){
        if (!controlPanelToggleEl || !controlPanelButtonsEl) return;
        const isOpen = !!controlPanelToggleEl.checked;
        controlPanelButtonsEl.classList.toggle("open", isOpen);
        controlPanelButtonsEl.setAttribute("aria-hidden", String(!isOpen));
        if (controlPanelToggleLabelEl) controlPanelToggleLabelEl.textContent = isOpen ? "Skjul tilleggsfunksjoner" : "Åpne tilleggsfunksjoner";
    }
    function loadControlPanelOpenSetting(){
        if (!controlPanelToggleEl) return;
        const val = getProfileScopedSetting(CONTROL_PANEL_OPEN_KEY, { fallbackToGlobal: false });
        controlPanelToggleEl.checked = (val === 'true');
        syncControlPanelUi();
    }
    function saveControlPanelOpenSetting(isOpen){
        setProfileScopedSetting(CONTROL_PANEL_OPEN_KEY, !!isOpen);
    }
    if (controlPanelToggleEl && controlPanelButtonsEl) {
        controlPanelToggleEl.addEventListener("change", () => {
            syncControlPanelUi();
            saveControlPanelOpenSetting(!!controlPanelToggleEl.checked);
        });
        loadControlPanelOpenSetting();
    }
    if (underDevelopmentVisibilityButtonEl) {
        underDevelopmentVisibilityButtonEl.addEventListener('click', () => {
            setUnderDevelopmentExpanded(!underDevelopmentExpanded);
            saveUnderDevelopmentExpandedSetting(underDevelopmentExpanded);
        });
        loadUnderDevelopmentExpandedSetting();
    }
// ESC: lukk og lagre når profil/innstillinger er åpne
    document.addEventListener("keydown", (e) => {
        if (e.key !== "Escape") return;
        if (!settingsOverlayEl || !settingsOverlayEl.classList.contains("show")) return;
        e.preventDefault();
        saveToStorage();
        saveProfiles();
        saveDayTimelineSettings();
        closeSettingsModal();
    });
    if (settingsDoneButtonEl) settingsDoneButtonEl.addEventListener("click", closeSettingsModal);
    if (createProfileButtonEl) createProfileButtonEl.addEventListener("click", createNewProfile);
    if (deleteProfileButtonEl) {
        deleteProfileButtonEl.addEventListener("click", (e) => {
            e.preventDefault();
            showDeleteProfilePopup();
        });
    }
    if (deleteProfileCancelBtnEl) deleteProfileCancelBtnEl.addEventListener("click", hideDeleteProfilePopup);
    if (deleteProfileConfirmBtnEl) deleteProfileConfirmBtnEl.addEventListener("click", executeDeleteProfile);
    if (deleteProfileSaveDeleteBtnEl) deleteProfileSaveDeleteBtnEl.addEventListener("click", executeSaveAndDeleteProfile);
    if (profileSelectEl) profileSelectEl.addEventListener("change", (e) => { switchProfile(e.target.value); });
    if (downloadBackupButtonEl) downloadBackupButtonEl.addEventListener("click", downloadBackup);
    if (uploadBackupButtonEl) uploadBackupButtonEl.addEventListener("click", triggerUpload);
    if (backupFileInputEl) backupFileInputEl.addEventListener("change", handleFileSelect);
    if (cpGenerateTestDataEl) {
        // Behave like a control-panel switch: ON = generate once, then stay ON until profile is deleted
        cpGenerateTestDataEl.addEventListener("change", () => {
            // Prevent manual OFF. The switch state is driven by whether the demo profile exists.
            if (cpGenerateTestDataEl.checked) {
                const ok = generateDemoData();
                if (!ok) cpGenerateTestDataEl.checked = false;
            }
            syncTestDataToggleUI();
        });
        syncTestDataToggleUI();
    }


    // Delete task (X i forslaglisten) confirm popup
    if (deleteTaskCancelBtnEl) deleteTaskCancelBtnEl.addEventListener("click", async () => { hideDeleteTaskPopup(); taskInputEl && taskInputEl.focus(); });
    if (deleteTaskConfirmBtnEl) deleteTaskConfirmBtnEl.addEventListener("click", async () => {
        if (pendingDeleteTaskName) {
            removeTaskNameFromHistory(pendingDeleteTaskName);
            renderSuggestions();
            saveToStorage();
        }
        hideDeleteTaskPopup();
        taskInputEl && taskInputEl.focus();
    });
    if (deleteTaskOverlayEl) deleteTaskOverlayEl.addEventListener("mousedown", (e) => {
        if (e.target === deleteTaskOverlayEl) {
            e.preventDefault();
            hideDeleteTaskPopup();
            taskInputEl && taskInputEl.focus();
        }
    });
    document.addEventListener("keydown", (e) => {
        if (e.key !== "Escape" && e.key !== "Esc") return;
        if (!deleteTaskOverlayEl || !deleteTaskOverlayEl.classList.contains("show")) return;
        e.preventDefault();
        hideDeleteTaskPopup();
        taskInputEl && taskInputEl.focus();
    });
    toggleAllCommentsButtonEl.addEventListener("click", async () => {
        if (toggleAllCommentsButtonEl.disabled) return;
        showAllComments = !showAllComments;
        expandedCommentTaskId = null;
        updateUI();
        saveToStorage();
    });

    if (copyOneNoteButtonEl) {
        copyOneNoteButtonEl.addEventListener("click", async () => {
             let originalTasks = null;
             if (selectedArchiveForCopy) {
                 const archive = data.archives.find(a => a.id === selectedArchiveForCopy);
                 if (archive && Array.isArray(archive.tasks)) {
                     originalTasks = data.tasks;
                     data.tasks = archive.tasks;
                 }
             }

            const tasksToCopy = copySourceTasks || data.tasks;
            if (tasksToCopy.length === 0) return;
            const escapeHtml = (text) => {
                if (!text) return "";
                return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            };

            const roundingOn = isRoundingEnabled || (toggleRoundingButtonEl && toggleRoundingButtonEl.classList.contains("btn-rounding-active"));
            const getTaskCopyMs = (task) => {
                if (!task) return 0;
                let ms = task.isActive ? getTaskElapsedMs(task) : (task.totalMs || 0);
                if (roundingOn) ms = getRoundedMs(ms);
                return ms;
            };
            const formatCommentPlain = (comment) => {
                const value = typeof comment === 'string' ? comment.trim() : '';
                return value ? `Kommentar: ${value}` : '';
            };
            const formatCommentHtml = (comment) => {
                const value = typeof comment === 'string' ? comment.trim() : '';
                return value ? `<div>Kommentar: ${escapeHtml(value).replace(/\n/g, "<br>")}</div>` : '';
            };
            const projectDivisionMap = new Map();
            tasksToCopy.forEach((task) => {
                if (!task || !isProjectDivisionSubTask(task)) return;
                const key = normalizeTaskName(task.parentProject || '');
                if (!key) return;
                if (!projectDivisionMap.has(key)) projectDivisionMap.set(key, []);
                projectDivisionMap.get(key).push(task);
            });
            const topLevelTasksForCopy = tasksToCopy.filter(task => !isProjectDivisionSubTask(task));
            const buildStructuredEntries = () => {
                return topLevelTasksForCopy.map((task) => {
                    const projectName = String(task && task.name || '').trim();
                    const divisionOrder = getStoredProjectDivisionForName(projectName);
                    const groupedSubTasks = projectDivisionMap.get(normalizeTaskName(projectName)) || [];
                    if (!divisionOrder.length || !groupedSubTasks.length) {
                        return {
                            type: 'single',
                            name: projectName,
                            time: formatDuration(getTaskCopyMs(task), false),
                            commentPlain: formatCommentPlain(task.comment),
                            commentHtml: formatCommentHtml(task.comment)
                        };
                    }
                    const groupedSubTaskLookup = new Map();
                    groupedSubTasks.forEach((subTask) => {
                        const key = normalizeTaskName(subTask.subTaskName || subTask.name || '');
                        if (!key || groupedSubTaskLookup.has(key)) return;
                        groupedSubTaskLookup.set(key, subTask);
                    });
                    const orderedSubEntries = [];
                    let parentOnlyMs = getTaskCopyMs(task);
                    let combinedTotalMs = parentOnlyMs;
                    divisionOrder.forEach((subTaskName) => {
                        const subTask = groupedSubTaskLookup.get(normalizeTaskName(subTaskName));
                        const subTaskMs = getTaskCopyMs(subTask);
                        orderedSubEntries.push({
                            name: String(subTaskName || '').trim(),
                            time: formatDuration(subTaskMs, false),
                            commentPlain: formatCommentPlain(subTask && subTask.comment),
                            commentHtml: formatCommentHtml(subTask && subTask.comment)
                        });
                        combinedTotalMs += subTaskMs;
                        if (subTask) groupedSubTaskLookup.delete(normalizeTaskName(subTaskName));
                    });
                    groupedSubTaskLookup.forEach((subTask) => {
                        const subTaskMs = getTaskCopyMs(subTask);
                        orderedSubEntries.push({
                            name: String(subTask.subTaskName || subTask.name || '').trim(),
                            time: formatDuration(subTaskMs, false),
                            commentPlain: formatCommentPlain(subTask.comment),
                            commentHtml: formatCommentHtml(subTask.comment)
                        });
                        combinedTotalMs += subTaskMs;
                    });
                    const projectDisplayMs = projectDivisionEnabled ? parentOnlyMs : combinedTotalMs;
                    if (!projectDivisionEnabled) {
                        return {
                            type: 'single',
                            name: projectName,
                            time: formatDuration(projectDisplayMs, false),
                            commentPlain: formatCommentPlain(task.comment),
                            commentHtml: formatCommentHtml(task.comment)
                        };
                    }
                    return {
                        type: 'project-division',
                        name: projectName,
                        time: formatDuration(projectDisplayMs, false),
                        commentPlain: formatCommentPlain(task.comment),
                        commentHtml: formatCommentHtml(task.comment),
                        items: orderedSubEntries
                    };
                });
            };
            const structuredEntries = buildStructuredEntries();
            const plainText = structuredEntries.map(entry => {
                if (entry.type !== 'project-division') {
                    return [entry.name, entry.time, entry.commentPlain, '-'].filter(Boolean).join('\n');
                }
                const lines = [entry.name, entry.time];
                if (entry.commentPlain) lines.push(entry.commentPlain);
                entry.items.forEach((item, idx) => {
                    lines.push(`${idx + 1}. ${item.name}`);
                    lines.push(`   ${item.time}`);
                    if (item.commentPlain) lines.push(`   ${item.commentPlain}`);
                });
                lines.push('-');
                return lines.join('\n');
            }).join("\n\n");
            const htmlContent = structuredEntries.map(entry => {
                if (entry.type !== 'project-division') {
                    return `<div style="margin-bottom: 1em;"><b>${escapeHtml(entry.name)}</b><br><span style="color: #16a34a; font-weight: 600;">${entry.time}</span>${entry.commentHtml ? `<br>${entry.commentHtml}` : ''}<br>-</div>`;
                }
                const itemsHtml = entry.items.map((item, idx) => {
                    return `<div style="margin-top: 0.4em; padding-left: 1.1em;"><b>${idx + 1}. ${escapeHtml(item.name)}</b><br><span style="color: #16a34a; font-weight: 600;">${item.time}</span>${item.commentHtml ? `<br>${item.commentHtml}` : ''}</div>`;
                }).join('');
                return `<div style="margin-bottom: 1em;"><b>${escapeHtml(entry.name)}</b><br><span style="color: #16a34a; font-weight: 600;">${entry.time}</span>${entry.commentHtml ? `<br>${entry.commentHtml}` : ''}${itemsHtml}<br>-</div>`;
            }).join("");
            try {
                const ok = await copyToClipboard(htmlContent, plainText);
                if (!ok) throw new Error('copy failed');
                if (!copySourceTasks && !selectedArchiveForCopy) {
                    oneNoteReminderCurrentTasksCopySignature = buildOneNoteReminderSignatureForTasks(data.tasks);
                }
                    const originalText = copyOneNoteButtonEl.textContent;
                    copyOneNoteButtonEl.textContent = "Kopiert!";
                    setTimeout(() => { copyOneNoteButtonEl.textContent = originalText; }, 1500);
            } catch (e) {
                navigator.clipboard.writeText(plainText);
                if (!copySourceTasks && !selectedArchiveForCopy) {
                    oneNoteReminderCurrentTasksCopySignature = buildOneNoteReminderSignatureForTasks(data.tasks);
                }
                alert("Kopierte som ren tekst (nettleseren støttet ikke rik formatering).");
            } finally {
                if (originalTasks) {
                    data.tasks = originalTasks;
                }
            }
        });
    }

    if (toggleListHeightButtonEl) {
        toggleListHeightButtonEl.addEventListener("click", async () => {
            const isExpanded = taskListEl.classList.contains("expanded");
            if (!isExpanded) {
                taskListEl.classList.add("expanded");
                if (taskListWrapperEl) taskListWrapperEl.classList.add("expanded");
                toggleListHeightButtonEl.textContent = "Minimer liste";
            } else {
                taskListEl.classList.remove("expanded");
                if (taskListWrapperEl) taskListWrapperEl.classList.remove("expanded");
                toggleListHeightButtonEl.textContent = "Utvid liste";
            }
        });
    }
    if (toggleRoundingButtonEl) {
        toggleRoundingButtonEl.addEventListener("click", async () => {
            isRoundingEnabled = !isRoundingEnabled;
            if (isRoundingEnabled) {
                toggleRoundingButtonEl.classList.add("btn-rounding-active");
                toggleRoundingButtonEl.textContent = "Avrunding PÅ";
            } else {
                toggleRoundingButtonEl.classList.remove("btn-rounding-active");
                toggleRoundingButtonEl.textContent = "Avrund tid";
            }
            updateUI();
        });
    }
    if (resizeHandleEl && taskListWrapperEl) {
        let isResizing = false;
        resizeHandleEl.addEventListener('mousedown', (e) => {
            isResizing = true;
            resizeHandleEl.classList.add('resizing');
            resizeHandleEl.classList.remove('handle-release-anim'); 
            document.body.style.cursor = 'col-resize'; 
            e.preventDefault(); 
        });
        resizeHandleEl.addEventListener('touchstart', (e) => {
            isResizing = true;
            resizeHandleEl.classList.add('resizing');
            resizeHandleEl.classList.remove('handle-release-anim');
            e.preventDefault();
        });
        resizeHandleEl.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const containerWidth = taskListWrapperEl.offsetWidth;
            const newGap = Math.max(50, containerWidth - 140);
            taskListWrapperEl.style.setProperty('--dynamic-gap', newGap + "px");
        });
        const handleMove = (clientX) => {
            if (!isResizing) return;
            const rect = taskListWrapperEl.getBoundingClientRect();
            let newGap = clientX - rect.left;
            if (newGap < 50) newGap = 50;
            if (newGap > rect.width - 50) newGap = rect.width - 50;
            taskListWrapperEl.style.setProperty('--dynamic-gap', newGap + "px");
        };
        document.addEventListener('mousemove', (e) => handleMove(e.clientX));
        document.addEventListener('touchmove', (e) => handleMove(e.touches[0].clientX));
        const stopResize = () => {
            if (isResizing) {
                isResizing = false;
                suppressProjectDivisionOutsideCloseUntil = Date.now() + 350;
                resizeHandleEl.classList.remove('resizing');
                resizeHandleEl.classList.add('handle-release-anim'); 
                document.body.style.cursor = '';
            }
        };
        document.addEventListener('mouseup', stopResize);
        document.addEventListener('touchend', stopResize);
    }

    startButtonEl.addEventListener("click", async () => {
        if (selectedProjectDivisionTarget) {
            startOrResumeProjectDivisionTask(selectedProjectDivisionTarget.projectName, selectedProjectDivisionTarget.subTaskName);
        } else if (selectedTaskId !== null) {
            const selectedTask = data.tasks.find(t => t.id === selectedTaskId);
            if (selectedTask && selectedTask.isActive) {
                updateUI();
                return;
            }
            resumeTask(selectedTaskId);
        } else {
            const name = taskInputEl.value.trim();
            if (!name) return;
            startOrResumeByName(name);
        }
    });
    endButtonEl.addEventListener("click", async () => {
        endDayPressedAtMs = Date.now();
        finalizeActiveTask();
        finalizeTemporaryMidnightGuardSuspend();
        saveToStorage();
        updateUI();
        autoResizeSplitter(); 
        enableCompactMode();  
        // Switch to Work Mode automatically when ending day
        saveTimelineMode('work');
        renderDayTimeline();
        
        if (autoSaveOnEndDay) {
            downloadBackup();
        }
    });
    transferTimeButtonEl.addEventListener("click", async () => { if (!transferTimeButtonEl.disabled) showTransferPopup(); });
    transferCloseButtonEl.addEventListener("click", () => hideTransferPopup());
    transferCancelButtonEl.addEventListener("click", () => hideTransferPopup());
    transferConfirmButtonEl.addEventListener("click", () => transferTimeConfirm());
    adjustStartButtonEl.addEventListener("click", async () => { if (!adjustStartButtonEl.disabled) showAdjustStartPopup(); });
    adjustStartCloseButtonEl.addEventListener("click", () => hideAdjustStartPopup());
    adjustStartCancelButtonEl.addEventListener("click", () => hideAdjustStartPopup());
    adjustStartConfirmButtonEl.addEventListener("click", () => adjustStartConfirm());
    clearButtonEl.addEventListener("click", async () => {
        if (clearButtonEl.disabled) return;
        if (shouldBlockClearArchiveForOneNoteReminder()) { showOneNoteReminderPopup(); return; }
        showClearTodayPopup();
    });
    clearTodayCancelButtonEl.addEventListener("click", () => hideClearTodayPopup());
    clearTodayConfirmButtonEl.addEventListener("click", async () => {
        if (shouldBlockClearArchiveForOneNoteReminder()) { hideClearTodayPopup(); showOneNoteReminderPopup(); return; }
        hideClearTodayPopup();
        clearAndArchiveTasks();
    });
    if (oneNoteReminderCloseButtonEl) oneNoteReminderCloseButtonEl.addEventListener("click", () => hideOneNoteReminderPopup());
    if (oneNoteReminderOkButtonEl) oneNoteReminderOkButtonEl.addEventListener("click", () => hideOneNoteReminderPopup());
    if (oneNoteReminderOverlayEl) {
        oneNoteReminderOverlayEl.addEventListener("mousedown", (e) => {
            if (e.target === oneNoteReminderOverlayEl) hideOneNoteReminderPopup();
        });
    }
    exportButtonEl.addEventListener("click", () => exportArchivesToCsv());
    clearArchivesButtonEl.addEventListener("click", () => showClearArchivesPopup());
    clearArchivesDeleteButtonEl.addEventListener("click", async () => { deleteAllArchives(); hideClearArchivesPopup(); });
    clearArchivesExportDeleteButtonEl.addEventListener("click", async () => {
        const ok = exportArchivesToCsv();
        if (ok) deleteAllArchives();
        hideClearArchivesPopup();
    });
    clearArchivesCloseButtonEl.addEventListener("click", () => hideClearArchivesPopup());
    clearArchivesCancelButtonEl.addEventListener("click", () => hideClearArchivesPopup());
    overdueConfirmButtonEl.addEventListener("click", async () => {
        const hour = parseInt(overdueHourEl.value, 10);
        const minute = parseInt(overdueMinuteEl.value, 10);
        const activeBefore = getActiveTask();

        if (overduePopupMode === "midnightGuard") {
            // Correct the provisional auto-stop (23:59) using the user-entered end time on the previous day.
            let corrected = false;

            // Case 1: task is somehow still active (fallback)
            if (getActiveTask()) {
                finalizeActiveTaskAtSameStartDate(hour, minute);
                const stillActiveTask = data.tasks.find(t => t && t.midnightGuardPending);
                if (stillActiveTask) {
                    stillActiveTask.midnightGuardPending = false;
                    delete stillActiveTask.midnightGuardBaseMs;
                    delete stillActiveTask.midnightGuardStartMs;
                }
                corrected = true;
            } else {
                // Case 2: normal flow after auto-stop (task is inactive, but marked as pending correction)
                const pendingTask = [...data.tasks].reverse().find(t => t && t.midnightGuardPending);
                if (pendingTask) {
                    const baseMs = Math.max(0, Number(pendingTask.midnightGuardBaseMs || 0));
                    const startMs = Number(pendingTask.midnightGuardStartMs || pendingTask.lastStartMs || pendingTask.firstStartAt || 0);

                    if (startMs > 0) {
                        const startDate = new Date(startMs);
                        const endDate = new Date(startDate);
                        endDate.setHours(hour, minute, 0, 0);

                        const delta = Math.max(0, endDate.getTime() - startMs);
                        pendingTask.totalMs = baseMs + delta;
                        pendingTask.lastEndAt = endDate.getTime();
                        pendingTask.isActive = false;
                        pendingTask.lastStartMs = null;
                        corrected = true;
                    }
                    pendingTask.midnightGuardPending = false;
                    delete pendingTask.midnightGuardBaseMs;
                    delete pendingTask.midnightGuardStartMs;
                }
            }

            hideOverduePopup();
            // Vis normal oversikt og krev arkivering før ny/gjenopptatt føring når vakten er aktiv.
            selectedTaskId = null;
            endDayPressedAtMs = Date.now();
            saveTimelineMode('work');
            saveToStorage();
            updateUI();
            autoResizeSplitter();
            enableCompactMode();
            return;
        }

        finalizeActiveTaskAt(hour, minute);
        let archiveBaseTs = null;
        if (activeBefore) {
            const sameTask = data.tasks.find(t => t.id === activeBefore.id);
            if (sameTask && sameTask.lastEndAt) archiveBaseTs = sameTask.lastEndAt;
        }
        hideOverduePopup();
        saveToStorage();
        if (shouldBlockClearArchiveForOneNoteReminder()) {
            showOneNoteReminderPopup();
            return;
        }
        clearAndArchiveTasks(archiveBaseTs);
    });
    projectCloseButtonEl.addEventListener("click", () => hideProjectPopup());
    projectCancelButtonEl.addEventListener("click", () => hideProjectPopup());
    projectConfirmButtonEl.addEventListener("click", () => confirmProjectPopup());

// Live update: when toggling "Utgått" in the project edit popup, update list immediately in the background
if (projectOutdatedCheckboxEl) {
    projectOutdatedCheckboxEl.addEventListener("change", () => {
        if (!pendingNewTaskName) return;
        const name = (projectNameEditInputEl && projectPopupMode === "edit")
            ? (projectNameEditInputEl.value || pendingNewTaskName).trim()
            : (pendingNewTaskName || "").trim();
        if (!name) return;

        // Persist manual outdated flag and refresh list view behind the popup
        setOutdatedForName(name, !!projectOutdatedCheckboxEl.checked, true);
        saveToStorage();
        // Re-render suggestions even if input isn't focused (allowed while overlay is open)
        renderSuggestions();
    });
}
    projectNumberInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") { e.preventDefault(); confirmProjectPopup(); }
        if (e.key === "Escape") { e.preventDefault(); hideProjectPopup(); }
            if (deleteTaskOverlayEl && deleteTaskOverlayEl.classList.contains("show")) { hideDeleteTaskPopup(); return; }
    });

    if (projectTaskDivisionButtonEl) projectTaskDivisionButtonEl.addEventListener('click', openProjectTaskDivisionModal);
    if (projectTaskDivisionTextareaEl) {
        projectTaskDivisionTextareaEl.addEventListener('input', updateProjectTaskDivisionLineNumbers);
        projectTaskDivisionTextareaEl.addEventListener('scroll', updateProjectTaskDivisionLineNumbers);
        projectTaskDivisionTextareaEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveProjectTaskDivisionFromModal();
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                closeProjectTaskDivisionModal();
            }
        });
    }
    if (projectTaskDivisionCloseButtonEl) projectTaskDivisionCloseButtonEl.addEventListener('click', closeProjectTaskDivisionModal);
    if (projectTaskDivisionCancelButtonEl) projectTaskDivisionCancelButtonEl.addEventListener('click', closeProjectTaskDivisionModal);
    if (projectTaskDivisionOkButtonEl) projectTaskDivisionOkButtonEl.addEventListener('click', saveProjectTaskDivisionFromModal);
    if (projectTaskDivisionOverlayEl) {
        projectTaskDivisionOverlayEl.addEventListener('click', (e) => {
            if (e.target === projectTaskDivisionOverlayEl) saveProjectTaskDivisionFromModal();
        });
    }
    commentCloseButtonEl.addEventListener("click", () => hideCommentPopup());
    commentCancelButtonEl.addEventListener("click", () => hideCommentPopup());
    commentSaveButtonEl.addEventListener("click", () => saveComment());
    commentTextareaEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); saveComment(); }
    });
    restoreDayCancelButtonEl.addEventListener("click", () => hideRestoreDayPopup());
    restoreDayConfirmButtonEl.addEventListener("click", () => restoreDayConfirm());

    taskInputEl.addEventListener("keydown", (e) => {
        if (e.key === "ArrowDown" || e.key === "ArrowUp") {
            if (!Array.isArray(filteredSuggestions) || filteredSuggestions.length === 0) renderSuggestions();
            if (filteredSuggestions.length === 0) return;
            e.preventDefault();
            if (e.key === "ArrowDown") suggestionIndex = (suggestionIndex + 1 + filteredSuggestions.length) % filteredSuggestions.length;
            else suggestionIndex = (suggestionIndex - 1 + filteredSuggestions.length) % filteredSuggestions.length;
            renderSuggestions();
            return;
        }
        if (e.key === "Enter") {
            e.preventDefault();
            const hasSelection = suggestionIndex >= 0 && suggestionIndex < filteredSuggestions.length && filteredSuggestions.length > 0;
            if (hasSelection) {
                const name = filteredSuggestions[suggestionIndex];
                selectedTaskId = null;
                startOrResumeByName(name);
            } else {
                selectedTaskId = null;
                selectedProjectDivisionTarget = null;
                const name = taskInputEl.value.trim();
                if (!name) return;
                startOrResumeByName(name);
            }
            return;
        }
        if (e.key === "Escape") { if (filteredSuggestions.length > 0) { e.preventDefault(); clearSuggestions(); } return; }
    });
    taskInputEl.addEventListener("input", () => {
        if (selectedTaskId !== null) { selectedTaskId = null; }
        if (selectedProjectDivisionTarget) { selectedProjectDivisionTarget = null; }
        if (tempTaskSelectionTimer) { clearTimeout(tempTaskSelectionTimer); tempTaskSelectionTimer = null; }
        document.body.classList.remove("temp-task-selection");
        updateUI();
suggestionIndex = -1;
        renderSuggestions();
    });
    taskInputEl.addEventListener("focus", () => { suggestionIndex = -1; renderSuggestions(); });
    taskInputEl.addEventListener("blur", () => { /* keep suggestions open; closed by outside click */ });


    // Close task suggestions only when clicking outside (no blur/timer auto-close)
    function isTaskSuggestionsOpen() {
        return !!(taskSuggestionsEl && taskSuggestionsEl.style.display !== 'none' && taskSuggestionsEl.innerHTML && taskSuggestionsEl.innerHTML.trim() !== '');
    }

    document.addEventListener('pointerdown', (e) => {
        if (!isTaskSuggestionsOpen()) return;
        const t = e.target;
        // If click is inside input, suggestions, or helper, keep open
        if (t.closest('#taskInput') || t.closest('#taskSuggestions') || t.closest('#taskListHelper') || t.closest('#projectOverlay .modal')) return;
        clearSuggestions();
    }, true);


    let taskClickTimer = null;
    let projectDivisionClickTimer = null;
    taskListEl.addEventListener("click", (e) => {
        if (taskClickTimer) clearTimeout(taskClickTimer);
        const divisionArrow = e.target.closest('.project-division-arrow');
        if (divisionArrow) {
            if (projectDivisionClickTimer) {
                clearTimeout(projectDivisionClickTimer);
                projectDivisionClickTimer = null;
            }
            const parentRow = divisionArrow.closest('.task-list-item');
            const parentId = Number(parentRow && parentRow.dataset ? parentRow.dataset.id : 0);
            if (parentId) {
                e.preventDefault();
                e.stopPropagation();
                toggleWorkListProjectDivision(parentId);
            }
            taskClickTimer = null;
            return;
        }
        const divisionLi = e.target.closest('.project-division-item');
        if (divisionLi) {
            if (projectDivisionClickTimer) clearTimeout(projectDivisionClickTimer);
            const projectName = divisionLi.dataset.projectName || '';
            const subTaskName = divisionLi.dataset.subTaskName || '';
            projectDivisionClickTimer = setTimeout(() => {
                const nextSelection = makeProjectDivisionSelection(projectName, subTaskName);
                selectedProjectDivisionTarget = isSameProjectDivisionSelection(selectedProjectDivisionTarget, nextSelection) ? null : nextSelection;
                selectedTaskId = null;
                if (tempTaskSelectionTimer) {
                    clearTimeout(tempTaskSelectionTimer);
                    tempTaskSelectionTimer = null;
                }
                document.body.classList.remove("temp-task-selection");
                updateUI();
                projectDivisionClickTimer = null;
            }, 220);
            return;
        }
        const li = e.target.closest(".task-list-item");
        if (!li) return;
        const id = Number(li.dataset.id);
        if (!id) return;
        const task = data.tasks.find(t => t.id === id);
        if (!task) return;

        taskClickTimer = setTimeout(() => {
            selectedProjectDivisionTarget = null;

            const isExpandedProjectDivisionParent = taskHasWorkListProjectDivision(task) && expandedProjectDivisionTaskId === id;
            selectedTaskId = (selectedTaskId === id) ? null : id;
            if (isExpandedProjectDivisionParent) {
                expandedProjectDivisionTaskId = id;
            }

            if (tempTaskSelectionTimer) {
                clearTimeout(tempTaskSelectionTimer);
                tempTaskSelectionTimer = null;
            }

            const active = getActiveTask();

            if (selectedTaskId && ((!active) || (active && selectedTaskId !== active.id))) {
                document.body.classList.add("temp-task-selection");
                tempTaskSelectionTimer = setTimeout(() => {
                    selectedTaskId = null;
                    document.body.classList.remove("temp-task-selection");
                    tempTaskSelectionTimer = null;
                    updateUI();
                }, 10000);
            } else {
                document.body.classList.remove("temp-task-selection");
            }

            updateUI();
            taskClickTimer = null;
        }, 220);
    });
    document.addEventListener('click', (e) => {
        if (expandedProjectDivisionTaskId === null) return;
        if (Date.now() < suppressProjectDivisionOutsideCloseUntil) return;
        const t = e.target;
        const insideExpandedDivision = t.closest('.task-list-item, .project-division-row');
        if (insideExpandedDivision) return;
        if (t.closest('#resizeHandle') || t.closest('#commentOverlay .modal')) return;
        const clickedInteractiveControl = !!t.closest('button, input, select, textarea, label, a, summary, details, [role="button"], .btn-secondary, .btn-primary, .btn-danger, .circle-btn, .archive-header-toggle, .modal, .popup-content, .timeline-seg, .adhd-strip, .helper-text');
        if (clickedInteractiveControl) return;
        expandedProjectDivisionTaskId = null;
        updateUI();
    });

    taskListEl.addEventListener("dblclick", (e) => {
        if (taskClickTimer) { clearTimeout(taskClickTimer); taskClickTimer = null; }
        if (projectDivisionClickTimer) { clearTimeout(projectDivisionClickTimer); projectDivisionClickTimer = null; }
        const divisionLi = e.target.closest('.project-division-item');
        if (divisionLi) {
            e.preventDefault();
            e.stopPropagation();
            const projectName = divisionLi.dataset.projectName || '';
            const subTaskName = divisionLi.dataset.subTaskName || '';
            const subTask = ensureProjectDivisionTask(projectName, subTaskName);
            selectedProjectDivisionTarget = makeProjectDivisionSelection(projectName, subTaskName);
            showCommentPopup(subTask);
            return;
        }
        const li = e.target.closest(".task-list-item");
        if (!li) return;
        const id = Number(li.dataset.id);
        if (!id) return;
        const task = data.tasks.find(t => t.id === id);
        if (!task) return;
        selectedTaskId = id;
        selectedProjectDivisionTarget = null;
        if (projectDivisionEnabled && taskHasWorkListProjectDivision(task) && expandedProjectDivisionTaskId !== id) {
            expandedProjectDivisionTaskId = id;
            updateUI();
            return;
        }
        showCommentPopup(task);
    });


    function normalizeAdhdTasksState(raw){
        const base = { items: [], comments: [], completed: [], activeIndex: 0, startedAt: null, completedAt: [], breakdownShown: false };
        if (!raw || typeof raw !== 'object') return base;
        if (Array.isArray(raw.items)) base.items = raw.items.map(v => String(v || '').trim()).filter(Boolean);
        if (Array.isArray(raw.comments)) base.comments = raw.comments.map(v => String(v || '')).slice(0, base.items.length);
        while (base.comments.length < base.items.length) base.comments.push('');
        if (Array.isArray(raw.completed)) base.completed = raw.completed.map(v => !!v).slice(0, base.items.length);
        while (base.completed.length < base.items.length) base.completed.push(false);
        base.activeIndex = Math.max(0, Math.min(parseInt(raw.activeIndex || 0, 10) || 0, Math.max(0, base.items.length)));
        if (typeof raw.startedAt === 'number') base.startedAt = raw.startedAt;
        if (Array.isArray(raw.completedAt)) base.completedAt = raw.completedAt.map(v => (typeof v === 'number' ? v : null));
        while (base.completedAt.length < base.items.length) base.completedAt.push(null);
        base.breakdownShown = !!raw.breakdownShown;
        // move activeIndex to first unfinished if needed
        const firstUnfinished = base.completed.findIndex(v => !v);
        if (firstUnfinished === -1) base.activeIndex = base.items.length;
        else if (base.activeIndex >= base.items.length || base.completed[base.activeIndex]) base.activeIndex = firstUnfinished;
        return base;
    }

    function saveAdhdTasksState(){
        if (!getAdhdActiveProjectKey()) return;
        try { localStorage.setItem(getAdhdTasksKey(), JSON.stringify(adhdTasksState)); } catch(e){}
    }

    function updateAdhdModeToggleVisualState(){
        if (cpAdhdModeLabelEl) cpAdhdModeLabelEl.classList.toggle('is-active', !!adhdModeArmed);
    }

    function loadAdhdTasksState(){
        if (!getAdhdActiveProjectKey()) {
            adhdTasksState = normalizeAdhdTasksState(null);
            renderAdhdStrip();
            return;
        }
        let parsed = null;
        try { parsed = JSON.parse(localStorage.getItem(getAdhdTasksKey()) || 'null'); } catch(e){}
        adhdTasksState = normalizeAdhdTasksState(parsed);
        renderAdhdStrip();
    }

    function saveAdhdModeArmSetting(){
        const activeProjectKey = getAdhdActiveProjectKey();
        if (!activeProjectKey) return;
        try { localStorage.setItem(getAdhdModeArmKey(), String(!!adhdModeArmed)); } catch(e){}
    }

    function loadAdhdModeArmSetting(){
        const projectKey = getAdhdActiveProjectKey();
        if (!projectKey) {
            adhdModeArmed = false;
        } else {
            const val = localStorage.getItem(getAdhdModeArmKey());
            adhdModeArmed = (val === 'true');
        }
        if (cpAdhdModeEl) cpAdhdModeEl.checked = adhdModeArmed;
        updateAdhdModeToggleVisualState();
    }

    function loadAdhdModeSetting(){
        const wasEnabled = !!adhdModeEnabled;
        const projectKey = getAdhdActiveProjectKey();
        if (!projectKey) {
            adhdModeEnabled = false;
        } else {
            const val = localStorage.getItem(getAdhdModeKey());
            adhdModeEnabled = (val === 'true');
        }
        if (adhdModeEnabled && !adhdModeArmed) {
            adhdModeEnabled = false;
        }

        if (!wasEnabled && adhdModeEnabled) {
            rememberThemeBeforeAdhd();
            drawTaskChart();
            renderDayTimeline();
            updateTimelineNowDot();
        } else if (wasEnabled && !adhdModeEnabled) {
            restoreThemeAfterAdhd();
        }

        document.body.classList.toggle('adhd-mode-active', adhdModeEnabled);
        renderAdhdStrip();
    }

    function setAdhdModeEnabled(nextEnabled, opts = {}){
        const wantEnabled = !!nextEnabled;
        const activeProjectKey = getAdhdActiveProjectKey();
        const wasEnabled = !!adhdModeEnabled;
        if (wantEnabled && !activeProjectKey) {
            adhdModeEnabled = false;
            if (cpAdhdModeEl) cpAdhdModeEl.checked = adhdModeArmed;
            updateAdhdModeToggleVisualState();
            renderAdhdStrip();
            return false;
        }
        if (wantEnabled && !adhdModeArmed) {
            renderAdhdStrip();
            return false;
        }

        adhdModeEnabled = wantEnabled;
        if (cpAdhdModeEl) cpAdhdModeEl.checked = adhdModeArmed;
        updateAdhdModeToggleVisualState();

        if (activeProjectKey) {
            try { localStorage.setItem(getAdhdModeKey(), String(adhdModeEnabled)); } catch(e){}
        }

        if (!wasEnabled && adhdModeEnabled) {
            rememberThemeBeforeAdhd();
        }

        if (adhdModeEnabled) {
            const totalItems = Array.isArray(adhdTasksState.items) ? adhdTasksState.items.length : 0;
            const doneItems = Array.isArray(adhdTasksState.completed) ? adhdTasksState.completed.filter(Boolean).length : 0;

            // Tillat flere Sekvens-økter på samme prosjekt:
            // hvis forrige økt er fullført og brukeren slår på Sekvensmodus igjen,
            // startes en ny tom økt i stedet for å låse seg til gammel fullført liste.
            if (totalItems > 0 && doneItems >= totalItems) {
                adhdTasksState = normalizeAdhdTasksState(null);
                saveAdhdTasksState();
            }

            // Sekvensmodus skal beholde aktivt tema (lys/mørk/AMOLED) og kun gjenopprette ved avslutning hvis tema ble endret underveis.
            if (!adhdTasksState.startedAt && adhdTasksState.items.length) {
                adhdTasksState.startedAt = Date.now();
                saveAdhdTasksState();
            }
        } else if (wasEnabled) {
            restoreThemeAfterAdhd();
        }

        if (wasEnabled !== adhdModeEnabled) {
            drawTaskChart();
            renderDayTimeline();
            updateTimelineNowDot();
        }

        renderAdhdStrip();

        if (adhdModeEnabled && opts.openTasksModal) {
            setTimeout(() => openAdhdTasksModal(), 0);
        }
        return adhdModeEnabled;
    }

    function renderAdhdProgressLine(){
        if (!adhdStripLineEl) return;
        const total = Array.isArray(adhdTasksState.items) ? adhdTasksState.items.length : 0;
        const done = Array.isArray(adhdTasksState.completed) ? adhdTasksState.completed.filter(Boolean).length : 0;
        const frag = document.createDocumentFragment();

        if (total <= 0) {
            const seg = document.createElement('span');
            seg.className = 'adhd-strip-seg is-placeholder';
            frag.appendChild(seg);
            adhdStripLineEl.replaceChildren(frag);
            return;
        }

        for (let i = 0; i < total; i++) {
            const seg = document.createElement('span');
            seg.className = 'adhd-strip-seg' + (i < done ? ' is-done' : ' is-pending');
            seg.title = `${i + 1}. ${adhdTasksState.items[i] || ''}`;
            frag.appendChild(seg);
        }
        adhdStripLineEl.replaceChildren(frag);
    }

    function openAdhdDiscardConfirmPopup(hasItems){
        if (!adhdDiscardOverlayEl) return;
        if (adhdDiscardMessageEl) {
            adhdDiscardMessageEl.textContent = hasItems
                ? 'Dette vil deaktivere Sekvensmodus og slette oppgavelisten for aktivt prosjekt. Fortsette?'
                : 'Dette vil deaktivere Sekvensmodus. Fortsette?';
        }
        adhdDiscardOverlayEl.classList.add('show');
    }

    function closeAdhdDiscardConfirmPopup(){
        if (adhdDiscardOverlayEl) adhdDiscardOverlayEl.classList.remove('show');
    }

    function confirmAdhdDiscardAndDisableFromChartHold(){
        closeAdhdDiscardConfirmPopup();
        adhdTasksState = normalizeAdhdTasksState(null);
        saveAdhdTasksState();
        setAdhdModeEnabled(false);
        renderAdhdStrip();
        return true;
    }

    function discardAdhdTasksAndDisableFromChartHold(){
        const hasItems = Array.isArray(adhdTasksState.items) && adhdTasksState.items.some(v => String(v || '').trim() !== '');
        openAdhdDiscardConfirmPopup(hasItems);
        return false;
    }

    function startAdhdChartHoldArming(){
        if (!chartCanvas || adhdChartHoldTimer) return;
        adhdChartHoldTriggered = false;
        if (chartWrapperEl) chartWrapperEl.classList.remove('adhd-hold-arming');
        if ((adhdModeEnabled || adhdModeArmed) && chartWrapperEl) chartWrapperEl.classList.add('adhd-hold-arming');
        adhdChartHoldTimer = window.setTimeout(() => {
            adhdChartHoldTimer = null;
            adhdChartHoldTriggered = true;
            if (chartWrapperEl) chartWrapperEl.classList.remove('adhd-hold-arming');

            if (adhdModeEnabled) {
                discardAdhdTasksAndDisableFromChartHold();
                return;
            }

            if (!adhdModeArmed) {
                return;
            }

            if (setAdhdModeEnabled(true, { openTasksModal: false })) {
                openAdhdTasksModal();
            }
        }, 3000);
    }

    function stopAdhdChartHoldArming(){
        if (adhdChartHoldTimer) {
            clearTimeout(adhdChartHoldTimer);
            adhdChartHoldTimer = null;
        }
        if (chartWrapperEl) chartWrapperEl.classList.remove('adhd-hold-arming');
    }

    function getAdhdProgressCounts(){
        const total = adhdTasksState.items.length;
        const done = adhdTasksState.completed.filter(Boolean).length;
        return { total, done, left: Math.max(0, total - done) };
    }

    function formatAdhdDuration(ms){
        const m = Math.max(0, Math.round(ms / 60000));
        const h = Math.floor(m / 60);
        const mm = m % 60;
        if (h > 0) return `${h} t ${mm} min`;
        return `${mm} min`;
    }

    function ensureAdhdMergedChartHost(){
        if (!adhdTimelineHostEl) return null;
        if (!adhdMergedChartHostEl || !adhdMergedChartHostEl.isConnected) {
            adhdMergedChartHostEl = document.createElement('div');
            adhdMergedChartHostEl.id = 'adhdMergedChartHost';
            adhdMergedChartHostEl.className = 'adhd-merged-chart-host';
            adhdTimelineHostEl.appendChild(adhdMergedChartHostEl);
        }
        return adhdMergedChartHostEl;
    }

    function applyAdhdTimelineReplacement(){
        if (!adhdTimelineHostEl) return;

        if (adhdStripWrapEl && adhdStripWrapEl.parentElement !== adhdTimelineHostEl) {
            adhdTimelineHostEl.insertBefore(adhdStripWrapEl, adhdTimelineHostEl.firstChild || null);
        }

        const mergedChartHost = ensureAdhdMergedChartHost();

        if (adhdModeEnabled) {
            if (mergedChartHost && chartWrapperEl && chartWrapperEl.parentElement !== mergedChartHost) mergedChartHost.appendChild(chartWrapperEl);
            if (mergedChartHost && chartLegendEl && chartLegendEl.parentElement !== mergedChartHost) mergedChartHost.appendChild(chartLegendEl);
            if (mergedChartHost) mergedChartHost.style.display = 'block';
            if (chartCardEl) chartCardEl.style.display = 'none';
        } else {
            if (chartOriginalParentEl) {
                if (chartWrapperEl && chartWrapperEl.parentElement !== chartOriginalParentEl) chartOriginalParentEl.appendChild(chartWrapperEl);
                if (chartLegendEl && chartLegendEl.parentElement !== chartOriginalParentEl) chartOriginalParentEl.appendChild(chartLegendEl);
            }
            if (mergedChartHost) mergedChartHost.style.display = 'none';
            if (chartCardEl) chartCardEl.style.display = '';
        }

        if (timelineCardTitleEl) timelineCardTitleEl.textContent = adhdModeEnabled ? 'Sekvensmodus' : 'Tidslinje';
        if (adhdTimelineHostEl) adhdTimelineHostEl.style.display = adhdModeEnabled ? 'block' : 'none';
        if (timelineWrapEl) timelineWrapEl.style.display = adhdModeEnabled ? 'none' : '';
    }

    function syncAdhdToActiveProject(){
        const nextKey = getAdhdActiveProjectKey();
        if (nextKey === adhdBoundProjectKey) return;
        adhdBoundProjectKey = nextKey;
        loadAdhdModeArmSetting();
        loadAdhdModeSetting();
        loadAdhdTasksState();
        if (!nextKey) {
            adhdModeArmed = false;
            if (cpAdhdModeEl) cpAdhdModeEl.checked = false;
            updateAdhdModeToggleVisualState();
        }
    }

    function getAdhdCurrentItemIndex(){
        return adhdTasksState.items.findIndex((_,i) => !adhdTasksState.completed[i]);
    }

    function getAdhdTaskStartMsAtIndex(idx){
        if (idx < 0) return null;
        if (!adhdTasksState.startedAt) return null;
        if (idx === 0) return adhdTasksState.startedAt;
        return adhdTasksState.completedAt[idx - 1] || null;
    }

    function buildAdhdBreakdownRows(){
        const rows = [];
        for (let i = 0; i < adhdTasksState.items.length; i++) {
            const startMs = getAdhdTaskStartMsAtIndex(i);
            const endMs = adhdTasksState.completedAt[i] || null;
            let elapsedMs = 0;
            if (startMs && endMs && endMs >= startMs) elapsedMs = endMs - startMs;
            rows.push({ index:i, name: adhdTasksState.items[i] || '', comment: (adhdTasksState.comments && adhdTasksState.comments[i]) ? adhdTasksState.comments[i] : '', elapsedMs, startMs, endMs });
        }
        return rows;
    }

    function normalizeArchiveAdhdRows(rawRows){
        return (Array.isArray(rawRows) ? rawRows : []).map((r, i) => {
            const startMs = (r && Number.isFinite(Number(r.startMs))) ? Number(r.startMs) : null;
            const endMs = (r && Number.isFinite(Number(r.endMs))) ? Number(r.endMs) : null;
            let elapsedMs = (r && Number.isFinite(Number(r.elapsedMs))) ? Number(r.elapsedMs) : 0;
            if ((!elapsedMs || elapsedMs < 0) && startMs && endMs && endMs >= startMs) elapsedMs = endMs - startMs;
            if (!Number.isFinite(elapsedMs) || elapsedMs < 0) elapsedMs = 0;
            return {
                index: Number.isFinite(Number(r && r.index)) ? Number(r.index) : i,
                name: (r && typeof r.name === 'string') ? r.name : '',
                comment: (r && typeof r.comment === 'string') ? r.comment : '',
                elapsedMs,
                startMs,
                endMs
            };
        }).filter(r => (r.name || '').trim() !== '' || (r.comment || '').trim() !== '' || (r.elapsedMs || 0) > 0);
    }

    function getArchiveAdhdBreakdownRowsFromLegacyStorage(archive){
        if (!archive || !Array.isArray(archive.tasks) || !archive.tasks.length) return [];
        const pid = currentProfile || 'default';

        for (const t of archive.tasks) {
            if (!t || t.id == null) continue;
            const key = `taskTimeTracker_adhd_tasks_${pid}_${String(t.id)}`;
            let parsed = null;
            try { parsed = JSON.parse(localStorage.getItem(key) || 'null'); } catch(e) { parsed = null; }
            const state = normalizeAdhdTasksState(parsed);
            if (!state || !Array.isArray(state.items) || !state.items.length) continue;

            const rows = state.items.map((name, i) => {
                const startMs = i === 0 ? (state.startedAt || null) : (state.completedAt && state.completedAt[i - 1] ? state.completedAt[i - 1] : null);
                const endMs = (state.completedAt && state.completedAt[i]) ? state.completedAt[i] : null;
                let elapsedMs = 0;
                if (startMs && endMs && endMs >= startMs) elapsedMs = endMs - startMs;
                return {
                    index: i,
                    name: String(name || ''),
                    comment: (state.comments && typeof state.comments[i] === 'string') ? state.comments[i] : '',
                    elapsedMs,
                    startMs,
                    endMs
                };
            });

            const normalized = normalizeArchiveAdhdRows(rows);
            if (normalized.length) return normalized;
        }
        return [];
    }

    function getArchiveAdhdBreakdownRows(archive){
        const rawRows = (archive && archive.adhdBreakdown && Array.isArray(archive.adhdBreakdown.rows)) ? archive.adhdBreakdown.rows : [];
        const normalized = normalizeArchiveAdhdRows(rawRows);
        if (normalized.length) return normalized;

        // Fallback for eldre arkiver opprettet før Sekvens-breakdown ble lagret i historikk
        return getArchiveAdhdBreakdownRowsFromLegacyStorage(archive);
    }

    function renderAdhdBreakdownPopupRows(rows, opts = {}){
        if (!adhdBreakdownOverlayEl || !adhdBreakdownContentEl) return;
        const safeRows = Array.isArray(rows) ? rows : [];
        const totalMs = safeRows.reduce((sum, r) => sum + (r && r.elapsedMs ? r.elapsedMs : 0), 0);
        const summaryPrefix = (opts && opts.summaryPrefix) ? String(opts.summaryPrefix).trim() : '';
        if (adhdBreakdownSummaryEl) {
            adhdBreakdownSummaryEl.textContent = `${summaryPrefix ? (summaryPrefix + ' • ') : ''}Oppgaver: ${safeRows.length} • Total tid: ${formatAdhdDuration(totalMs)}`;
        }
        const esc = (v) => String(v || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        adhdBreakdownContentEl.innerHTML = safeRows.map((r, idx) => `
            <div style="padding:0.45rem 0; border-bottom:1px solid var(--border-soft);">
                <div style="font-weight:600;">${(Number.isFinite(Number(r.index)) ? Number(r.index) + 1 : idx + 1)}. ${esc(r.name)}</div>
                <div class="inline-note" style="margin-top:0.15rem;">Tid: ${formatAdhdDuration(r.elapsedMs || 0)}${r.startMs && r.endMs ? ` • ${new Date(r.startMs).toLocaleTimeString('nb-NO',{hour:'2-digit',minute:'2-digit'})}–${new Date(r.endMs).toLocaleTimeString('nb-NO',{hour:'2-digit',minute:'2-digit'})}` : ''}</div>
                <div style="margin-top:0.35rem; white-space:pre-wrap; color:var(--text);">${esc(r.comment).replace(/\n/g,'<br>') || '<span class="inline-note">Ingen kommentar</span>'}</div>
            </div>
        `).join('');
        if (!safeRows.length) {
            adhdBreakdownContentEl.innerHTML = '<div class="inline-note" style="padding:0.35rem 0;">Ingen Sekvens-breakdown lagret.</div>';
        }
        adhdBreakdownOverlayEl.classList.add('show');
    }

    function showAdhdBreakdownPopup(){
        const rows = buildAdhdBreakdownRows();
        renderAdhdBreakdownPopupRows(rows);
    }

    function hideAdhdBreakdownPopup(){ if (adhdBreakdownOverlayEl) adhdBreakdownOverlayEl.classList.remove('show'); }

    function openAdhdTaskCommentModal(){
        if (!adhdModeEnabled || !adhdCommentOverlayEl || !adhdCommentTextareaEl) return;
        const idx = getAdhdCurrentItemIndex();
        if (idx < 0) return;
        adhdActiveCommentIndex = idx;
        const itemName = adhdTasksState.items[idx] || '';
        if (adhdCommentTaskLabelEl) adhdCommentTaskLabelEl.textContent = `${idx + 1}. ${itemName}`;
        adhdCommentTextareaEl.value = (adhdTasksState.comments && adhdTasksState.comments[idx]) ? adhdTasksState.comments[idx] : '';
        adhdCommentOverlayEl.classList.add('show');
        setTimeout(() => adhdCommentTextareaEl.focus(), 0);
    }

    function closeAdhdTaskCommentModal(){
        adhdActiveCommentIndex = -1;
        if (adhdCommentOverlayEl) adhdCommentOverlayEl.classList.remove('show');
    }

    function saveAdhdTaskCommentFromModal(){
        if (adhdActiveCommentIndex < 0 || !adhdCommentTextareaEl) return;
        if (!Array.isArray(adhdTasksState.comments)) adhdTasksState.comments = [];
        while (adhdTasksState.comments.length < adhdTasksState.items.length) adhdTasksState.comments.push('');
        adhdTasksState.comments[adhdActiveCommentIndex] = adhdCommentTextareaEl.value || '';
        saveAdhdTasksState();
        closeAdhdTaskCommentModal();
    }

    function renderAdhdStrip(opts={}){
        applyAdhdTimelineReplacement();
        if (!adhdStripWrapEl) return;
        document.body.classList.toggle('adhd-mode-active', !!adhdModeEnabled);
        renderAdhdProgressLine();
        if (!adhdModeEnabled) return;

        const { total, done, left } = getAdhdProgressCounts();
        const firstUnfinished = adhdTasksState.items.findIndex((_,i) => !adhdTasksState.completed[i]);
        const activeIndex = (firstUnfinished === -1) ? adhdTasksState.items.length : firstUnfinished;
        adhdTasksState.activeIndex = activeIndex;

        if (total === 0) {
            adhdCurrentTaskEmptyEl.style.display = '';
            adhdCurrentTaskTextEl.style.display = 'none';
            adhdCurrentTaskCheckEl.style.display = 'none';
            adhdSummaryPillEl.style.display = 'none';
            return;
        }

        if (left <= 0) {
            if (!adhdTasksState.breakdownShown) {
                adhdTasksState.breakdownShown = true;
                saveAdhdTasksState();
                setTimeout(showAdhdBreakdownPopup, 0);
            }
            setAdhdModeEnabled(false);
            return;
        }

        const text = adhdTasksState.items[activeIndex] || '';
        if (opts.enterAnimation && adhdCurrentTaskEl) {
            adhdCurrentTaskEl.classList.remove('is-entering');
            void adhdCurrentTaskEl.offsetWidth;
            adhdCurrentTaskEl.classList.add('is-entering');
        }
        adhdCurrentTaskEmptyEl.style.display = 'none';
        adhdCurrentTaskTextEl.style.display = '';
        adhdCurrentTaskTextEl.textContent = `${activeIndex + 1}. ${text}`;
        const hasComment = !!(adhdTasksState.comments && adhdTasksState.comments[activeIndex]);
        adhdCurrentTaskTextEl.title = hasComment ? `${text} (klikk for kommentar • har kommentar)` : `${text} (klikk for kommentar)`;
        adhdCurrentTaskCheckEl.style.display = '';
        adhdCurrentTaskCheckEl.checked = false;
        adhdCurrentTaskCheckEl.disabled = adhdAnimatingCompletion;
        adhdSummaryPillEl.style.display = '';
        adhdSummaryPillEl.textContent = `Fullført ${done}/${total} • Gjenstår ${left}`;
    }

    function updateAdhdLineNumbers(){
        if (!adhdTasksTextareaEl || !adhdLineNumbersEl) return;
        const lines = Math.max(1, adhdTasksTextareaEl.value.split('\n').length);
        let out = '';
        for (let i=1;i<=lines;i++) out += i + (i < lines ? '\n' : '');
        adhdLineNumbersEl.textContent = out;
        adhdLineNumbersEl.scrollTop = adhdTasksTextareaEl.scrollTop;
    }

    function openAdhdTasksModal(){
        if (!adhdTasksOverlayEl || !adhdTasksTextareaEl) return;
        adhdTasksTextareaEl.value = adhdTasksState.items.join('\n');
        updateAdhdLineNumbers();
        adhdTasksOverlayEl.classList.add('show');
        setTimeout(() => { adhdTasksTextareaEl.focus(); adhdTasksTextareaEl.selectionStart = adhdTasksTextareaEl.value.length; adhdTasksTextareaEl.selectionEnd = adhdTasksTextareaEl.value.length; }, 0);
    }

    function closeAdhdTasksModal(){
        if (!adhdTasksOverlayEl) return;
        adhdTasksOverlayEl.classList.remove('show');
    }

    function saveAdhdTasksFromModal(){
        if (!adhdTasksTextareaEl) return;
        const items = adhdTasksTextareaEl.value.split('\n').map(v => v.trim()).filter(Boolean);

        const prevStartedAt = adhdTasksState.startedAt;
        const prevComments = Array.isArray(adhdTasksState.comments) ? adhdTasksState.comments.slice() : [];
        const prevCompleted = Array.isArray(adhdTasksState.completed) ? adhdTasksState.completed.slice() : [];
        const prevCompletedAt = Array.isArray(adhdTasksState.completedAt) ? adhdTasksState.completedAt.slice() : [];
        const prevBreakdownShown = !!adhdTasksState.breakdownShown;

        // Bevarer status ved navnendring/redigering av eksisterende linjer (index-basert),
        // slik at fullførte oppgaver ikke resettes når teksten justeres.
        const completed = items.map((_, i) => !!prevCompleted[i]);
        const completedAt = items.map((_, i) => prevCompletedAt[i] || null);
        const firstUnfinished = items.findIndex((_, i) => !completed[i]);
        const nextActiveIndex = (firstUnfinished === -1) ? items.length : firstUnfinished;

        adhdTasksState = normalizeAdhdTasksState({
            items,
            comments: items.map((_,i) => prevComments[i] || ''),
            completed,
            activeIndex: nextActiveIndex,
            startedAt: items.length ? (prevStartedAt || Date.now()) : null,
            completedAt,
            breakdownShown: prevBreakdownShown
        });

        saveAdhdTasksState();
        closeAdhdTasksModal();
        renderAdhdStrip({ enterAnimation:true });
    }

    function completeCurrentAdhdTask(){
        if (!adhdModeEnabled || adhdAnimatingCompletion) return;
        const idx = adhdTasksState.items.findIndex((_,i) => !adhdTasksState.completed[i]);
        if (idx === -1) return;
        adhdAnimatingCompletion = true;
        if (adhdCurrentTaskCheckEl) adhdCurrentTaskCheckEl.disabled = true;
        if (adhdCurrentTaskTextEl) {
            adhdCurrentTaskTextEl.classList.remove('is-completing-green');
            void adhdCurrentTaskTextEl.offsetWidth;
            adhdCurrentTaskTextEl.classList.add('is-completing-green');
        }
        window.setTimeout(() => {
            adhdTasksState.completed[idx] = true;
            adhdTasksState.completedAt[idx] = Date.now();
            adhdTasksState.activeIndex = idx + 1;
            saveAdhdTasksState();
            if (adhdCurrentTaskTextEl) adhdCurrentTaskTextEl.classList.remove('is-completing-green');
            adhdAnimatingCompletion = false;
            renderAdhdStrip({ enterAnimation:true });
        }, 1000);
    }

    function animateChart() {
        drawTaskChart();
    }

    if (cpAdhdModeEl) {
        cpAdhdModeEl.addEventListener("change", (e) => {
            const nextArmed = !!e.target.checked;
            if (nextArmed && !getAdhdActiveProjectKey()) {
                e.target.checked = false;
                adhdModeArmed = false;
                updateAdhdModeToggleVisualState();
                return;
            }
            adhdModeArmed = nextArmed;
            saveAdhdModeArmSetting();
            updateAdhdModeToggleVisualState();
            if (!adhdModeArmed && adhdModeEnabled) {
                setAdhdModeEnabled(false);
            }
        });
    }

    function openPersonalCustomizeModal(){
        if (!personalCustomizeOverlayEl) return;
        renderPersonalCustomizeModalRows();
        initPersonalBackgroundDraftForModal();
        personalCustomizeOverlayEl.classList.add('show');
        if (customPageBgVideoEl) {
            try { customPageBgVideoEl.pause(); } catch(e){}
        }
        setTimeout(() => {
            const firstInput = personalCustomizeRowsEl ? personalCustomizeRowsEl.querySelector('input[data-pc-key]') : null;
            if (firstInput) firstInput.focus();
        }, 0);
    }

    function closePersonalCustomizeModal(opts = {}){
        if (!personalCustomizeOverlayEl) return;
        const revertBackgroundPreview = opts.revertBackgroundPreview !== false;
        if (revertBackgroundPreview) {
            const restoreState = personalCustomizeBackgroundSavedSnapshot || readPersonalBackgroundStateFromValues(personalCustomizationValues);
            applyPersonalBackgroundState(restoreState, { preview: false });
        }
        setPersonalBgMediaHistoryOpen(false);
        personalCustomizeOverlayEl.classList.remove('show');
        if (customPageBgVideoEl && document.body.classList.contains('custom-page-bg-active')) {
            const videoVisible = customPageBgVideoEl.style.display !== 'none' && !!customPageBgVideoEl.getAttribute('src');
            if (videoVisible) {
                const p = customPageBgVideoEl.play();
                if (p && typeof p.catch === 'function') p.catch(() => {});
            }
        }
        if (reopenSettingsAfterPersonalCustomizeClose) {
            reopenSettingsAfterPersonalCustomizeClose = false;
            if (settingsOverlayEl && !settingsOverlayEl.classList.contains('show')) {
                requestAnimationFrame(() => openSettingsModal());
            }
        }
    }

    if (cpPersonalCustomizationToggleEl) {
        cpPersonalCustomizationToggleEl.addEventListener('change', (e) => {
            const on = !!e.target.checked;
            if (!on && personalCtrlLightHoldActive) releasePersonalCtrlLightHold();
            if (!on) stopPersonalFruitigerArchiveAutoRotation({ clearSelection: false });
            if (!on) setFrutigerMusicPlayerVisible(false);
            setPersonalCustomizationUiState(on);
            savePersonalCustomizationToggle(on);
            applyPersonalCustomizationHeadings();
        });
    }
    if (openPersonalCustomizeButtonEl) {
        openPersonalCustomizeButtonEl.addEventListener('click', () => {
            reopenSettingsAfterPersonalCustomizeClose = true;
            if (typeof closeSettingsModal === 'function') closeSettingsModal();
            requestAnimationFrame(() => openPersonalCustomizeModal());
        });
    }
    if (toggleFrutigerMusicPlayerButtonEl) {
        toggleFrutigerMusicPlayerButtonEl.addEventListener('click', async () => {
            const nextVisible = !frutigerMusicPlayerVisible;
            setFrutigerMusicPlayerVisible(nextVisible);
            if (nextVisible) {
                try {
                    if (!Array.isArray(frutigerMusicPlaylist) || frutigerMusicPlaylist.length <= 1) {
                        await loadFrutigerMusicPlaylist(true);
                    } else {
                        await loadFrutigerMusicPlaylist(false);
                    }
                } catch(e) {}
            }
            updateFrutigerMusicPlayerUi();
        });
    }
    if (frutigerMusicStartStopButtonEl) {
        frutigerMusicStartStopButtonEl.addEventListener('click', () => { handleFrutigerMusicStartStop(); });
    }
    if (frutigerMusicPauseButtonEl) {
        frutigerMusicPauseButtonEl.addEventListener('click', () => { handleFrutigerMusicPause(); });
    }
    if (frutigerMusicPrevButtonEl) {
        frutigerMusicPrevButtonEl.addEventListener('click', async () => {
            try { await playNextFrutigerMusic(-1); } catch(e) {}
        });
    }
    if (frutigerMusicNextButtonEl) {
        frutigerMusicNextButtonEl.addEventListener('click', async () => {
            try { await playNextFrutigerMusic(1); } catch(e) {}
        });
    }
    if (frutigerMusicAudioEl) {
        try { frutigerMusicAudioEl.preload = 'metadata'; } catch(e){}
        try { frutigerMusicAudioEl.crossOrigin = 'anonymous'; } catch(e){}
        try { frutigerMusicAudioEl.referrerPolicy = 'no-referrer'; } catch(e){}
        frutigerMusicAudioEl.addEventListener('play', () => { setFrutigerMusicStatus('Spiller'); updateFrutigerMusicPlayerUi(); });
        frutigerMusicAudioEl.addEventListener('pause', () => { updateFrutigerMusicPlayerUi(); });
        frutigerMusicAudioEl.addEventListener('ended', async () => {
            try { await playNextFrutigerMusic(1); } catch(e) { updateFrutigerMusicPlayerUi(); }
        });
        frutigerMusicAudioEl.addEventListener('error', async () => {
            frutigerMusicLastError = 'Feil ved avspilling';
            setFrutigerMusicStatus('Feil – prøver alternativ…');
            updateFrutigerMusicPlayerUi();
            try {
                const retried = await playFrutigerMusicTrackByIndex(frutigerMusicCurrentIndex, { autoplay: true, nextSource: true });
                if (retried) return;
            } catch(e) {}
            setFrutigerMusicStatus('Feil – hopper over');
            updateFrutigerMusicPlayerUi();
            try { await playNextFrutigerMusic(1); } catch(e) {}
        });
    }
    updateFrutigerMusicPlayerUi();

    if (personalCustomizeCloseButtonEl) {
        personalCustomizeCloseButtonEl.addEventListener('click', () => closePersonalCustomizeModal());
    }
    if (personalCustomizeCancelButtonEl) {
        personalCustomizeCancelButtonEl.addEventListener('click', () => closePersonalCustomizeModal());
    }
    if (personalCustomizeResetButtonEl) {
        let personalResetHoldTimer = null;
        let personalResetHoldTriggered = false;
        const clearPersonalResetHold = () => {
            if (personalResetHoldTimer) { clearTimeout(personalResetHoldTimer); personalResetHoldTimer = null; }
            personalCustomizeResetButtonEl.classList.remove('danger-hold-pending');
        };
        personalCustomizeResetButtonEl.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            personalResetHoldTriggered = false;
            clearPersonalResetHold();
            personalCustomizeResetButtonEl.classList.add('danger-hold-pending');
            personalResetHoldTimer = setTimeout(() => {
                personalResetHoldTriggered = true;
                clearPersonalBgMediaHistoryEverywhere();
                personalCustomizeResetButtonEl.classList.remove('danger-hold-pending');
            }, 5000);
        });
        ['pointerup','pointerleave','pointercancel'].forEach(evt => {
            personalCustomizeResetButtonEl.addEventListener(evt, clearPersonalResetHold);
        });
        personalCustomizeResetButtonEl.addEventListener('click', () => {
            if (personalResetHoldTriggered) {
                personalResetHoldTriggered = false;
                return;
            }
            resetPersonalCustomizationValues();
        });
    }
    if (personalCustomizeOkButtonEl) {
        personalCustomizeOkButtonEl.addEventListener('click', () => {
            savePersonalCustomizeModalValues();
            writePersonalBackgroundStateToValues(personalCustomizationValues, personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
            savePersonalCustomizationValues();
            applyPersonalCustomizationHeadings();
            personalCustomizeBackgroundSavedSnapshot = readPersonalBackgroundStateFromValues(personalCustomizationValues);
            closePersonalCustomizeModal({ revertBackgroundPreview: false });
        });
    }
    if (personalBgCustomizeButtonEl) {
        personalBgCustomizeButtonEl.addEventListener('click', () => {
            setPersonalBgControlsOpen(!personalBgControlsOpen);
        });
    }
    if (personalRenameControlsToggleButtonEl) {
        personalRenameControlsToggleButtonEl.addEventListener('click', () => {
            setPersonalRenameControlsOpen(!personalRenameControlsOpen);
        });
    }
    if (personalBgColorButtonEl) {
        personalBgColorButtonEl.addEventListener('click', () => {
            setPersonalBgControlsOpen(true);
            const willOpen = !personalBgColorControlsOpen;
            setPersonalBgColorControlsOpen(willOpen);
            if (!willOpen) {
                renderPersonalBackgroundUiFromDraft();
                return;
            }
            const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
            s.type = 'color';
            personalCustomizeBackgroundDraft = s;
            setPersonalBgMediaHistoryOpen(false);
            setPersonalFruitigerArchiveOpen(false);
            renderPersonalBackgroundUiFromDraft();
            applyPersonalBackgroundState(s, { preview: true, forceOn: true });
        });
    }
    if (personalBgMediaButtonEl) {
        personalBgMediaButtonEl.addEventListener('click', () => {
            setPersonalBgControlsOpen(true);
            setPersonalBgMediaHistoryOpen(false);
            setPersonalFruitigerArchiveOpen(false);

            const openWithTemporaryInput = () => {
                try {
                    const tempInput = document.createElement('input');
                    tempInput.type = 'file';
                    tempInput.accept = 'image/*,video/*';
                    tempInput.style.position = 'fixed';
                    tempInput.style.left = '-99999px';
                    tempInput.style.top = '0';
                    tempInput.style.opacity = '0';
                    tempInput.style.width = '1px';
                    tempInput.style.height = '1px';
                    document.body.appendChild(tempInput);
                    tempInput.addEventListener('change', (e) => {
                        const file = e.target && e.target.files ? e.target.files[0] : null;
                        handlePersonalBgMediaFile(file);
                        try { tempInput.remove(); } catch(_) {}
                    }, { once: true });
                    tempInput.click();
                } catch(err) {
                    console.warn('Kunne ikke åpne midlertidig filvelger for bakgrunnsmedia:', err);
                }
            };

            if (!personalBgMediaInputEl) {
                openWithTemporaryInput();
                return;
            }

            try { personalBgMediaInputEl.value = ''; } catch(e) {}
            try {
                if (typeof personalBgMediaInputEl.showPicker === 'function') {
                    personalBgMediaInputEl.showPicker();
                } else {
                    personalBgMediaInputEl.click();
                }
            } catch(e) {
                try {
                    personalBgMediaInputEl.click();
                } catch(err) {
                    openWithTemporaryInput();
                }
            }
        });
    }

    if (personalBgMediaHistoryButtonEl) {
        personalBgMediaHistoryButtonEl.addEventListener('click', () => {
            setPersonalBgControlsOpen(true);
            renderPersonalBgMediaHistoryDropdown();
            setPersonalFruitigerArchiveOpen(false);
            setPersonalBgMediaHistoryOpen(!personalBgMediaHistoryOpen);
        });
    }
    if (personalBgGlassButtonEl) {
        personalBgGlassButtonEl.addEventListener('click', () => {
            setPersonalBgControlsOpen(true);
            const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());

            if (!s.glassEnabled) {
                s.glassEnabled = true;
                s.glassBlurPx = 1;
                personalBgGlassControlsOpen = true;
                personalBgGlassControlsOpenInitialized = true;
                try { applyThemeMode('light'); } catch(e){}
            } else {
                // Når glassmodus allerede er aktiv: bruk knappen som vis/skjul for gjennomsiktighetskontroller
                personalBgGlassControlsOpen = !personalBgGlassControlsOpen;
                personalBgGlassControlsOpenInitialized = true;
            }

            personalCustomizeBackgroundDraft = s;
            setPersonalBgMediaHistoryOpen(false);
            renderPersonalBackgroundUiFromDraft();
            applyPersonalBackgroundState(s, { preview: true, forceOn: true });
        });
    }
    if (personalBgTextColorButtonEl) {
        personalBgTextColorButtonEl.addEventListener('click', () => {
            setPersonalBgControlsOpen(true);
            const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
            s.textOverrideEnabled = !s.textOverrideEnabled;
            personalCustomizeBackgroundDraft = s;
            setPersonalBgMediaHistoryOpen(false);
            setPersonalFruitigerArchiveOpen(false);
            renderPersonalBackgroundUiFromDraft();
            applyPersonalBackgroundState(s, { preview: true, forceOn: true });
        });
    }
    if (personalFruitigerArchiveButtonEl) {
        personalFruitigerArchiveButtonEl.addEventListener('click', async () => {
            const willOpen = !personalFruitigerArchiveOpen;
            setPersonalBgControlsOpen(true);
            setPersonalBgMediaHistoryOpen(false);
            setPersonalFruitigerArchiveOpen(willOpen);
            if (willOpen) {
                try { await loadFruitigerArchiveCategories(false); } catch(e){}
                try { await applyDefaultFruitigerArchiveCategoryIfNeeded(); } catch(e){}
            }
        });
    }
    if (personalFruitigerArchiveIntervalRangeEl) {
        const onArchiveIntervalInput = () => {
            const raw = Number(personalFruitigerArchiveIntervalRangeEl.value || 0);
            personalFruitigerArchiveAutoIntervalSec = Math.max(0, Math.min(600, Number.isFinite(raw) ? raw : 45));
            updatePersonalFruitigerArchiveIntervalUi();
        };
        personalFruitigerArchiveIntervalRangeEl.addEventListener('input', onArchiveIntervalInput);
        personalFruitigerArchiveIntervalRangeEl.addEventListener('change', () => {
            onArchiveIntervalInput();
            const sec = Math.max(0, Math.min(600, Number(personalFruitigerArchiveAutoIntervalSec || 0)));
            const secLabel = sec <= 0 ? 'AV' : `${sec}s`;
            const selected = getPersonalFruitigerArchiveSelectedCategory();

            if (sec <= 0) {
                stopPersonalFruitigerArchiveAutoRotation();
                if (personalFruitigerArchiveHistoryMode) {
                    setPersonalFruitigerArchiveStatus('Auto-bytte er deaktivert (AV): historikk.');
                } else {
                    setPersonalFruitigerArchiveStatus(selected
                        ? `Auto-bytte er deaktivert (AV): «${selected.label || 'Kategori'}».`
                        : 'Auto-bytte er deaktivert (AV). Velg en kategori for manuelt bytte.');
                }
                return;
            }

            const canRun = personalFruitigerArchiveHistoryMode || personalFruitigerArchiveRandomCategoryMode || !!selected;
            if (canRun) {
                personalFruitigerArchiveAutoRunning = true;
                schedulePersonalFruitigerArchiveAutoRotation();
                if (personalFruitigerArchiveHistoryMode) {
                    setPersonalFruitigerArchiveStatus(`Auto-bytte er aktivt: ${secLabel} (historikk).`);
                } else {
                    setPersonalFruitigerArchiveStatus(selected
                        ? `Auto-bytte er aktivt: ${secLabel} (${personalFruitigerArchiveRandomCategoryMode ? 'tilfeldig kategori' : `samme kategori: «${selected.label || 'Kategori'}»`}).`
                        : `Auto-bytte er aktivt: ${secLabel} (${personalFruitigerArchiveRandomCategoryMode ? 'tilfeldig kategori' : 'samme kategori'}).`);
                }
            }
        });
        }
    if (personalFruitigerArchiveModeToggleEl) {
        personalFruitigerArchiveModeToggleEl.addEventListener('click', () => {
            const nextMode = personalFruitigerArchiveHistoryMode ? 'same'
                : (personalFruitigerArchiveRandomCategoryMode ? 'history' : 'random');
            setPersonalFruitigerArchiveModeToggle(nextMode);

            if (personalFruitigerArchiveAutoRunning) schedulePersonalFruitigerArchiveAutoRotation();

            const selected = getPersonalFruitigerArchiveSelectedCategory();
            const sec = Math.max(0, Math.min(600, Number(personalFruitigerArchiveAutoIntervalSec || 0)));
            const secLabel = sec <= 0 ? 'AV' : `${sec}s`;

            if (personalFruitigerArchiveHistoryMode) {
                setPersonalFruitigerArchiveStatus(`Auto-bytte er ${sec <= 0 ? 'deaktivert (AV)' : 'aktivt'}: ${secLabel} (historikk).`);
                return;
            }

            setPersonalFruitigerArchiveStatus(selected
                ? `Auto-bytte er ${sec <= 0 ? 'deaktivert (AV)' : 'aktivt'}: ${secLabel} (${personalFruitigerArchiveRandomCategoryMode ? 'tilfeldig kategori' : `samme kategori: «${selected.label || 'Kategori'}»`}).`
                : `Velg en kategori. Auto-bytte bruker ${secLabel} (${personalFruitigerArchiveHistoryMode ? 'historikk' : (personalFruitigerArchiveRandomCategoryMode ? 'tilfeldig kategori' : 'samme kategori')}).`);
        });
    }
    updatePersonalFruitigerArchiveIntervalUi();
    setPersonalFruitigerArchiveModeToggle(personalFruitigerArchiveHistoryMode ? 'history' : (personalFruitigerArchiveRandomCategoryMode ? 'random' : 'same'));

    if (personalBgMediaInputEl) {
        personalBgMediaInputEl.addEventListener('change', (e) => {
            const file = e.target && e.target.files ? e.target.files[0] : null;
            handlePersonalBgMediaFile(file);
            try { e.target.value = ''; } catch(err){}
        });
    }
    function syncPersonalBgDraftFromSliderInputsWithHueAssist(source){
        if (source === personalBgHueRangeEl && personalBgLightRangeEl) {
            personalBgLightRangeEl.value = '60';
        }
        syncPersonalBgDraftFromSliderInputs();
    }

    [personalBgHueRangeEl, personalBgSatRangeEl, personalBgLightRangeEl].forEach(el => {
        if (!el) return;
        const handler = () => syncPersonalBgDraftFromSliderInputsWithHueAssist(el);
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    function syncPersonalTextDraftFromSliderInputs(source, opts = {}){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        const fastPreview = !!opts.fastPreview;
        if (source === personalTextHueRangeEl && personalTextLightRangeEl) {
            personalTextLightRangeEl.value = '60';
        }
        if (personalTextHueRangeEl) s.textHue = Number(personalTextHueRangeEl.value || s.textHue);
        if (personalTextSatRangeEl) s.textSat = Number(personalTextSatRangeEl.value || s.textSat);
        if (personalTextLightRangeEl) s.textLight = Number(personalTextLightRangeEl.value || s.textLight);
        s.textOverrideEnabled = true;
        personalCustomizeBackgroundDraft = s;

        if (fastPreview) {
            if (customPageBgVideoEl) {
                try { customPageBgVideoEl.pause(); } catch(e){}
            }
            renderPersonalTextUiFromDraftFast();
            applyPersonalTextOverrideState(s, { preview: true, forceOn: true });
            return;
        }

        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(s, { preview: true, forceOn: true });
    }

    [personalTextHueRangeEl, personalTextSatRangeEl, personalTextLightRangeEl].forEach(el => {
        if (!el) return;
        const onInputFastPreview = () => syncPersonalTextDraftFromSliderInputs(el, { fastPreview: true });
        const onCommit = () => syncPersonalTextDraftFromSliderInputs(el, { fastPreview: false });
        el.addEventListener('input', onInputFastPreview);
        el.addEventListener('change', onCommit);
        el.addEventListener('pointerup', onCommit);
        el.addEventListener('keyup', (e) => {
            if (!e || !e.key) return;
            if (e.key.startsWith('Arrow') || e.key === 'Home' || e.key === 'End' || e.key === 'PageUp' || e.key === 'PageDown') {
                onCommit();
            }
        });
    });
    function setPersonalBgGlassBlurPreset(px){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        s.glassBlurPx = normalizePersonalGlassBlurPx(px);
        if (!s.glassEnabled) {
            s.glassEnabled = true;
            try { applyThemeMode('light'); } catch(e){}
        }
        personalCustomizeBackgroundDraft = s;
        personalBgGlassControlsOpen = true;
        personalBgGlassControlsOpenInitialized = true;
        setPersonalBgControlsOpen(true);
        setPersonalBgMediaHistoryOpen(false);
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(s, { preview: true, forceOn: true });
    }

    function setPersonalBgGlassOff(){
        const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
        s.glassEnabled = false;
        personalCustomizeBackgroundDraft = s;
        personalBgGlassControlsOpen = true;
        personalBgGlassControlsOpenInitialized = true;
        setPersonalBgControlsOpen(true);
        setPersonalBgMediaHistoryOpen(false);
        renderPersonalBackgroundUiFromDraft();
        applyPersonalBackgroundState(s, { preview: true, forceOn: true });
    }

    if (personalBgBlurOffButtonEl) {
        personalBgBlurOffButtonEl.addEventListener('click', () => setPersonalBgGlassOff());
    }
    if (personalBgBlurFastButtonEl) {
        personalBgBlurFastButtonEl.addEventListener('click', () => setPersonalBgGlassBlurPreset(1));
    }
    if (personalBgBlurPrettyButtonEl) {
        personalBgBlurPrettyButtonEl.addEventListener('click', () => setPersonalBgGlassBlurPreset(12));
    }
    if (personalBgBlurHeavyButtonEl) {
        personalBgBlurHeavyButtonEl.addEventListener('click', () => setPersonalBgGlassBlurPreset(24));
    }

    if (personalBgGlassOpacityRangeEl) {
        const updateGlassOpacityDraftValue = () => {
            const s = clonePersonalBackgroundState(personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
            s.glassOpacity = Number(personalBgGlassOpacityRangeEl.value || s.glassOpacity);
            personalCustomizeBackgroundDraft = s;
            if (personalBgGlassOpacityValueEl) personalBgGlassOpacityValueEl.textContent = `${Math.round(s.glassOpacity)}%`;
            return s;
        };
        const onGlassOpacityInputPreviewOnly = () => {
            const s = updateGlassOpacityDraftValue();
            schedulePersonalGlassOpacityPreview(s);
        };
        const onGlassOpacityCommit = () => {
            const s = updateGlassOpacityDraftValue();
            applyPersonalBackgroundState(s, { preview: true, forceOn: true });
        };
        personalBgGlassOpacityRangeEl.addEventListener('input', onGlassOpacityInputPreviewOnly);
        personalBgGlassOpacityRangeEl.addEventListener('change', onGlassOpacityCommit);
        personalBgGlassOpacityRangeEl.addEventListener('pointerup', onGlassOpacityCommit);
        personalBgGlassOpacityRangeEl.addEventListener('keyup', (e) => {
            if (!e || !e.key) return;
            if (e.key.startsWith('Arrow') || e.key === 'Home' || e.key === 'End' || e.key === 'PageUp' || e.key === 'PageDown') {
                onGlassOpacityInputPreviewOnly();
                onGlassOpacityCommit();
            }
        });
    }

    if (personalCustomizeOverlayEl) {
        personalCustomizeOverlayEl.addEventListener('click', (e) => {
            const clickedInsideHistory = !!(e.target && e.target.closest && e.target.closest('#personalBgMediaHistoryDropdown'));
            const clickedMediaButton = !!(e.target && e.target.closest && e.target.closest('#personalBgMediaButton'));
            const clickedHistoryButton = !!(e.target && e.target.closest && e.target.closest('#personalBgMediaHistoryButton'));
            if (personalBgMediaHistoryOpen && !clickedInsideHistory && !clickedMediaButton && !clickedHistoryButton) setPersonalBgMediaHistoryOpen(false);
const clickedInsideArchive = !!(e.target && e.target.closest && e.target.closest('#personalFruitigerArchivePanel'));
            const clickedArchiveButton = !!(e.target && e.target.closest && e.target.closest('#personalFruitigerArchiveButton'));
            if (personalFruitigerArchiveOpen && !clickedInsideArchive && !clickedArchiveButton) setPersonalFruitigerArchiveOpen(false);
            if (e.target === personalCustomizeOverlayEl) closePersonalCustomizeModal();
        });
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (personalCustomizeOverlayEl && personalCustomizeOverlayEl.classList.contains('show')) {
                closePersonalCustomizeModal();
            }
            return;
        }
        if (e.key === 'Enter' && personalCustomizeOverlayEl && personalCustomizeOverlayEl.classList.contains('show')) {
            const target = e.target;
            if (target && target.matches && target.matches('#personalCustomizeRows input[data-pc-key]')) {
                e.preventDefault();
                savePersonalCustomizeModalValues();
                writePersonalBackgroundStateToValues(personalCustomizationValues, personalCustomizeBackgroundDraft || getDefaultPersonalBackgroundState());
                savePersonalCustomizationValues();
                applyPersonalCustomizationHeadings();
                personalCustomizeBackgroundSavedSnapshot = readPersonalBackgroundStateFromValues(personalCustomizationValues);
                closePersonalCustomizeModal({ revertBackgroundPreview: false });
            }
        }
    });

    document.addEventListener('keydown', (e) => {
        if (!e) return;
        if (e.key === 'Control') activatePersonalCtrlLightHold();
    });
    document.addEventListener('keyup', (e) => {
        if (!e) return;
        if (e.key === 'Control') releasePersonalCtrlLightHold();
    });
    window.addEventListener('blur', () => releasePersonalCtrlLightHold());
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) releasePersonalCtrlLightHold();
    });

    const adhdStripLineHintEl = document.querySelector('#adhdStrip .adhd-strip-line');
    if (adhdStripLineHintEl && !adhdStripLineHintEl.title) adhdStripLineHintEl.title = 'Klikk for å legge inn eller endre oppgavene';

    if (chartCanvas) {
        chartCanvas.addEventListener('pointerdown', (e) => {
            if (e.button != null && e.button !== 0) return;
            startAdhdChartHoldArming();
        });
        chartCanvas.addEventListener('pointerup', () => stopAdhdChartHoldArming());
        chartCanvas.addEventListener('pointercancel', () => stopAdhdChartHoldArming());
        chartCanvas.addEventListener('pointerleave', () => stopAdhdChartHoldArming());
    }

    if (adhdStripEl) {
        adhdStripEl.addEventListener('click', (e) => {
            if (!adhdModeEnabled) return;
            if (e.target === adhdCurrentTaskTextEl) return;
            if (e.target === adhdCurrentTaskCheckEl) return;
            openAdhdTasksModal();
        });
    }
    if (adhdCurrentTaskTextEl) {
        adhdCurrentTaskTextEl.addEventListener('click', (e) => {
            e.stopPropagation();
            openAdhdTaskCommentModal();
        });
    }
    if (adhdCurrentTaskCheckEl) {
        adhdCurrentTaskCheckEl.addEventListener('change', (e) => {
            if (!e.target.checked) return;
            completeCurrentAdhdTask();
        });
    }
    if (adhdTasksTextareaEl) {
        adhdTasksTextareaEl.addEventListener('input', updateAdhdLineNumbers);
        adhdTasksTextareaEl.addEventListener('scroll', updateAdhdLineNumbers);
        adhdTasksTextareaEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveAdhdTasksFromModal();
            }
        });
    }
    if (adhdTasksCloseButtonEl) adhdTasksCloseButtonEl.addEventListener('click', closeAdhdTasksModal);
    if (adhdTasksCancelButtonEl) adhdTasksCancelButtonEl.addEventListener('click', closeAdhdTasksModal);
    if (adhdTasksOkButtonEl) adhdTasksOkButtonEl.addEventListener('click', saveAdhdTasksFromModal);
    if (adhdTasksOverlayEl) {
        adhdTasksOverlayEl.addEventListener('click', (e) => {
            if (e.target === adhdTasksOverlayEl) saveAdhdTasksFromModal();
        });
    }
    if (adhdCommentCloseButtonEl) adhdCommentCloseButtonEl.addEventListener('click', closeAdhdTaskCommentModal);
    if (adhdCommentCancelButtonEl) adhdCommentCancelButtonEl.addEventListener('click', closeAdhdTaskCommentModal);
    if (adhdCommentSaveButtonEl) adhdCommentSaveButtonEl.addEventListener('click', saveAdhdTaskCommentFromModal);
    if (adhdCommentTextareaEl) adhdCommentTextareaEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            saveAdhdTaskCommentFromModal();
        }
    });
    if (adhdCommentOverlayEl) adhdCommentOverlayEl.addEventListener('click', (e) => { if (e.target === adhdCommentOverlayEl) saveAdhdTaskCommentFromModal(); });
    if (adhdBreakdownCloseButtonEl) adhdBreakdownCloseButtonEl.addEventListener('click', hideAdhdBreakdownPopup);
    if (adhdBreakdownOkButtonEl) adhdBreakdownOkButtonEl.addEventListener('click', hideAdhdBreakdownPopup);
    if (adhdBreakdownOverlayEl) adhdBreakdownOverlayEl.addEventListener('click', (e) => { if (e.target === adhdBreakdownOverlayEl) hideAdhdBreakdownPopup(); });
    if (adhdDiscardCancelButtonEl) adhdDiscardCancelButtonEl.addEventListener('click', closeAdhdDiscardConfirmPopup);
    if (adhdDiscardConfirmButtonEl) adhdDiscardConfirmButtonEl.addEventListener('click', confirmAdhdDiscardAndDisableFromChartHold);
    if (adhdDiscardOverlayEl) adhdDiscardOverlayEl.addEventListener('click', (e) => { if (e.target === adhdDiscardOverlayEl) closeAdhdDiscardConfirmPopup(); });
    if (settingsOverlayEl) {
        settingsOverlayEl.addEventListener('dblclick', (e) => {
            if (e.target === settingsOverlayEl) closeSettingsModal();
        });
    }

    if (dayTimelineCurtainCloseEl) dayTimelineCurtainCloseEl.addEventListener("click", () => closeDayTimelineCurtain());
    if (dayTimelineFromEl) {
        dayTimelineFromEl.addEventListener("change", () => handleDayTimelineFromChanged());
        dayTimelineFromEl.addEventListener("input", () => handleDayTimelineFromChanged());
    }
    if (dayTimelineToEl) {
        dayTimelineToEl.addEventListener("change", () => applyDayTimelineCurtainChange());
        dayTimelineToEl.addEventListener("input", () => applyDayTimelineCurtainChange());
    }

    window.addEventListener('pointerup', () => stopAdhdChartHoldArming());
    window.addEventListener('blur', () => stopAdhdChartHoldArming());

    document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            if (deleteProfileOverlayEl && deleteProfileOverlayEl.classList.contains("show")) { hideDeleteProfilePopup(); return; }
            if (adhdTasksOverlayEl && adhdTasksOverlayEl.classList.contains("show")) { closeAdhdTasksModal(); return; }
            if (adhdCommentOverlayEl && adhdCommentOverlayEl.classList.contains("show")) { closeAdhdTaskCommentModal(); return; }
            if (adhdBreakdownOverlayEl && adhdBreakdownOverlayEl.classList.contains("show")) { hideAdhdBreakdownPopup(); return; }
            if (adhdDiscardOverlayEl && adhdDiscardOverlayEl.classList.contains("show")) { closeAdhdDiscardConfirmPopup(); return; }
            if (settingsOverlayEl && settingsOverlayEl.classList.contains("show")) { closeSettingsModal(); return; }
            if (projectOverlayEl && projectOverlayEl.classList.contains("show")) { hideProjectPopup(); return; }
            if (overdueOverlayEl && overdueOverlayEl.classList.contains("show")) { hideOverduePopup(); return; }
            if (clearArchivesOverlayEl && clearArchivesOverlayEl.classList.contains("show")) { hideClearArchivesPopup(); return; }
            if (clearTodayOverlayEl && clearTodayOverlayEl.classList.contains("show")) { hideClearTodayPopup(); return; }
            if (commentOverlayEl && commentOverlayEl.classList.contains("show")) { hideCommentPopup(); return; }
            if (transferOverlayEl && transferOverlayEl.classList.contains("show")) { hideTransferPopup(); return; }
            if (adjustStartOverlayEl && adjustStartOverlayEl.classList.contains("show")) { hideAdjustStartPopup(); return; }
            if (restoreDayOverlayEl && restoreDayOverlayEl.classList.contains("show")) { hideRestoreDayPopup(); return; }
            if (dayTimelineCurtainEl && dayTimelineCurtainEl.classList.contains("open")) { closeDayTimelineCurtain(); return; }
        }
        if (e.key === "Enter") {
            if (adjustStartOverlayEl && adjustStartOverlayEl.classList.contains("show")) {
                e.preventDefault();
                adjustStartConfirm();
            }
        }
    });

    window.addEventListener("resize", () => scheduleCrossBrowserTimelineRefresh());
    window.addEventListener("load", () => scheduleCrossBrowserTimelineRefresh(), { once: true });

    loadTheme();
    loadProfiles();
    enforceStandardProfileDefaultPanelSettings();
    loadFromStorage();
    loadDayTimelineSettings();
    applyStoredSuggestionsHeight();
    initSuggestionsResizePersistence();
    wireGroupEditModal();
    loadAutoSaveSetting();
    loadMidnightDoubleCountGuardSetting();
    applyMidnightGuardTemporaryVisualState();
    loadNoHelpTextSetting();
    loadProjectDivisionToggleSetting();
    updateProjectTaskDivisionVisibility();
    loadOneNoteReminderSetting();
    loadPersonalCustomizationValues();
    loadPersonalCustomizationToggle();
    syncAdhdToActiveProject();
    applyAdhdTimelineReplacement();
    scheduleCrossBrowserTimelineRefresh();
    updateUI();
    applyPersonalCustomizationHeadings();
    try { document.dispatchEvent(new Event('profileLoaded')); } catch(e){}
    scheduleCrossBrowserTimelineRefresh();
    updateCurrentTimeDisplay();
    updateProfileButton(); 
    
    if (autoSaveToggleEl) {
        autoSaveToggleEl.addEventListener("change", (e) => {
            autoSaveOnEndDay = e.target.checked;
            setProfileScopedSetting(AUTO_SAVE_KEY, !!autoSaveOnEndDay);
        });
    }

    if (cpMidnightGuardEl) {
        cpMidnightGuardEl.addEventListener("change", (e) => {
            // Hvis bruker endrer manuelt, avslutt midlertidig gjenoppta-overstyring
            if (midnightGuardTempResumeSuspended) {
                midnightGuardTempResumeSuspended = false;
                midnightGuardTempResumePrevEnabled = null;
                profileTempGuardIndicatorActive = false;
            }
            midnightDoubleCountGuardEnabled = !!e.target.checked;
            setProfileScopedSetting(MIDNIGHT_DOUBLE_COUNT_GUARD_KEY, !!midnightDoubleCountGuardEnabled);
            applyMidnightGuardTemporaryVisualState();
            updateUI();
            checkOverdueActiveTask();
        });
    }

    if (cpNoHelpTextEl) {
        cpNoHelpTextEl.addEventListener("change", (e) => {
            const on = !!e.target.checked;
            setProfileScopedSetting(NO_HELP_TEXT_KEY, !!on);
            applyNoHelpTextMode(on);
        });
    }

    if (cpProjectDivisionToggleEl) {
        cpProjectDivisionToggleEl.addEventListener("change", (e) => {
            projectDivisionEnabled = !!e.target.checked;
            setProfileScopedSetting(PROJECT_DIVISION_TOGGLE_KEY, !!projectDivisionEnabled);
            updateProjectTaskDivisionVisibility();
            if (!projectDivisionEnabled) closeProjectTaskDivisionModal();
        });
    }

    if (cpOneNoteReminderToggleEl) {
        cpOneNoteReminderToggleEl.addEventListener("change", (e) => {
            oneNoteReminderEnabled = !!e.target.checked;
            setProfileScopedSetting(ONENOTE_REMINDER_KEY, !!oneNoteReminderEnabled);
        });
    }

    drawTaskChart();

    function refreshWorkListLiveTimes() {
        const projectRows = Array.from(taskListEl.querySelectorAll('.task-list-item'));
        projectRows.forEach((row) => {
            const rowId = Number(row.dataset.id || 0);
            const rowTimeSpan = row.querySelector('.task-time');
            if (!rowTimeSpan) return;

            const rowProjectName = String(row.dataset.projectName || '').trim();
            const rowHasProjectDivision = row.dataset.hasProjectDivision === '1' || getStoredProjectDivisionItemsForDisplay(rowProjectName).length > 0;

            if (rowHasProjectDivision && rowProjectName) {
                const parentRawMs = getProjectDivisionParentDisplayRawMs(rowProjectName);
                const parentDisplayMs = isRoundingEnabled ? getRoundedMs(parentRawMs) : parentRawMs;
                const compactMode = taskListEl.classList.contains('compact-mode');
                const showSeconds = !compactMode && !isRoundingEnabled && !projectDivisionEnabled && hasLiveProjectDivisionSeconds(rowProjectName);
                rowTimeSpan.textContent = formatDurationWorkList(parentDisplayMs, showSeconds);
                if (isRoundingEnabled) rowTimeSpan.classList.add('text-rounded');
                else rowTimeSpan.classList.remove('text-rounded');
                return;
            }

            const task = data.tasks.find(t => Number(t.id) === rowId)
                || data.tasks.find(t => !isProjectDivisionSubTask(t) && normalizeTaskName(t.name || '') === normalizeTaskName(rowProjectName));
            if (!task) return;

            const rawMs = task.isActive ? getTaskElapsedMs(task) : (task.totalMs || 0);
            const displayMs = isRoundingEnabled ? getRoundedMs(rawMs) : rawMs;
            if (isRoundingEnabled) rowTimeSpan.classList.add('text-rounded');
            else rowTimeSpan.classList.remove('text-rounded');

            if (task.isActive) {
                rowTimeSpan.textContent = formatDurationWorkList(displayMs, shouldShowWorkListSecondsForTask(task));
            } else {
                rowTimeSpan.textContent = formatDurationWorkList(displayMs, !isRoundingEnabled && shouldShowWorkListSecondsForTask(task));
            }
        });

        const divisionItems = Array.from(taskListEl.querySelectorAll('.project-division-item'));
        divisionItems.forEach((itemEl) => {
            const projectName = itemEl.dataset.projectName || '';
            const subTaskName = itemEl.dataset.subTaskName || '';
            const taskId = Number(itemEl.dataset.taskId || 0);
            const subTask = resolveLiveProjectDivisionTask(projectName, subTaskName, taskId);
            if (subTask && Number(itemEl.dataset.taskId || 0) !== Number(subTask.id)) {
                itemEl.dataset.taskId = String(subTask.id);
            }
            const timeEl = itemEl.querySelector('.project-division-time');
            if (!timeEl) return;
            if (subTask) {
                const rawMs = subTask.isActive ? getTaskElapsedMs(subTask) : (subTask.totalMs || 0);
                const displayMs = isRoundingEnabled ? getRoundedMs(rawMs) : rawMs;
                const compactMode = taskListEl.classList.contains('compact-mode');
                timeEl.textContent = formatDurationWorkList(displayMs, !compactMode && !isRoundingEnabled && shouldShowWorkListSecondsForTask(subTask));
                if (isRoundingEnabled) timeEl.classList.add('text-rounded');
                else timeEl.classList.remove('text-rounded');
            } else {
                timeEl.textContent = taskListEl.classList.contains('compact-mode') ? '00:00' : '00:00:00';
                timeEl.classList.remove('text-rounded');
            }
            itemEl.classList.toggle('is-active', !!(subTask && subTask.isActive));
        });
    }


    function refreshProjectDivisionArrowBlink() {
        document.querySelectorAll('.project-division-arrow.is-collapsed').forEach(el => {
            if (!el.style.animationDelay) el.style.animationDelay = `-${Date.now() % 2000}ms`;
            el.classList.remove('is-blink-off');
        });
        document.querySelectorAll('.project-division-arrow.is-expanded').forEach(el => {
            el.classList.remove('is-blink-off');
            el.style.animationDelay = '0ms';
        });
    }

    function updateActiveTaskTimer() {
        let totalDayMs = 0;
        data.tasks.forEach(t => {
            if (t.isActive) totalDayMs += getTaskElapsedMs(t);
            else totalDayMs += (t.totalMs || 0);
        });
        currentTaskTimeEl.classList.remove("text-rounded-green");
        if (isRoundingEnabled) {
            const displayTotalMs = getRoundedMs(totalDayMs);
            currentTaskTimeEl.classList.add("text-rounded-green");
            currentTaskTimeEl.innerHTML = formatDuration(displayTotalMs, false);
        } else {
            if (totalDayMs > 0) {
                currentTaskTimeEl.innerHTML = formatColoredDuration(totalDayMs);
            } else {
                currentTaskTimeEl.innerHTML = `<span class="time-digit-neutral">00</span>:<span class="time-digit-neutral">00</span>:<span class="time-digit-neutral">00</span>`;
            }
        }
        refreshWorkListLiveTimes();
    }

    setInterval(() => {
        updateCurrentTimeDisplay();
        const activeTaskForLiveRefresh = getActiveTask();
        if (activeTaskForLiveRefresh) {
            updateUI();
        }
        updateActiveTaskTimer();
        if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(refreshWorkListLiveTimes);
        } else {
            refreshWorkListLiveTimes();
        }
        refreshProjectDivisionArrowBlink();
        updateTimelineNowDot();
        checkOverdueActiveTask();
        if (getActiveTask()) drawTaskChart();
    }, 1000);

    // --- Group edit modal (dblclick on group)
    let editingGroupId = null;

    function openGroupEditModal(groupId){
        ensureGroupData();
        const g = getGroupById(groupId);
        if (!g) return;
        editingGroupId = g.id;

        const backdrop = document.getElementById("groupEditBackdrop");
        const nameEl = document.getElementById("groupEditName");
        const colorEl = document.getElementById("groupEditColor");

        if (!backdrop || !nameEl || !colorEl) return;

        nameEl.value = g.name || "";
        // default to current text color if missing
        const color = (g.color && typeof g.color === "string") ? g.color : "";
        colorEl.value = color ? color : "#111827";

        backdrop.style.display = "flex";
        setTimeout(() => { try { nameEl.focus(); nameEl.select(); } catch(e){} }, 0);
    }

    function closeGroupEditModal(){
        const backdrop = document.getElementById("groupEditBackdrop");
        if (backdrop) backdrop.style.display = "none";
        editingGroupId = null;
    }

    function saveGroupEditModal(){
        if (!editingGroupId) { closeGroupEditModal(); return; }
        ensureGroupData();
        const g = getGroupById(editingGroupId);
        if (!g) { closeGroupEditModal(); return; }

        const nameEl = document.getElementById("groupEditName");
        const colorEl = document.getElementById("groupEditColor");

        const newName = (nameEl ? nameEl.value.trim() : "");
        g.name = newName ? newName : (g.name || makeNextGroupName());

        // store explicit color, allow empty (cleared)
        const rawColor = (colorEl ? colorEl.value : "");
        g.color = (rawColor && rawColor !== "#111827") ? rawColor : (g.color || "");

        saveToStorage();
        closeGroupEditModal();
        renderSuggestions();
        taskInputEl && taskInputEl.focus();
    }

    function wireGroupEditModal(){
        const backdrop = document.getElementById("groupEditBackdrop");
        if (!backdrop) return;

        const btnClose = document.getElementById("groupEditClose");
        const btnCancel = document.getElementById("groupEditCancel");
        const btnSave = document.getElementById("groupEditSave");
        const btnClear = document.getElementById("groupEditColorClear");

        const onClose = (e) => { e && e.preventDefault && e.preventDefault(); closeGroupEditModal(); };

        btnClose && btnClose.addEventListener("click", onClose);
        btnCancel && btnCancel.addEventListener("click", onClose);
        btnSave && btnSave.addEventListener("click", (e) => { e.preventDefault(); saveGroupEditModal(); });

        btnClear && btnClear.addEventListener("click", (e) => {
            e.preventDefault();
            const colorEl = document.getElementById("groupEditColor");
            if (colorEl) colorEl.value = "#111827";
            if (editingGroupId) {
                const g = getGroupById(editingGroupId);
                if (g) g.color = "";
            }
        });

        // click outside modal closes
        backdrop.addEventListener("mousedown", (e) => {
            if (e.target === backdrop) closeGroupEditModal();
        });

        // Enter saves, ESC closes (only when modal open)
        document.addEventListener("keydown", (e) => {
            const isOpen = backdrop.style.display !== "none" && backdrop.style.display !== "";
            if (!isOpen) return;
            if (e.key === "Escape" || e.key === "Esc") {
                e.preventDefault();
                closeGroupEditModal();
                return;
            }
            if (e.key === "Enter") {
                // avoid saving when inside color input? still ok
                e.preventDefault();
                saveGroupEditModal();
            }
        }, true);
    }



</script>


<!-- Group Edit Modal -->
<div id="groupEditBackdrop" class="group-edit-backdrop" style="display:none;">
  <div class="group-edit-modal" role="dialog" aria-modal="true" aria-labelledby="groupEditTitle">
    <div class="group-edit-header">
      <div id="groupEditTitle" class="group-edit-title">Rediger gruppe</div>
      <button type="button" id="groupEditClose" class="group-edit-close" title="Lukk">×</button>
    </div>
    <div class="group-edit-body">
      <label class="group-edit-label" for="groupEditName">Navn</label>
      <input id="groupEditName" type="text" class="group-edit-input" placeholder="Gruppe-navn">

      <label class="group-edit-label" for="groupEditColor">Tekstfarge</label>
      <div class="group-edit-colorrow">
        <input id="groupEditColor" type="color" class="group-edit-color">
        <button type="button" id="groupEditColorClear" class="btn-secondary" style="padding:0.35rem 0.6rem;">Nullstill</button>
      </div>

      <div class="group-edit-actions">
        <button type="button" id="groupEditSave" class="btn-primary">Lagre</button>
        <button type="button" id="groupEditCancel" class="btn-secondary">Avbryt</button>
      </div>
    </div>
  </div>
</div>


<div id="appNotesOverlay" class="overlay">
    <div class="modal">
        <button class="modal-close" id="appNotesCloseButton">&times;</button>
        <h2 id="appNotesModalTitle">Notater</h2>
        <div class="modal-row" style="width:100%;">
            <textarea id="appNotesTextarea" class="modal-textarea" placeholder="Skriv inn notater her ..."></textarea>
        </div>
        <div class="modal-footer">
            <button id="appNotesSaveButton" class="modal-button-primary" type="button">Lagre</button>
        </div>
        <div class="helper-text" style="text-align:center; margin-top: 0.75rem;">ESC eller klikk utenfor = lagre</div>
    </div>
</div>


<script>
(function(){
    const btn = document.getElementById("appNotesButton");
    const overlay = document.getElementById("appNotesOverlay");
    const closeBtn = document.getElementById("appNotesCloseButton");
    const saveBtn = document.getElementById("appNotesSaveButton");
    const textarea = document.getElementById("appNotesTextarea");
    const indicator = document.getElementById("appNotesIndicator");

    let appNotesAutosaveTimer = null;
    const scheduleAppNotesAutosave = () => {
        if (appNotesAutosaveTimer) clearTimeout(appNotesAutosaveTimer);
        appNotesAutosaveTimer = setTimeout(() => {
            try { saveNotes(); } catch(e){}
        }, 400);
    };

    function ensureNotesField(){
        if(typeof data === "object" && data){
            if(typeof data.appNotes !== "string"){
                data.appNotes = "";
            }
        }
    }

    function updateIndicator(){
        if(!indicator) return;
        const val = (textarea?.value ?? data?.appNotes ?? "");
        indicator.style.display = (String(val).trim().length > 0) ? "inline-block" : "none";
    }


    function loadNotes(){
        if(typeof data === "object" && data){
            ensureNotesField();
            textarea.value = data.appNotes || "";
            updateIndicator();
        }
    }

    function saveNotes(){
        if(typeof data === "object" && data){
            ensureNotesField();
            data.appNotes = textarea.value || "";
            updateIndicator();
            if(typeof saveToStorage === "function"){
                saveToStorage();
            }
        }
    }

    function openOverlay(){
        loadNotes();
        overlay.classList.add("show");
        textarea.focus();
    }

    function closeOverlay(save=true){
        if(save){
            saveNotes();
        }
        overlay.classList.remove("show");
    }

    btn?.addEventListener("click", openOverlay);
    closeBtn?.addEventListener("click", () => closeOverlay(true));
    saveBtn?.addEventListener("click", () => closeOverlay(true));
    textarea?.addEventListener("input", () => { updateIndicator(); scheduleAppNotesAutosave(); });

    overlay?.addEventListener("click", (e) => {
        if(e.target === overlay){
            closeOverlay(true);
        }
    });

    document.addEventListener("keydown", (e) => {
        if(!overlay.classList.contains("show")) return;
        if(e.key === "Escape"){
            closeOverlay(true);
        }
    });

    // Also reload notes when profile changes (if profile system triggers loadData)
    document.addEventListener("profileLoaded", () => {
        loadNotes();
        updateIndicator();
    });

    // Attempt initial sync after page load

    window.addEventListener("beforeunload", () => {
        try { saveNotes(); } catch(e){}
    });

    window.addEventListener("load", () => {
        setTimeout(() => { ensureHelpTextContainers(document.body); loadNotes(); updateIndicator(); }, 50);
    });

})();
</script>




<style id="frutigerMusicPlayerDisablePatch">
#frutigerMusicPlayerWrap{ display:none !important; }
</style>
<script id="frutigerMusicPlayerOpenTabPatch">
(function(){
  const MUSIC_URL = 'https://frutigeraeroarchive.org/music';
  function bindFrutigerMusicOpenTabButton(){
    const btn = document.getElementById('toggleFrutigerMusicPlayerButton');
    if (!btn) return false;
    btn.setAttribute('aria-pressed', 'false');
    btn.classList.remove('active');
    btn.addEventListener('click', function(e){
      try{
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
      }catch(_){}
      try { window.open(MUSIC_URL, '_blank', 'noopener,noreferrer'); }
      catch(_) { try { window.open(MUSIC_URL, '_blank'); } catch(__){} }
      return false;
    }, true); // capture phase: blocks existing player logic
    return true;
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bindFrutigerMusicOpenTabButton, { once:true });
  } else {
    bindFrutigerMusicOpenTabButton();
  }
})();
</script>

</body>

</html>


